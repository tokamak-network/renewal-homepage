import Vue from "vue";
import Vuex from "vuex";

// import Web3 from "web3";
import axios from "axios";

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    web3: null,
    posts: [],
    roadmap: [],
    launched: false,
    loaded: false,
    locale: "en_US",
    roadmapEN: [
      {
        index: "0",
        subject: "Networking the Layer 2 networks",
        title: "Support all types of layer 2 protocol in Tokamak Network.",
        contents: [
          "Support Optimistic Rollup : Optimism, Arbitrum, and more",
          "Support Zk-Rollup : StarkEx, zkSync, and more",
          "Support Validium : StarkEx and more",
          "Support Plasma : Tokamak plasma and more",
          "Add custom layer 2 building protocol",
        ],
      },
      {
        index: "1",
        subject: "Networking the Layer 2 networks",
        title: "Integrate all types of layer 2 protocols with TON ecosystem",
        contents: [
          "Integrate all layer 2 protocols with TON seigniorage pool, PowerTON game, and DAO governance",
        ],
      },
      {
        index: "2",
        subject: "Networking the Layer 2 networks",
        title: "Support one-click cross-rollup transfer",
        contents: ["Build cross-rollup transfer liquidity pool"],
      },
      {
        index: "3",
        subject: "Networking the Layer 2 networks",
        title: "Support fast withdrawal",
        contents: ["Build fast withdrawal liquidity pool"],
      },
      {
        index: "4",
        subject: "Networking the Layer 2 networks",
        title: "Support full verification from day one ",
        contents: [
          "Implement attention challenge",
          "Build additional reward pool for intermediaries of fast withdrawal and cross-rollup transfer",
        ],
      },
      {
        index: "5",
        subject: "Higher security, More Interoperability",
        title: "Eth 2.0 migration",
        contents: ["Migrate rollup data storage to Eth 2.0"],
      },
      {
        index: "6",
        subject: "Higher security, More Interoperability",
        title: "Support cross-contract call",
        contents: ["Support arbitrary message call between rollups"],
      },
      {
        index: "7",
        subject: "Higher security, More Interoperability",
        title: "Support stateless verification",
        contents: ["Add light-verification mode"],
      },
      {
        index: "8",
        subject: "Full verification with zkp",
        title: "Support fully Ethereum-compatible zk rollups",
        contents: [
          "Migrate all layer 2 protocols based on fraud proof based layer 2 to validity proof basis",
        ],
      },
    ],
    roadmapKR: [
      {
        index: "0",
        subject: "Networking the Layer 2 networks",
        title: "모든 레이어 2 프로토콜 지원",
        contents: [
          "Optimistic Rollup 지원: Optimism, Arbitrum 등",
          "Zk-Rollup 지원: StarkEx, zkSync 등",
          "Validium 지원: StarkEx 등",
          "Plasma 지원: Tokamak plasma 등",
          "커스텀 레이어 2 개발 프로토콜 구축",
        ],
      },
      {
        index: "1",
        subject: "Networking the Layer 2 networks",
        title: "TON 생태계와 각 레이어 2 프로토콜 통합 및 지원",
        contents: [
          "톤 시뇨리지 풀, 파워톤 게임, DAO 거버넌스와 레이어 2 프로토콜 간의 통합",
        ],
      },
      {
        index: "2",
        subject: "Networking the Layer 2 networks",
        title: "원클릭 크로스 롤업 전송 지원",
        contents: ["크로스 롤업 전송 유동성 풀 구축"],
      },
      {
        index: "3",
        subject: "Networking the Layer 2 networks",
        title: "빠른 출금 지원",
        contents: ["빠른 출금 유동성 풀 구축"],
      },
      {
        index: "4",
        subject: "Networking the Layer 2 networks",
        title: "레이어 2 완전 검증 지원",
        contents: [
          "주의 챌린지 구현",
          "빠른 출금과 크로스 롤업 중개인들을 위한 추가 보상 풀 구축",
        ],
      },
      {
        index: "5",
        subject: "Higher security, More Interoperability",
        title: "이더리움 2.0 마이그레이션",
        contents: ["롤업 데이터 스토리지 이더리움 2.0으로 이전"],
      },
      {
        index: "6",
        subject: "Higher security, More Interoperability",
        title: "크로스 컨트랙트 콜 지원",
        contents: ["롤업 간 임의 메세지 콜 지원"],
      },
      {
        index: "7",
        subject: "Higher security, More Interoperability",
        title: "스테이트리스 검증 지원",
        contents: ["라이트 검증 모드 지원"],
      },
      {
        index: "8",
        subject: "Full verification with zkp",
        title: "이더리움 완전 호환 및 검증 레이어 2 지원",
        contents: [
          "위조 증명 기반의 모든 레이어 2 프로토콜을 유효성 증명 기반으로 마이그레이션 ",
        ],
      },
    ],
    roadmapCN: [
      {
        index: "0",
        subject: "Networking the Layer 2 networks",
        title: "支持坦克网络（Tokamak Network）中的所有类型的二层协议",
        contents: [
          "支持Optimistic Rollup：Optimism、Arbitrum等",
          "支持Zk-Rollup：StarkEx、zkSync等",
          "支持Validium：StarkEx等",
          "支持Plasma：Tokamak plasma等",
          "添加自定义二层构建协议",
        ],
      },
      {
        index: "1",
        subject: "Networking the Layer 2 networks",
        title: "将所有类型的二层协议与TON生态系统集成在一起",
        contents: [
          "将所有二层协议与TON铸币池、PowerTON游戏和DAO治理集成在一起",
        ],
      },
      {
        index: "2",
        subject: "Networking the Layer 2 networks",
        title: "支持一键式跨Rollup转移",
        contents: ["建立跨Rollup转移的流动资金池"],
      },
      {
        index: "3",
        subject: "Networking the Layer 2 networks",
        title: "支持快速提现",
        contents: ["建立快速提现的流动资金池"],
      },
      {
        index: "4",
        subject: "Networking the Layer 2 networks",
        title: "从第一天开始就支持全面验证",
        contents: [
          "实施注意力挑战",
          "为快速提现和跨Rollup转移的中介方建立额外奖励池",
        ],
      },
      {
        index: "5",
        subject: "Higher security, More Interoperability",
        title: "以太坊2.0迁移",
        contents: ["将Rollup数据存储迁移到以太坊2.0"],
      },
      {
        index: "6",
        subject: "Higher security, More Interoperability",
        title: "支持跨合约调用",
        contents: ["支持Rollup间的任意消息调用"],
      },
      {
        index: "7",
        subject: "Higher security, More Interoperability",
        title: "支持无状态验证",
        contents: ["添加轻验证模式"],
      },
      {
        index: "8",
        subject: "Full verification with zkp",
        title: "支持完全与以太坊兼容，支持可验证二层网络",
        contents: ["迁移所有基于欺诈证明和有效性证明的二层协议"],
      },
    ],
  },
  mutations: {
    SET_WEB3(state, web3) {
      state.web3 = web3;
    },
    SET_POSTS(state, posts) {
      state.posts = posts;
    },
    SET_ROADMAP(state, roadmap) {
      state.roadmap = roadmap;
    },
    SET_TOTALSTAKED: (state, totalStaked) => {
      state.totalStaked = totalStaked;
    },
    SET_USD: (state, usd) => {
      state.usd = usd;
    },
    SET_LOADED: (state, loaded) => {
      state.loaded = loaded;
    },
    SET_INFO: (state, info) => {
      state.info = info;
    },
    SET_LOCALE: (state, { locale }) => {
      state.locale = locale;
    },
    LAUNCHED(state) {
      state.launched = true;
    },
  },
  actions: {
    async launch({ commit, dispatch, state }) {
      await dispatch("setPosts");
      await dispatch("getCurrencyInfo");
      await dispatch("getUSDInfo");
      await dispatch("getTotalStaked");
      await dispatch("setRoadMap", state.locale);
      commit("LAUNCHED");
      dispatch("setLoaded");
    },
    updateData(context) {
      setInterval(() => context.dispatch("getCurrencyInfo"), 60000);
      setInterval(() => context.dispatch("getUSDInfo"), 60000);
      setInterval(() => context.dispatch("getTotalStaked"), 60000);
    },
    async getCurrencyInfo(context) {
      await axios
        .get("https://api.upbit.com/v1/ticker?markets=KRW-TON")
        .then((response) => {
          context.commit(
            "SET_INFO",
            JSON.parse(JSON.stringify(response.data).replace(/]|[[]/g, ""))
          );
        });
    },
    async getTotalStaked(context) {
      await axios
        .get("https://price-api.tokamak.network/staking/current")
        .then((response) => {
          context.commit("SET_TOTALSTAKED", response.data);
        });
    },
    async getUSDInfo(context) {
      await axios
        .get("https://api.frankfurter.app/latest?from=KRW")
        .then((response) => context.commit("SET_USD", response.data.rates.USD));
    },
    async setLoaded(context) {
      await context.commit("SET_LOADED", true);
    },
    setLocale({ commit }, val) {
      commit("SET_LOCALE", val);
    },
    async setRoadMap({ commit, state }, locale) {
      let roadmap;
      if (locale === "en_US") {
        roadmap = state.roadmapEN;
      } else if (locale === "ko_KR") {
        roadmap = state.roadmapKR;
      } else {
        roadmap = state.roadmapCN;
      }

      commit("SET_ROADMAP", roadmap);
    },
    async setPosts({ commit }) {
      await axios
        .get(
          "https://cors-anywhere.herokuapp.com/https://api.rss2json.com/v1/api.json?rss_url=https://medium.com/feed/onther-tech"
        )
        .then((res) => {
          commit("SET_POSTS", res.data.items);
        })
        .catch((error) => {
          console.log(error);
          const contents = {
            status: "ok",
            feed: {
              url: "https://medium.com/feed/onther-tech",
              title: "Onther - Medium",
              link:
                "https://medium.com/onther-tech?source=rss----eb8117f0bafd---4",
              author: "",
              description:
                "Building an Ethereum Blockchain ECO system to Change the World - Medium",
              image:
                "https://cdn-images-1.medium.com/proxy/1*TGH72Nnw24QL3iV9IOm4VA.png",
            },
            items: [
              {
                title:
                  "Tokamak Network has signed MOU with Ozys and supports KlaySwap [EN/KR]",
                pubDate: "2021-06-01 07:00:08",
                link:
                  "https://medium.com/onther-tech/tokamak-network-has-signed-mou-with-ozys-and-supports-klayswap-en-kr-e280b4426810?source=rss----eb8117f0bafd---4",
                guid: "https://medium.com/p/e280b4426810",
                author: "Onther",
                thumbnail:
                  "https://cdn-images-1.medium.com/max/1024/1*RFNH3BMC2q7-Kb6fBz3cxA.png",
                description:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RFNH3BMC2q7-Kb6fBz3cxA.png"></figure><p>Hello!</p>\n<p>This is On-demand Ethereum Layer 2 Platform ‘Tokamak Network’.</p>\n<p>Tokamak Network has signed an MOU with Ozys, a blockchain technology company regarding the use of the Orbit bridge and research advice on the bridge between heterogeneous chains and Ethereum Layer 2. We will also participate in the KlaySwap developed by Ozys.</p>\n<h3><strong>What is Ozys?</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8_bH41RbWIHqeVh2eEec1Q.png"></figure><p>Ozys is operating ‘<a href="https://klayswap.com/"><strong>Klayswap</strong></a>’, a DeFi protocol launched last November based on Klaytn which is the blockchain platform of Kakao’s blockchain technology affiliate Ground X. KlaySwap is a decentralized financial swap protocol based on Automated Market Maker (AMM). Currently, it has a total value of about $1.3 billion in its liquidity and deposits.</p>\n<h3>What we will do?</h3>\n<p>The details of this business agreement are as follows.</p>\n<ul>\n<li>TON ecosystem expansion using Orbit chain bridge (Klaytn, BSC, HECO, etc.)</li>\n<li>Research advice on the bridge between heterogeneous chains and Ethereum Layer 2</li>\n<li>Providing liquidity for KLAY-(K)TON in Klayswap</li>\n<li>Joint marketing</li>\n</ul>\n<h3>What can we expect?</h3>\n<p>We plan to expand the TON ecosystem through Orbit Bridge, a tool that supports token swap between mainnets of heterogeneous chains developed by Ozys. The TON ecosystem is planned to expand to chains where the DeFi ecosystem is rapidly growing, such as Klaytn, Binance Smart Chain (BSC), and Huobi ECO chain (HECO). We expect that global users who have had difficult access to our ecosystem will be able to more easily participate through Klayswap (Klaytn), Pancake Swap (BSC), and more.</p>\n<p>Tokamak Network will also provide advice on research for a bridge between Ethereum-based Layer 2 and other mainnets provided Orbit Bridge supports Ethereum-based Layer 2.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*yAzUZe-GFbUfQ6TrXDOuhw.png"></figure><p>In order to deposit TON into KlaySwap, users first need to convert the mainnet to KTON through <a href="https://bridge.orbitchain.io/"><strong>Orbit Bridge</strong></a>, a tool that supports token conversion between mainnets. (<a href="https://bridge.orbitchain.io/assets/orbitbridge_guide_en.pdf"><strong>Conversion Guide</strong></a>) Tokamak Network expects to secure liquidity between the two cryptocurrencies by creating a TON-Klaytn pair and supplying initial liquidity to Klayswap which operates as a 100% smart contract on the Klaytn blockchain. Through this, users can directly exchange TON and Klay without a separate intermediate process, and users who provide liquidity can also receive a share of the fee generated from the pool.</p>\n<h3>One More Thing…</h3>\n<p>Tokamak Network is holding an airdrop event within KlaySwap to commemorate the cooperation with Ozys and support for KlaySwap.</p>\n<p>The event will be held for 2 months from the creation of the TON-KLAY pool in KlaySwap, and airdrops will be distributed to participants according to their contribution. You can check the details related to the event on the <a href="https://klayswap.com/">KlaySwap webpage</a>.</p>\n<p>We believe that this agreement has opened up the possibility of using TON in other chain ecosystems. In particular, it is expected that the ecosystem of Klaytn, one of the most attention-grabbing blockchain projects in Korea, can be connected with Tokamak Network.</p>\n<p>Thank you!</p>\n<p>안녕하세요</p>\n<p>온디맨드 이더리움 레이어 2 플랫폼 ‘토카막 네트워크’입니다.</p>\n<p>토카막 네트워크가 블록체인 기술 기업 오지스와 오르빗 브릿지 활용 및 이종체인과 레이어 2 간의 브릿지 연구 자문 관련한 업무협약(MOU)을 체결하고 오지스가 개발한 클레이스왑에 참여합니다.</p>\n<h3>What is Ozys?</h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8_bH41RbWIHqeVh2eEec1Q.png"></figure><p>오지스는 카카오 블록체인 기술 계열사 그라운드X의 블록체인 플랫폼인 클레이튼을 기반으로 한 디파이 프로토콜 ‘<a href="https://klayswap.com/"><strong>클레이스왑</strong></a>’을 지난해 11월 출시해 운영 중입니다. 클레이스왑은 자동화 마켓메이커(Automated Market Maker, AMM) 기반의 탈중앙 금융 스왑 프로토콜 현재 약 13억 달러 규모의 유동성 및 예치가 진행되고 있습니다.</p>\n<h3>What we will do?</h3>\n<p>이번 업무 협약에 대한 세부 내용은 다음과 같습니다.</p>\n<ul>\n<li>오르빗 체인의 브릿지를 활용한 TON 생태계 확장(Klaytn, BSC, HECO 등)</li>\n<li>이더리움 레이어2 — 이종체인 간 브릿지에 대한 연구 자문</li>\n<li>클레이 스왑(Klayswap)에 KLAY-(K)TON 유동성 제공</li>\n<li>공동 마케팅 진행</li>\n</ul>\n<h3>What can we expect?</h3>\n<p>오지스에서 개발한 이종 체인의 메인넷 간의 토큰 전환을 지원하는 툴인 오르빗 브릿지를 통하여, TON의 생태계를 확장해 나갈 예정입니다. Klaytn, Binance Smart Chain(BSC), Huobi ECO chain(HECO) 등 DeFi 생태계가 빠르게 성장하고 있는 체인으로의 TON 생태계를 확장해나갈 예정입니다. Klayswap(Klaytn), Pancake Swap(BSC)등을 통하여, 그동안 접근이 어려웠던 글로벌 유저들이 TON 생태계에 더 쉽게 참여할 수 있을 것으로 기대하고 있습니다.</p>\n<p>오르빗 브릿지에서 이더리움 기반의 레이어2를 지원하는 경우, 토카막 네트워크는 이더리움 기반의 레이어2와 다른 메인넷 간 브릿지를 위한 연구에 대한 자문을 지원할 예정입니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*yAzUZe-GFbUfQ6TrXDOuhw.png"></figure><p>TON을 클레이스왑에 예치하기 위해서는 메인넷 간의 토큰 전환을 지원하는 툴인 <a href="https://bridge.orbitchain.io/"><strong>오르빗브릿지</strong></a>를 통해 KTON으로 메인넷을 전환한 후 이용이 가능합니다(<a href="https://bridge.orbitchain.io/assets/orbitbridge_guide_ko.pdf"><strong>전환 가이드</strong></a>). 토카막 네트워크는 클레이튼 블록체인에서 100% 스마트 컨트랙트로 동작하는 클레이스왑에 톤-클레이튼 페어를 생성하고 초기 유동성을 공급함으로써, 두 암호화폐 간의 유동성이 확보될 것으로 기대하고 있습니다. 이를 통해 사용자들은 별도의 중간 과정 없이 톤과 클레이를 직접 교환할 수 있으며, 유동성을 공급한 사용자는 해당 풀에서 발생하는 수수료를 공유 받을 수도 있습니다.</p>\n<h3>One more thing…</h3>\n<p>토카막 네트워크는 오지스와 업무 협약 및 클레이스왑 지원을 기념해 클래이스왑내 에어드랍 이벤트를 진행합니다.</p>\n<p>이벤트 기간은 클레이스왑에 TON-KLAY 풀이 생성된 이후부터 2개월간이며, 참여한 사람에게는 기여도에 따라 차등적으로 에어드롭이 지급될 예정입니다. 이벤트와 관련된 자세한 내용은 <a href="https://klayswap.com/"><strong>클레이스왑 웹페이지</strong></a>에서 확인이 가능합니다.</p>\n<p>저희는 이번 협약을 시작으로 톤을 다른 체인 생태계에서 활용할 수 있는 가능성을 열었다고 생각합니다. 특히 국내에서 가장 주목 받고 있는 블록체인 프로젝트 중 하나인 클레이튼의 생태계를 토카막 네트워크로 연계할 수 있을 것으로 기대합니다.</p>\n<p>감사합니다.</p>\n<h3>* Tokamak Official Channels</h3>\n<p>📌Tokamak Global Telegram: <a href="https://t.me/tokamak_network">https://t.me/tokamak_network</a><br>📌Tokamak Global Discord: <a href="https://discord.gg/WjwRezbJY8">https://discord.gg/WjwRezbJY8</a><br>📌Tokamak Network Homepage: <a href="https://tokamak.network/#/">https://tokamak.network/#/</a><br>📌Tokamak Network Twitter: <a href="https://twitter.com/tokamak_network">https://twitter.com/tokamak_network</a><br>📌Tokamak Network Medium: <a href="https://medium.com/onther-tech">https://medium.com/onther-tech</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e280b4426810" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/tokamak-network-has-signed-mou-with-ozys-and-supports-klayswap-en-kr-e280b4426810">Tokamak Network has signed MOU with Ozys and supports KlaySwap [EN/KR]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                content:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RFNH3BMC2q7-Kb6fBz3cxA.png"></figure><p>Hello!</p>\n<p>This is On-demand Ethereum Layer 2 Platform ‘Tokamak Network’.</p>\n<p>Tokamak Network has signed an MOU with Ozys, a blockchain technology company regarding the use of the Orbit bridge and research advice on the bridge between heterogeneous chains and Ethereum Layer 2. We will also participate in the KlaySwap developed by Ozys.</p>\n<h3><strong>What is Ozys?</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8_bH41RbWIHqeVh2eEec1Q.png"></figure><p>Ozys is operating ‘<a href="https://klayswap.com/"><strong>Klayswap</strong></a>’, a DeFi protocol launched last November based on Klaytn which is the blockchain platform of Kakao’s blockchain technology affiliate Ground X. KlaySwap is a decentralized financial swap protocol based on Automated Market Maker (AMM). Currently, it has a total value of about $1.3 billion in its liquidity and deposits.</p>\n<h3>What we will do?</h3>\n<p>The details of this business agreement are as follows.</p>\n<ul>\n<li>TON ecosystem expansion using Orbit chain bridge (Klaytn, BSC, HECO, etc.)</li>\n<li>Research advice on the bridge between heterogeneous chains and Ethereum Layer 2</li>\n<li>Providing liquidity for KLAY-(K)TON in Klayswap</li>\n<li>Joint marketing</li>\n</ul>\n<h3>What can we expect?</h3>\n<p>We plan to expand the TON ecosystem through Orbit Bridge, a tool that supports token swap between mainnets of heterogeneous chains developed by Ozys. The TON ecosystem is planned to expand to chains where the DeFi ecosystem is rapidly growing, such as Klaytn, Binance Smart Chain (BSC), and Huobi ECO chain (HECO). We expect that global users who have had difficult access to our ecosystem will be able to more easily participate through Klayswap (Klaytn), Pancake Swap (BSC), and more.</p>\n<p>Tokamak Network will also provide advice on research for a bridge between Ethereum-based Layer 2 and other mainnets provided Orbit Bridge supports Ethereum-based Layer 2.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*yAzUZe-GFbUfQ6TrXDOuhw.png"></figure><p>In order to deposit TON into KlaySwap, users first need to convert the mainnet to KTON through <a href="https://bridge.orbitchain.io/"><strong>Orbit Bridge</strong></a>, a tool that supports token conversion between mainnets. (<a href="https://bridge.orbitchain.io/assets/orbitbridge_guide_en.pdf"><strong>Conversion Guide</strong></a>) Tokamak Network expects to secure liquidity between the two cryptocurrencies by creating a TON-Klaytn pair and supplying initial liquidity to Klayswap which operates as a 100% smart contract on the Klaytn blockchain. Through this, users can directly exchange TON and Klay without a separate intermediate process, and users who provide liquidity can also receive a share of the fee generated from the pool.</p>\n<h3>One More Thing…</h3>\n<p>Tokamak Network is holding an airdrop event within KlaySwap to commemorate the cooperation with Ozys and support for KlaySwap.</p>\n<p>The event will be held for 2 months from the creation of the TON-KLAY pool in KlaySwap, and airdrops will be distributed to participants according to their contribution. You can check the details related to the event on the <a href="https://klayswap.com/">KlaySwap webpage</a>.</p>\n<p>We believe that this agreement has opened up the possibility of using TON in other chain ecosystems. In particular, it is expected that the ecosystem of Klaytn, one of the most attention-grabbing blockchain projects in Korea, can be connected with Tokamak Network.</p>\n<p>Thank you!</p>\n<p>안녕하세요</p>\n<p>온디맨드 이더리움 레이어 2 플랫폼 ‘토카막 네트워크’입니다.</p>\n<p>토카막 네트워크가 블록체인 기술 기업 오지스와 오르빗 브릿지 활용 및 이종체인과 레이어 2 간의 브릿지 연구 자문 관련한 업무협약(MOU)을 체결하고 오지스가 개발한 클레이스왑에 참여합니다.</p>\n<h3>What is Ozys?</h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8_bH41RbWIHqeVh2eEec1Q.png"></figure><p>오지스는 카카오 블록체인 기술 계열사 그라운드X의 블록체인 플랫폼인 클레이튼을 기반으로 한 디파이 프로토콜 ‘<a href="https://klayswap.com/"><strong>클레이스왑</strong></a>’을 지난해 11월 출시해 운영 중입니다. 클레이스왑은 자동화 마켓메이커(Automated Market Maker, AMM) 기반의 탈중앙 금융 스왑 프로토콜 현재 약 13억 달러 규모의 유동성 및 예치가 진행되고 있습니다.</p>\n<h3>What we will do?</h3>\n<p>이번 업무 협약에 대한 세부 내용은 다음과 같습니다.</p>\n<ul>\n<li>오르빗 체인의 브릿지를 활용한 TON 생태계 확장(Klaytn, BSC, HECO 등)</li>\n<li>이더리움 레이어2 — 이종체인 간 브릿지에 대한 연구 자문</li>\n<li>클레이 스왑(Klayswap)에 KLAY-(K)TON 유동성 제공</li>\n<li>공동 마케팅 진행</li>\n</ul>\n<h3>What can we expect?</h3>\n<p>오지스에서 개발한 이종 체인의 메인넷 간의 토큰 전환을 지원하는 툴인 오르빗 브릿지를 통하여, TON의 생태계를 확장해 나갈 예정입니다. Klaytn, Binance Smart Chain(BSC), Huobi ECO chain(HECO) 등 DeFi 생태계가 빠르게 성장하고 있는 체인으로의 TON 생태계를 확장해나갈 예정입니다. Klayswap(Klaytn), Pancake Swap(BSC)등을 통하여, 그동안 접근이 어려웠던 글로벌 유저들이 TON 생태계에 더 쉽게 참여할 수 있을 것으로 기대하고 있습니다.</p>\n<p>오르빗 브릿지에서 이더리움 기반의 레이어2를 지원하는 경우, 토카막 네트워크는 이더리움 기반의 레이어2와 다른 메인넷 간 브릿지를 위한 연구에 대한 자문을 지원할 예정입니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*yAzUZe-GFbUfQ6TrXDOuhw.png"></figure><p>TON을 클레이스왑에 예치하기 위해서는 메인넷 간의 토큰 전환을 지원하는 툴인 <a href="https://bridge.orbitchain.io/"><strong>오르빗브릿지</strong></a>를 통해 KTON으로 메인넷을 전환한 후 이용이 가능합니다(<a href="https://bridge.orbitchain.io/assets/orbitbridge_guide_ko.pdf"><strong>전환 가이드</strong></a>). 토카막 네트워크는 클레이튼 블록체인에서 100% 스마트 컨트랙트로 동작하는 클레이스왑에 톤-클레이튼 페어를 생성하고 초기 유동성을 공급함으로써, 두 암호화폐 간의 유동성이 확보될 것으로 기대하고 있습니다. 이를 통해 사용자들은 별도의 중간 과정 없이 톤과 클레이를 직접 교환할 수 있으며, 유동성을 공급한 사용자는 해당 풀에서 발생하는 수수료를 공유 받을 수도 있습니다.</p>\n<h3>One more thing…</h3>\n<p>토카막 네트워크는 오지스와 업무 협약 및 클레이스왑 지원을 기념해 클래이스왑내 에어드랍 이벤트를 진행합니다.</p>\n<p>이벤트 기간은 클레이스왑에 TON-KLAY 풀이 생성된 이후부터 2개월간이며, 참여한 사람에게는 기여도에 따라 차등적으로 에어드롭이 지급될 예정입니다. 이벤트와 관련된 자세한 내용은 <a href="https://klayswap.com/"><strong>클레이스왑 웹페이지</strong></a>에서 확인이 가능합니다.</p>\n<p>저희는 이번 협약을 시작으로 톤을 다른 체인 생태계에서 활용할 수 있는 가능성을 열었다고 생각합니다. 특히 국내에서 가장 주목 받고 있는 블록체인 프로젝트 중 하나인 클레이튼의 생태계를 토카막 네트워크로 연계할 수 있을 것으로 기대합니다.</p>\n<p>감사합니다.</p>\n<h3>* Tokamak Official Channels</h3>\n<p>📌Tokamak Global Telegram: <a href="https://t.me/tokamak_network">https://t.me/tokamak_network</a><br>📌Tokamak Global Discord: <a href="https://discord.gg/WjwRezbJY8">https://discord.gg/WjwRezbJY8</a><br>📌Tokamak Network Homepage: <a href="https://tokamak.network/#/">https://tokamak.network/#/</a><br>📌Tokamak Network Twitter: <a href="https://twitter.com/tokamak_network">https://twitter.com/tokamak_network</a><br>📌Tokamak Network Medium: <a href="https://medium.com/onther-tech">https://medium.com/onther-tech</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e280b4426810" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/tokamak-network-has-signed-mou-with-ozys-and-supports-klayswap-en-kr-e280b4426810">Tokamak Network has signed MOU with Ozys and supports KlaySwap [EN/KR]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                enclosure: {},
                categories: [
                  "blockchain",
                  "layer-2",
                  "partnerships",
                  "tokamak-network",
                  "ethereum",
                ],
              },
              {
                title:
                  "블록체인 확장성의 한계(The Limits to Blockchain Scalability)",
                pubDate: "2021-05-27 09:10:47",
                link:
                  "https://medium.com/onther-tech/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%99%95%EC%9E%A5%EC%84%B1%EC%9D%98-%ED%95%9C%EA%B3%84-the-limits-to-blockchain-scalability-802b3e036384?source=rss----eb8117f0bafd---4",
                guid: "https://medium.com/p/802b3e036384",
                author: "박정원(Aiden Park)",
                thumbnail:
                  "https://cdn-images-1.medium.com/max/598/0*svNLkj58FEGvhF-c",
                description:
                  '\n<blockquote>이 글은 비탈릭 부테린(Vitalik Buterin)의 글 <a href="https://vitalik.ca/general/2021/05/23/scaling.html">The Limits to Blockchain Scalability</a>을 Aiden, Gwen이 우리말로 옮겨 쓴 글이다.</blockquote>\n<blockquote>최근 ‘도지파더(Dogefather)\' 일론 머스크가 도지코인의 우월한 확장성에 대해 주장한 트윗이 화제가 되면서 블록체인 확장성에 대한 논의가 활발하게 이뤄졌다. 비탈릭 부테린은 이 글을 통해 일론 머스크의 주장에 대해 직간접적으로 답변하여 또 다른 많은 화제를 낳았다.</blockquote>\n<blockquote>그 동안 블록체인 확장성을 다룬 수 많은 글들이 있었지만, 왜 확장성을 쉽게 높이는 것이 어려운지에 대해 구체적으로 다룬 글은 흔치 않았다. 이 글은 이러한 내용에 대해 매우 자세하고 쉽게(?) 다루고 있으므로, 블록체인 확장성에 관심이 있는 분들에게 이 글이 큰 도움이 될 것이라 생각한다.</blockquote>\n<p><em>Special thanks to Felix Lange, Martin Swende, Marius van der Wijden and Mark Tyneway for feedback and review.</em></p>\n<p>블록체인의 확장성을 얼마나 높일 수 있을까? 정말 <a href="https://twitter.com/elonmusk/status/1393738154889338884">일론 머스크가 바라는 대로</a>, “블록 타임을 10배 빠르게 만들고, 블록 크기를 10배로 늘리고, 수수료는 100배 줄이는” 것이 극단적인 중앙화와 블록체인의 핵심 가치에 대한 훼손 없이 가능할까? 만약 그럴 수 없다면, 확장성을 어디까지 높일 수 있을까? 컨센서스 알고리즘을 바꾼다면 어떻게 될까? 더 나아가, ZK-SNARKs 또는 샤딩(sharding)과 같은 새로운 기능을 도입하여 기술을 개선하면 어떻게 될까? 이론적으로 샤딩 체인은 더 많은 샤드(shard)를 계속해서 추가할 수 있는데, 이러한 것이 정말 가능한걸까?</p>\n<p>나중에 알려진 사실이지만, 샤딩이 적용된 체인이나 적용되지 않은 체인 두가지 모든 경우에 대해 블록체인의 확장을 제한하는 여러가지 중요하고 미묘한 기술적 요인들이 있다. 대부분의 경우 이에 대한 해결책이 존재하지만, 이러한 해결책에도 한계는 분명히 존재한다. 이 글은 이러한 이슈들에 대해 다루고자 한다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/598/0*svNLkj58FEGvhF-c"><figcaption><em>단순히 파라미터 값을 늘리면 모든 문제가 해결된다. 하지만 여기서 우리가 잃는 것은 무엇인가?</em></figcaption></figure><h3><strong>블록체인 탈중앙화의 핵심은 일반 사용자들이 노드를 운영할 수 있도록 하는 것이다</strong></h3>\n<p>새벽 2시 35분, 당신은 지구 반대편에 위치한 마이닝 풀(또는 스테이킹 풀)의 운영을 돕고 있는 파트너로부터 긴급한 전화를 받는다. 파트너가 말하길, 약 14분 전부터 당신의 풀을 포함한 다른 몇개의 풀들이 전체 네트워크의 79%를 이끌고 있는 체인으로부터 분리되었다고 한다. 하지만 당신의 노드에 따르면, 다수가 동의한 해당 체인의 블록들은 유효하지 않은 것으로 확인된다. 해당 체인은 잔액 기록에 대한 오류가 발생했으며, 구체적으로 특정 키 블록(key block)에서 알 수 없는 주소에 450만개의 코인을 추가로 잘못 할당한 것으로 보인다.</p>\n<p>한 시간 후, 당신과 똑같이 매우 혼란스러워 하고 있는 다른 두개의 소규모 풀 업체와 소수의 블록 익스플로러 및 거래소 업체가 함께 속해 있는 텔레그램 채팅방에서 누군가 어떤 트윗에 대한 링크 하나를 올린다. 그 트윗은 다음과 같이 시작 한다.</p>\n<p><em>“지속가능한 새로운 온체인 프로토콜 개발 펀드를 발표합니다.”</em></p>\n<p>날이 밝자, 트위터와 검열이 없는 커뮤니티 포럼에서 모든 사람들이 이에 대해 활발하게 논쟁하고 있다. 하지만 그 동안 이미 450만개의 코인 중 상당 부분은 온체인에서 다른 자산으로 변환 되었고, 수십억 달러 규모의 디파이(defi) 트랜잭션들이 발생한 상황이다. 컨센서스 노드의 79%와 모든 주요 블록 익스플로러 및 라이트 월렛(light wallet)의 엔드포인트 또한 계속해서 이 새로운 체인을 따르고 있다. 이렇게 조성된 새로운 개발 펀드는 실제로 개발을 위한 자금을 조달하는데 사용될수도 있겠지만, 반대로 이를 주도한 여러 주요 풀과 거래소 및 이들의 지지자들이 이 자금을 모두 횡령할 수도 있을 것이다. 하지만 그 결과가 어떻게 되든, 이러한 펀드가 조성 되었다는 것은 이미 일어난 사실이며, 평범한 사용자들은 이에 대항할 방법이 없는 것이 현실이다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/511/0*7k2CX9ONLMK4Olq-"><figcaption><em>개봉 예정작. MolochDAO 같은 곳에서 펀딩을 받을 수 있을 지도 모르겠다.</em></figcaption></figure><p>이런 일이 당신이 사용하는 블록체인에서도 발생할 수도 있을까? 당신이 속한 블록체인 커뮤니티의 핵심 구성원들, 즉 주요 마이닝(스테이킹) 풀, 블록 익스플로러 및 호스트 노드들은 서로 매우 긴밀하게 협력하고 있을 가능성이 높다. 아마 이들은 모두 동일한 텔레그램 채널과 위챗 그룹에 속해 있을 것이다. 만약 이들이 정말로 본인들의 이익을 위해 프로토콜 규칙을 갑자기 변경하고 싶다면, 충분히 그렇게 할 수도 있을 것이다. 이더리움 블록체인은 10시간 만에 <a href="https://blog.ethereum.org/2016/11/25/security-alert-11242016-consensus-bug-geth-v1-4-19-v1-5-2/">컨센서스 오류</a>를 완전히 해결할 수 있었다. 하지만 당신이 사용하는 블록체인의 클라이언트 구현체가 단 하나이고, 클라이언트 코드 변경을 위해 수십개의 노드에만 이를 배포하는 것으로 충분하다면 이러한 공격은 훨씬 수월할 것이다. 이런 방식의 조직화된 사회적 공격을 효과적으로 방지할 수 있는 유일한 방법은 실질적으로 탈중앙화된 구성원, 즉 <strong>사용자</strong>들을 통한 수동적 방어(passive defense) 시스템을 구축하는 것이다.</p>\n<p>만약 사용자들이 체인을 검증하는 노드를 운영(직접 검증하거나 또는 <a href="https://vitalik.ca/general/2021/04/07/sharding.html#improving-sharding-with-better-security-models">개선된 기술을 통해 간접적으로 검증하든</a>)한다고 가정 해보자. 프로토콜 규칙을 위반한 블록을 심지어 90%이상의 마이너나 스테이커들이 지지하더라도 사용자들의 노드가 이 블록들을 자동적으로 거부한다면 이 이야기는 어떻게 전개될까? <strong>모든</strong> 사용자가 검증 노드를 운영했다면 이러한 공격은 빠르게 실패했을 것이다. 몇몇 마이닝 풀과 거래소가 포크해서 나갈수도 있지만, 이는 매우 어리석은 행동처럼 비춰질 것이다. 심지어 모든 사용자가 아니라 일부 사용자만이라도 검증 노드를 운영했다면, 공격자들이 완전한 승리를 거두기는 쉽지 않았을 것이다. 이 경우, 아마 사용자들은 각자가 올바르다고 믿는 체인을 따를 것이고, 이는 매우 큰 혼란을 초래 했을 것이다. 적어도 이로 인해 발생할 시장의 패닉과 지속적으로 발생하는 체인 분할로 인해 공격자들의 이익은 크게 감소했을 것이다. 이렇게 끊임없이 지속되는 갈등을 해결해야 할 것이라는 생각 자체가 공격에 대한 유인을 크게 떨어뜨릴 것이다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/598/0*7DZZ_B1J-QVLhd2R"><figcaption><em>이에 대한 Hasu의 의견을 들어보자.</em></figcaption></figure><p>만약 커뮤니티에 노드 운영자는 단 37명이고, 서명과 블록 헤더만 수동적으로 검증하는 사람들이 80000명이라면, 공격자가 승리할 것이다. 반대로 모든 사용자들이 노드를 운영한다면, 공격자는 패배할 것이다. 이러한 조직화된 공격에 대해 <a href="https://vitalik.ca/general/2020/08/17/philosophy.html">집단면역</a>을 갖추기 위한 구체적인 임계값이 정확히 무엇인지는 알 수 없지만, 단 한가지 사실은 분명하다. 노드는 많을수록 좋고, 적을수록 나쁘며, 최소한 수십 또는 수백 개 이상의 노드는 반드시 필요하다는 것이다.</p>\n<h3><strong>풀 노드 요구사양의 한계는 어디까지 인가?</strong></h3>\n<p>노드를 운영할 수 있는 사용자 수를 최대화하기 위해 일반 소비자용 하드웨어를 기준으로 논의해보자. 아마존 등을 통해 쉽게 구할 수 있는 블록체인에 특화된 하드웨어는 처리 능력을 다소 증가시킬 수 있겠지만, 실질적으로 블록체인의 확장성을 높이는데는 큰 도움이 되지 않는다.</p>\n<p>풀 노드가 수 많은 트랜잭션을 처리하기 위해 필요한 세가지 핵심 제약 사항은 다음과 같다.</p>\n<ul>\n<li>\n<strong>컴퓨팅 파워(computing power)</strong>: 노드를 실행하기 위해 필요한 안정적인 CPU 요구 사용률은 어느정도인가?</li>\n<li>\n<strong>대역폭(bandwidth)</strong>: 현재 인터넷 연결 환경의 현실을 고려할 때, 블록은 얼마나 많은 바이트를 포함할 수 있는가?</li>\n<li>\n<strong>저장용량(storage)</strong>: 사용자에게 디스크에 몇 기가바이트까지 저장하도록 요구할 수 있는가? 또한, 저장된 데이터를 얼마나 빨리 읽을 수 있어야 하는가? (즉, HDD로도 충분한가? 아니면 SSD가 필요한가?)</li>\n</ul>\n<p>“단순한” 기법을 통해 블록체인의 확장성을 높이려는 많은 잘못된 접근들은 주로 각 요소의 수치에 대해 지나치게 낙관적으로 추정하는 것에서 비롯된다. 위 세가지 요소를 각각 자세히 살펴보도록 하자.</p>\n<h4>컴퓨팅 파워(Computing Power)</h4>\n<ul>\n<li>\n<strong>오답</strong>: 블록 검증에 CPU의 100%를 사용할 수 있다.</li>\n<li>\n<strong>정답</strong>: CPU의 약 5~10%만 블록 검증에 사용할 수 있다.</li>\n</ul>\n<p>CPU 사용률에 대한 제한이 이렇게 낮은 데에는 크게 4가지 이유가 있다.</p>\n<ul>\n<li>DoS 공격(코드의 취약점을 이용하여 일반적인 트랜잭션보다 처리 시간이 오래 걸리도록 공격자가 조작한 트랜잭션)을 방어할 수 있는 안전 마진이 필요하다.</li>\n<li>노드들은 오프라인 상태에서도 체인을 동기화 할 수 있어야한다. 만약 1분 동안 네트워크 연결이 끊기더라도, 수 초 내에 체인을 따라갈 수 있어야 한다.</li>\n<li>노드를 운영하는 것이 배터리를 빠르게 소모시키거나, 다른 앱들을 지나치게 느리게 만들어서는 안된다.</li>\n<li>블록 생성 외에도 노드가 수행해야 하는 다른 작업도 있다. 주로 p2p 네트워크에서 들어오는 트랜잭션 및 요청을 검증하고 응답하는 것이다.</li>\n</ul>\n<p>최근까지 “왜 5–10% 밖에 사용할 수 없는지”에 대한 대부분의 설명은 다른 문제에 초점을 맞춰 왔었다. PoW에서는 블록이 랜덤하게 생성되기 때문에, 블록을 검증하는데 오랜 시간이 걸릴 경우 이는 동시에 많은 블록이 생성될 위험으로 이어질 수 있기 때문이다. 이 문제에 대해서는 많은 해결책(예: <a href="https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-eyal.pdf">Bitcoin NG</a>, PoS 등)이 존재한다. 그러나 이러한 해결책들은 <strong>위의 4가지 문제를 해결하지는 않으므로</strong>, 따라서 많은 이들이 예상했던 것과 달리 확장성을 크게 증가시키지 않는다.</p>\n<p>병렬처리는 결코 마법의 해결책이 아니다. 싱글 스레드(single-thread) 블록체인처럼 보이는 클라이언트 또한 이미 병렬화되어있다. 하나의 스레드는 서명을 검증하고, 다른 하나는 트랜잭션을 실행하고, 또 다른 별도의 스레드는 백그라운드에서 트랜잭션 풀을 처리한다. 그리고 스레드 사용률이 100%에 가까워질수록 노드를 운영하는데 필요한 에너지 소모량은 증가하고, DoS 공격에 대해 더 취약해질 것이다.</p>\n<h4>대역폭(Bandwidth)</h4>\n<ul>\n<li>\n<strong>오답</strong>: 2–3초마다 10MB의 블록을 생성한다면, 대부분의 사용자는 10MB/sec 이상의 네트워크를 사용하므로 이를 당연히 처리할 수 있다.</li>\n<li>\n<strong>정답</strong>: 1–5MB의 블록을 12초마다 생성할 ‘수’도 있다. 그러나 이 또한 쉽지 않다.</li>\n</ul>\n<p>오늘날 우리는 인터넷 서비스 업체들이 제공하는 매우 높은 대역폭에 대한 광고를 자주 마주치게 된다. 100 Mbps, 심지어 1 Gbps의 수치도 흔히 접할 수 있다. 하지만 광고에서 제시하는 대역폭과 실제 네트워크의 대역폭에는 큰 차이가 있는데, 이는 다음과 같은 여러 이유들 때문이다.</p>\n<ol>\n<li>“Mbps”는 “1초당 몇백만 비트인지”에 대한 단위이며, 비트는 바이트의 1/8이다. 따라서 광고에서 제시된 수치를 8로 나눠야지 바이트 기준의 Mbps 수치가 된다.</li>\n<li>모든 기업과 마찬가지로 인터넷 서비스 업체들도 종종 거짓말을 한다.</li>\n<li>동일한 인터넷 연결을 사용하는 다수의 애플리케이션이 있으므로 노드가 모든 대역폭을 사용할 수 없다.</li>\n<li>p2p 네트워크는 필연적으로 자체 오버헤드를 발생시킨다. 노드는 동일한 블록을 여러번 다운로드하거나 재업로드한다.(블록에 포함되기 <strong>전에</strong> 트랜잭션이 멤풀(mempool)을 통해 여러 곳으로 전송되는 것은 물론이다)</li>\n</ol>\n<p><a href="https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-eyal.pdf">트랜잭션 데이터 가스 비용이 감소</a>되자 2019년 Starkware 팀은 500kB 크기의 블록들을 퍼블리싱하는 실험을 진행할 수 있었는데, 실제로 이 실험에서 소수의 노드들은 해당 크기의 블록을 처리할 수 없었다. 물론 그 이후 큰 사이즈의 블록을 처리하기 위해 많은 개선이 이루어졌으며, 이는 앞으로도 계속해서 개선될 예정이다. 하지만 현재로서는 MB/sec 단위의 평균 대역폭이나 1초 수준의 레이턴시(latency)를 가정하거나, 이처럼 큰 사이즈의 블록을 생성하는 것들은 여전히 요원한 상황이다.</p>\n<p><strong>저장용량(Storage)</strong></p>\n<ul>\n<li>\n<strong>오답</strong>: 10 테라바이트</li>\n<li>\n<strong>정답</strong>: 512 기가바이트</li>\n</ul>\n<p>저장용량에 대한 주요 논점은 다른 모든것들이 그런것처럼 이론과 현실의 차이에 있다. <strong>이론상으로는</strong><em> </em>아마존에서 <a href="https://www.amazon.com/SAMSUNG-870-QVO-SATA-MZ-77Q8T0B/dp/B089C3TZL9/ref=sr_1_3?dchild=1&amp;keywords=8tb&amp;qid=1621637865&amp;s=pc&amp;sr=1-3">8TB SSD</a>(반드시 SSD나 NVME가 필요하다. HDD는 블록체인 상태를 저장하기에는 너무 느리기 때문이다)를 구매할 수 있다. <strong>실제로는</strong> 이 글을 작성하는 데 사용된 노트북은 512GB이고, 사람들에게 블록체인에 사용할 하드웨어를 직접 구매하라고 하면, 대부분은 매우 귀찮아서(혹은 800 달러나 하는 8 TB SSD를 구매할 여유가 없을 수도 있다.) 중앙화된 서비스를 이용할 것이다. 또한 블록체인에 적합한 일부 저장장치가 있다고 하더라도, 매우 활발하게 생성되는 블록체인의 데이터를 저장하다보면 디스크는 금방 꽉 차게 될 것이고, 여러분은 계속해서 새로운 저장장치를 구매할 수 밖에 없게 될 것이다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/420/0*m6E9ffYbXYY3w9tD"><figcaption><em>블록체인 프로토콜 연구자들을 대상으로 한 현재 보유중인 디스크 저장용량에 대한 설문조사. 표본이 작긴 하지만, 여전히 (의미는 있다)…</em></figcaption></figure><p>또한 저장공간의 크기는 새로운 노드가 네트워크에 참여하기 위해 필요한 시간을 결정한다. 기존 노드가 저장해야 하는 모든 데이터는 곧 새로운 노드가 다운로드해야 하는 데이터이다. 이 초기 동기화 시간(및 대역폭)은 사용자들이 노드를 운영하는데 주요 장애물로 작용한다. 이 글을 작성하는 동안 새로운 geth 노드를 동기화하는데 약 15시간이 소요됐다. 이더리움의 사용량이 10배가 되었다면 새로운 geth 노드를 동기화하는 것은 최소 일주일 이상이 걸릴 것이고, 이로 인해 인터넷 연결에 스로틀링(Throttling)이 발생할 가능성이 매우 높다. 이러한 요소는 공격 상황에서 더 중요해지는데, 공격을 성공적으로 방어하기 위해서는 이전에 노드를 운영하지 않았던 많은 사용자들이 새로운 노드를 실행하는것이 필요하기 때문이다.</p>\n<h3>상호작용 효과(Interaction effects)</h3>\n<p>이 세가지 비용들의 상호작용에 대한 효과도 존재한다. 데이터베이스는 내부적으로 데이터를 저장하고 읽어오기 위해 트리 구조를 사용하기 때문에, 데이터를 가져오는데 소요되는 비용은 데이터베이스 크기에 비례해 로그적으로 증가한다. 사실, 트리의 상위 레벨들은 RAM에 캐싱할 수 있으므로, 디스크 액세스 비용은 RAM에 캐싱된 데이터 크기의 배수로 데이터베이스의 크기에 비례하게 된다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/582/0*CW324HxNdDfglsrM"><figcaption><em>이 다이어그램은 설명의 편의를 위해 매우 단순하게 표현되었다. 각각의 데이터베이스는 서로 다른 방식으로 작동하며 많은 경우 메모리 부분은 (크지만) 단일 레이어이다(leveldb에서 사용되는 </em><a href="http://paperhub.s3.amazonaws.com/18e91eb4db2114a06ea614f0384f2784.pdf"><em>LSM trees</em></a><em>를 참고하라). 그러나 기본적인 원리는 같다.</em></figcaption></figure><p>예를 들어, 캐시가 4GB이고 데이터베이스의 각 레이어가 그 이전보다 4배 더 크다고 가정한다면, 약 64GB의 이더리움의 현재 상태 데이터는 상태는 약 2번의 액세스를 필요로 할것이다. 만약 이 상태 크기가 4배 더 증가하여 약 256GB가 된다면, 3번의 액세스를 필요로 할 것이다. 즉, 가스 리밋(gas limit)이 4배 증가하면 실질적으로 블록 검증 시간은 약 6배 증가할 수 있다. 이러한 효과는 더욱 강력해질수도 있는데, 하드디스크는 비어있을 때보다는 가득 찼을 때 읽고 쓰는 시간이 더 증가하기 때문이다.</p>\n<h3>이것이 이더리움에게 의미하는 바는 무엇인가?</h3>\n<p>오늘날 이더리움 블록체인 노드를 일반적인 하드웨어에서 운영하는 것이 가능은 하지만(이 글을 쓰는 동안에 나 또한 노트북으로 노드를 동기화했다!), 여전히 많은 사용자들에게는 어려운 일이다. 현재 우리는 병목 구간에 거의 근접해 있는데, <strong>코어 개발자들이 가장 우려하고 있는 것은 저장공간의 크기와 관련된 문제이다.</strong> 따라서 현재로써는, 연산과 데이터의 병목을 해결하기 위해 많은 노력을 기울이거나, 심지어 합의 알고리즘을 변경하더라도 가스 리밋을 대폭 증가시키는 것은 매우 어려울 것이다. <a href="https://blog.ethereum.org/2021/05/18/eth_state_problems/">이더리움의 최대 DoS 취약점을 해결하는 방법</a>도 가스 리밋을 단지 20% 증가시켰을 뿐이다.</p>\n<p>저장공간 크기에 대한 문제를 해결할 수 있는 유일한 방법은 <a href="https://hackmd.io/@vbuterin/state_expiry_paths">무상태성(statelessness)과 상태 만료(state expiry)</a>를 이용하는 것이다. <strong>무상태성</strong>은 영구적인 저장공간을 사용하지 않고도 체인을 검증할 수 있는 노드 클래스를 이용할 수 있게 해준다. <strong>상태 만료</strong>는 최근에 액세스되지 않은 상태들을 일시적으로 제거한 뒤, 이를 갱신하기 위해서는 사용자들이 직접 이에 대한 증명을 제출하도록 한다. 이러한 두가지 방법에 대한 작업은 이미 오래 전부터 계속해서 진행되고 있으며, 무상태성에 대한 개념 증명(proof-of-concept) 구현은 이미 착수 되었다. 이 두 가지 개선 사항을 결합하면 저장공간에 대한 문제를 완화하고 가스 리밋을 증가시킬 수 있는 여지를 만들어 낼 수 있다. <strong>하지만 무상태성과 상태 만료가 모두 성공적으로 도입되더라도, 다른 문제들이 완전히 해결되기 전에는 가스 리밋을 약 3배 수준까지 증가시키는 것이 최선일 것이다.</strong></p>\n<p>또 다른 중기적 솔루션은 ZK-SNARKs를 이용하여 트랜잭션을 검증하는 것이다. ZK-SNARKs를 이용하면 일반 사용자가 직접 스테이트를 저장하거나 블록을 검증할 필요가 없어질 수 있다. 물론 여전히 데이터 비가용성 공격으로부터 방어하기 위해 사용자들은 블록의 모든 데이터를 다운로드 해야 한다. 더불어 공격자가 유효하지 않은 블록을 강제로 포함시킬 수 없더라도, 만약 컨센서스 노드 운영에 어려움을 겪을 정도로 처리 용량이 지나치게 증가한다면 여전히 조직적인 검열 공격(censorship attack)이 발생할 위험이 있다. 따라서 ZK-SNARKs은 처리 용량을 무한히 늘릴 수는 없지만 상당히 큰 규모로(약 1~2배) 처리 용량을 늘릴 수 있다. 일부 체인은 레이어 1에서 이러한 방식을 도입하려고 하고 있지만, 이더리움은 이를 <a href="https://zksync.io/">zksync</a>, <a href="https://loopring.org/">Loopring</a>, <a href="https://medium.com/starkware/on-the-road-to-starknet-a-permissionless-stark-powered-l2-zk-rollup-83be53640880">Starknet</a> 과 같은 레이어 2 프로토콜(<a href="https://vitalik.ca/general/2021/01/05/rollup.html">ZK rollups</a>)을 통해 활용하고 있다.</p>\n<h3><strong>샤딩을 도입한다면?</strong></h3>\n<p><strong>샤딩은 앞에서 논의한 여러 한계점들을 근본적으로 해결할 수 있는데, 이는 블록체인에 포함되는 데이터와 단일 노드가 처리하고 저장해야 하는 데이터를 분리하기 때문이다.</strong> 각 노드들은 모든 블록을 직접 다운로드하고 실행하는 대신에, <a href="https://vitalik.ca/general/2021/04/07/sharding.html">진보된 암호수학적 기술</a>을 통해 블록들을 간접적으로 검증하게 된다.</p>\n<p>이로 인해 샤딩 체인은 비-샤딩 블록체인이 달성할 수 없는 매우 높은 수준의 트랜잭션 처리량을 안전하게 달성할 수 있다. 물론 이는 유효하지 않은 블록을 성공적으로 검증하는 완전 검증(full validation)방식을 효율적으로 대체할 수 있는 많은 정교한 암호학적 기술을 필요로하지만, 이는 어쨌든 가능한 상황이다. 이에 관한 <a href="https://hackmd.io/@vbuterin/das">이론</a>도 <a href="https://vitalik.ca/general/2021/01/26/snarks.html">잘 정립되어</a> 있으며, <a href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/sharding/beacon-chain.md">설계 초안</a>에 기반한 개념 증명에 대한 <a href="https://github.com/protolambda/eth2-das">작업도 이미 활발하게 진행</a>되고 있다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ru67pfWmPlvHkuIM"></figure><p>이더리움은 <strong>쿼드라틱(quadratic) 샤딩</strong>을 사용할 계획이며, 따라서 전체 확장성은 한 노드가 각 샤드에 대한 필수 관리 작업을 수행하는 비콘 체인과 단일 샤드를 모두 처리할 수 있는 수준으로 제한된다. 만약 샤드가 너무 크다면, 노드들은 개별 샤드를 더 이상 제대로 처리하지 못할것이며, 반대로 너무 많은 샤드가 있다면 노드들은 비콘 체인을 처리할 수 없게 될 것이다. 이 두가지 제약 조건의 곱이 전체 확장성의 상한선을 결정하게 되는 것이다.</p>\n<p>누군가는 여기서 더 나아가 큐빅(cubic) 샤딩 또는 심지어 기하급수적(exponential) 샤딩까지 도입하려 할 수 있다. 이러한 모델에서는 데이터 가용성 샘플링이 더욱 더 복잡해 질 것이지만, 어쨌든 가능은 할 것이다. 하지만 이더리움은 쿼드라틱 이상으로 더 나아가지 않을 것이다. 그 이유는 트랜잭션들의 샤드(shards-of-transactions)에서 트랜잭션들의 샤드의 샤드(shards-of-shards-of-transactions)로 변경하여 확보할 수 있는 추가적인 확장성이 매우 높은 위험을 수반할 수 밖에 없기 때문이다.</p>\n<p>그렇다면 구체적으로 어떠한 위험들이 있는가?</p>\n<h3><strong>최소 사용자 수</strong></h3>\n<p>비-샤딩 블록체인은 단 한명의 사용자만 네트워크에 참여하고 있는한 계속해서 운영될 수 있다. 하지만 샤딩 블록체인은 이와 다르게, 단일 노드가 모든 체인을 처리할 수 없다. 따라서 해당 체인을 최소한으로 함께 처리할 수 있는 충분한 수의 노드를 확보해야만 한다. 각 노드가 50 TPS를 처리할 수 있고, 체인은 10000 TPS를 처리할 수 있다면, 해당 체인에는 최소한 200개의 노드가 필요하다. 만약 노드의 수가 200개보다 낮아진다면, 노드들이 체인을 따라잡을 수 없거나 유효하지 않은 블록을 검증할 수 없게 될 것이고, 또는 구체적인 노드 소프트웨어의 설정값에 따라 수 많은 다른 오류가 발생할 수도 있다.</p>\n<p>현실적으로 안전한 수준의 최소 노드 수는 단순히 “체인 TPS를 노드 TPS로 나눈 것” 보다는 수 배 이상 더 높은데, 이는 <a href="https://hackmd.io/@vbuterin/das">데이터 가용성 샘플링(data availability sampling)</a>을 포함한 중복(redundancy) 작업을 필요로 하기 때문이다. 위의 예시에서, 이러한 안전한 최소 노드 수가 1000개라고 하자.</p>\n<p>샤딩 블록체인의 처리 용량이 10배 증가할 경우, 필요한 최소 노드 수 또한 10배 증가할 것이다. 이 때, 이런 질문을 할 수도 있다. “처음에는 낮은 수준의 처리 용량으로 시작하고, 실제로 필요한 수만큼의 사용자들이 확보가 되었을 때 이를 증가시키고, 사용자의 수가 줄어들 때는 감소시키면 되지 않을까?”</p>\n<p>이러한 방식에는 다음과 같은 몇가지 문제가 있다.</p>\n<ol>\n<li>블록체인 자체는 해당 체인에 실제로 고유한 사용자들이 몇명이나 있는지 정확히 파악할 수 없다. 따라서 적절한 샤드의 수를 파악하고 결정하는기 위해서는 일종의 거버넌스가 필요할 것이다. 이러한 처리 용량 제한에 대한 거버넌스는 <a href="https://en.bitcoin.it/wiki/Block_size_limit_controversy">분열과 갈등의 중심이 될 가능성이 높다.</a>\n</li>\n<li>만약 갑자기 많은 사용자들이 동시에 네트워크에서 빠져나간다면 어떻게 되는가?</li>\n<li>포크에 필요한 최소 사용자의 수를 높이는 것은 적대적 네트워크 점유 공격에 대응하기 어렵게 만든다.</li>\n</ol>\n<p>최소 사용자의 수가 1000 이하라면 거의 확실하게 문제가 없을 것이다. 반대로, 이 수가 1백만이라면 확실하게 문제가 발생할 것이다. 심지어 1만이라는 최소 사용자 수도 꽤 위험해지기 시작하는 수치이다. <strong>따라서, 샤드의 수를 수백개 이상으로 늘린 샤딩 블록체인이 타당하다고 보기는 매우 쉽지 않을 것이다.</strong></p>\n<h3><strong>기록 복구 가능성(History retrievability)</strong></h3>\n<p>사용자들이 가장 가치있게 여기는 블록체인의 중요한 속성은 바로 영구성(permanence)이다. 한 서버에 저장된 디지털 자산은 해당 기업이 그 생태계를 유지할 유인을 잃거나 또는 파산한다면 10년 내에 사라지게 될 것이다. 반대로, 이더리움의 NFT는 영원히 존재한다.</p>\n<blockquote>역주: 싸이월드에서 서비스 재개 가능성을 타진 하면서 <a href="https://www.chosun.com/economy/tech_it/2021/05/25/HJVV7TP5VJFLJNWBKDRICH5CSA/">약 38억원 어치의 도토리를 환불</a>할 것임을 밝혔다. 만약 싸이월드가 그대로 역사의 뒤안길로 사라졌다면, 이 도토리들은 어떻게 되었을까?</blockquote>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/800/0*_4fE7tyTRyPvxR4G"><figcaption><em>그렇다. 사람들은 당신의 크립토 키티를 2371년에도 찾아보고 다운로드 할 수 있을 것이다. 이는 분명한 사실이다.</em></figcaption></figure><p>하지만 블록체인의 용량이 지나치게 높아진다면, 이러한 모든 데이터를 저장하는 것에 어려움이 생길 수 있다. 어느 시점까지 히스토리 데이터의 일부를 어떤 노드도 저장하지 않을 위험이 커질 수 있다.</p>\n<p>이러한 위험을 측정하는 것은 비교적 쉽다. 블록체인 데이터 처리 용량을 MB/sec 단위로 측정하고, 이에 약 30을 곱해주면 매년 저장될 데이터의 테라바이트 단위 용량을 구할 수 있다. 현재 샤딩은 약 1.3MB/sec 의 처리 용량을 가정하고 있으므로, 대략 40 TB/year 만큼 데이터가 저장될 것이다. 만약 이를 10배 높인다면, 400 TB/year 가 될 것이다. 이러한 데이터에 대한 접근성을 더욱 높이기 위해서는 메타데이터(예: 롤업 트랜잭션 압축 해제)와 같은 것들이 필요할 수 있고, 이를 통해 연간 4 페타바이트 심지어 약 10년 후에는 연간 40페타바이트까지 확장할 수 있을 것이다. 인터넷 아카이브(Internet Archive)가 현재 <a href="https://archive.org/web/petabox.php">50 페타바이트</a> 정도를 사용하고 있는데, 이러한 수치는 샤딩 블록체인이 안전하게 확보할 수 있는 합리적인 상한선이라고 할 수 있다.</p>\n<p>따라서, 이러한 두가지 차원에서, <strong>이더리움 샤딩 설계는 사실 이미 의미있는 수준의 안전한 최댓값에 상당히 근접한 수치를 목표를 하고 있다.</strong> 구체적인 값들은 소폭 증가할 수 있겠지만, 여기에서 더 크게 증가하지는 않을 것이다.</p>\n<h3><strong>정리</strong></h3>\n<p>블록체인의 확장성을 높이는 방법에는 크게 두가지가 있다. 하나는 <strong>기술을 근본적으로 개선하는 것</strong>이고, 다른 하나는 단순히 <strong>파라미터 값을 늘리는 것</strong>이다. 언뜻 보기에 파라미터 값을 늘리는것은 매우 매력적으로 보인다. 단순하게 계산을 해보면 일반적인 노트북으로 ZK-SNARKs, 롤업, 샤딩과 같은 기술 없이 초당 수천건의 트랜잭션을 처리하는것에는 크게 문제가 없을 것처럼 보인다. 안타깝지만, 이러한 접근 방식에는 근본적으로 결함이 있을 수 밖에 없는 여러가지 미묘한 이유가 있다.</p>\n<p>블록체인 노드를 운영하는 컴퓨터는 체인을 검증하는데 100%의 CPU 파워를 할당할 수 없다. 예를 들어, 예상치 못한 DoS 공격에 대비하기 위해 높은 수준의 안전마진이 필요하고, 멤풀에 있는 트랜잭션들을 처리하는 작업등을 위해 여유 CPU 용량이 필요하다. 무엇보다 여러분은 해당 컴퓨터에서 오로지 노드만 운영할 수 있고, 다른 어떤 애플리케이션도 동시에 사용할 수 없는 상황을 바라지는 않을 것이다. 비슷한 이유로 대역폭에도 오버헤드가 발생하게 된다. 10MB/s 라는 수치는 초당 10MB의 블록을 받을 수 있다는 것을 의미하는게 아니다! 아마도 12초당 1~5MB 정도의 블록을 받을 수 있을 것이다. 저장 용량도 마찬가지다. 요컨대, 노드를 운영하는데 필요한 하드웨어 요구사항을 높여 노드 운영을 특수한 참여자에게만 제한하는것은 올바른 해결책이 아니다. <strong>블록체인이 탈중앙화되기 위해서 가장 중요한 것은 일반적인 사용자들이 직접 노드를 운영할 수 있도록 하고, 노드를 직접 운영하는 것이 지극히 일상적인 행위가 되는 문화를 만드는 것이다.</strong></p>\n<p>반대로, 기술을 근본적으로 개선하는 것은 해결책이 될 수 있다. <strong>현재 이더리움의 가장 큰 병목은 저장 용량에 있는데, 이는 무상태성(statelessness)과 상태 만료(state expiry)와 같은 방법들을 통해 이를 해결할 수 있으며</strong>, 노드 운영의 효율성을 현재 방식에 비해 최대 약 3배까지 끌어올릴 수 있다. <strong>샤딩을 도입하다면 이는 더 크게 증가할 수 있다.</strong> 샤딩 체인에서는 단일 노드가 모든 트랜잭션을 처리할 필요가 없어지기 때문이다.</p>\n<p>하지만 심지어 이러한 방식에도 한계가 존재한다. 처리 용량이 증가할수록 최소한으로 필요한 사용자의 수가 증가하게 되고, 체인을 아카이빙(archiving)하는 비용도 증가하며, 더불어 어느 누구도 체인 데이터를 아카이빙하지 않을 경우 데이터를 모두 잃어버릴 위험 또한 증가하게 된다. 물론, 이에 대해 크게 걱정할 필요는 없다. 이러한 한계에 대한 기준 자체가 충분히 높기 때문에, 블록체인의 안전성을 완전히 보장한 상태에서 초당 약 수백만건의 트랜잭션을 처리할 수 있을 것이다. 그러나 블록체인의 핵심 가치인 탈중앙성을 희생하지 않고 이러한 것들을 달성하기 위해서는 앞으로도 많은 노력이 필요할 것이다.</p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=802b3e036384" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%99%95%EC%9E%A5%EC%84%B1%EC%9D%98-%ED%95%9C%EA%B3%84-the-limits-to-blockchain-scalability-802b3e036384">블록체인 확장성의 한계(The Limits to Blockchain Scalability)</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                content:
                  '\n<blockquote>이 글은 비탈릭 부테린(Vitalik Buterin)의 글 <a href="https://vitalik.ca/general/2021/05/23/scaling.html">The Limits to Blockchain Scalability</a>을 Aiden, Gwen이 우리말로 옮겨 쓴 글이다.</blockquote>\n<blockquote>최근 ‘도지파더(Dogefather)\' 일론 머스크가 도지코인의 우월한 확장성에 대해 주장한 트윗이 화제가 되면서 블록체인 확장성에 대한 논의가 활발하게 이뤄졌다. 비탈릭 부테린은 이 글을 통해 일론 머스크의 주장에 대해 직간접적으로 답변하여 또 다른 많은 화제를 낳았다.</blockquote>\n<blockquote>그 동안 블록체인 확장성을 다룬 수 많은 글들이 있었지만, 왜 확장성을 쉽게 높이는 것이 어려운지에 대해 구체적으로 다룬 글은 흔치 않았다. 이 글은 이러한 내용에 대해 매우 자세하고 쉽게(?) 다루고 있으므로, 블록체인 확장성에 관심이 있는 분들에게 이 글이 큰 도움이 될 것이라 생각한다.</blockquote>\n<p><em>Special thanks to Felix Lange, Martin Swende, Marius van der Wijden and Mark Tyneway for feedback and review.</em></p>\n<p>블록체인의 확장성을 얼마나 높일 수 있을까? 정말 <a href="https://twitter.com/elonmusk/status/1393738154889338884">일론 머스크가 바라는 대로</a>, “블록 타임을 10배 빠르게 만들고, 블록 크기를 10배로 늘리고, 수수료는 100배 줄이는” 것이 극단적인 중앙화와 블록체인의 핵심 가치에 대한 훼손 없이 가능할까? 만약 그럴 수 없다면, 확장성을 어디까지 높일 수 있을까? 컨센서스 알고리즘을 바꾼다면 어떻게 될까? 더 나아가, ZK-SNARKs 또는 샤딩(sharding)과 같은 새로운 기능을 도입하여 기술을 개선하면 어떻게 될까? 이론적으로 샤딩 체인은 더 많은 샤드(shard)를 계속해서 추가할 수 있는데, 이러한 것이 정말 가능한걸까?</p>\n<p>나중에 알려진 사실이지만, 샤딩이 적용된 체인이나 적용되지 않은 체인 두가지 모든 경우에 대해 블록체인의 확장을 제한하는 여러가지 중요하고 미묘한 기술적 요인들이 있다. 대부분의 경우 이에 대한 해결책이 존재하지만, 이러한 해결책에도 한계는 분명히 존재한다. 이 글은 이러한 이슈들에 대해 다루고자 한다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/598/0*svNLkj58FEGvhF-c"><figcaption><em>단순히 파라미터 값을 늘리면 모든 문제가 해결된다. 하지만 여기서 우리가 잃는 것은 무엇인가?</em></figcaption></figure><h3><strong>블록체인 탈중앙화의 핵심은 일반 사용자들이 노드를 운영할 수 있도록 하는 것이다</strong></h3>\n<p>새벽 2시 35분, 당신은 지구 반대편에 위치한 마이닝 풀(또는 스테이킹 풀)의 운영을 돕고 있는 파트너로부터 긴급한 전화를 받는다. 파트너가 말하길, 약 14분 전부터 당신의 풀을 포함한 다른 몇개의 풀들이 전체 네트워크의 79%를 이끌고 있는 체인으로부터 분리되었다고 한다. 하지만 당신의 노드에 따르면, 다수가 동의한 해당 체인의 블록들은 유효하지 않은 것으로 확인된다. 해당 체인은 잔액 기록에 대한 오류가 발생했으며, 구체적으로 특정 키 블록(key block)에서 알 수 없는 주소에 450만개의 코인을 추가로 잘못 할당한 것으로 보인다.</p>\n<p>한 시간 후, 당신과 똑같이 매우 혼란스러워 하고 있는 다른 두개의 소규모 풀 업체와 소수의 블록 익스플로러 및 거래소 업체가 함께 속해 있는 텔레그램 채팅방에서 누군가 어떤 트윗에 대한 링크 하나를 올린다. 그 트윗은 다음과 같이 시작 한다.</p>\n<p><em>“지속가능한 새로운 온체인 프로토콜 개발 펀드를 발표합니다.”</em></p>\n<p>날이 밝자, 트위터와 검열이 없는 커뮤니티 포럼에서 모든 사람들이 이에 대해 활발하게 논쟁하고 있다. 하지만 그 동안 이미 450만개의 코인 중 상당 부분은 온체인에서 다른 자산으로 변환 되었고, 수십억 달러 규모의 디파이(defi) 트랜잭션들이 발생한 상황이다. 컨센서스 노드의 79%와 모든 주요 블록 익스플로러 및 라이트 월렛(light wallet)의 엔드포인트 또한 계속해서 이 새로운 체인을 따르고 있다. 이렇게 조성된 새로운 개발 펀드는 실제로 개발을 위한 자금을 조달하는데 사용될수도 있겠지만, 반대로 이를 주도한 여러 주요 풀과 거래소 및 이들의 지지자들이 이 자금을 모두 횡령할 수도 있을 것이다. 하지만 그 결과가 어떻게 되든, 이러한 펀드가 조성 되었다는 것은 이미 일어난 사실이며, 평범한 사용자들은 이에 대항할 방법이 없는 것이 현실이다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/511/0*7k2CX9ONLMK4Olq-"><figcaption><em>개봉 예정작. MolochDAO 같은 곳에서 펀딩을 받을 수 있을 지도 모르겠다.</em></figcaption></figure><p>이런 일이 당신이 사용하는 블록체인에서도 발생할 수도 있을까? 당신이 속한 블록체인 커뮤니티의 핵심 구성원들, 즉 주요 마이닝(스테이킹) 풀, 블록 익스플로러 및 호스트 노드들은 서로 매우 긴밀하게 협력하고 있을 가능성이 높다. 아마 이들은 모두 동일한 텔레그램 채널과 위챗 그룹에 속해 있을 것이다. 만약 이들이 정말로 본인들의 이익을 위해 프로토콜 규칙을 갑자기 변경하고 싶다면, 충분히 그렇게 할 수도 있을 것이다. 이더리움 블록체인은 10시간 만에 <a href="https://blog.ethereum.org/2016/11/25/security-alert-11242016-consensus-bug-geth-v1-4-19-v1-5-2/">컨센서스 오류</a>를 완전히 해결할 수 있었다. 하지만 당신이 사용하는 블록체인의 클라이언트 구현체가 단 하나이고, 클라이언트 코드 변경을 위해 수십개의 노드에만 이를 배포하는 것으로 충분하다면 이러한 공격은 훨씬 수월할 것이다. 이런 방식의 조직화된 사회적 공격을 효과적으로 방지할 수 있는 유일한 방법은 실질적으로 탈중앙화된 구성원, 즉 <strong>사용자</strong>들을 통한 수동적 방어(passive defense) 시스템을 구축하는 것이다.</p>\n<p>만약 사용자들이 체인을 검증하는 노드를 운영(직접 검증하거나 또는 <a href="https://vitalik.ca/general/2021/04/07/sharding.html#improving-sharding-with-better-security-models">개선된 기술을 통해 간접적으로 검증하든</a>)한다고 가정 해보자. 프로토콜 규칙을 위반한 블록을 심지어 90%이상의 마이너나 스테이커들이 지지하더라도 사용자들의 노드가 이 블록들을 자동적으로 거부한다면 이 이야기는 어떻게 전개될까? <strong>모든</strong> 사용자가 검증 노드를 운영했다면 이러한 공격은 빠르게 실패했을 것이다. 몇몇 마이닝 풀과 거래소가 포크해서 나갈수도 있지만, 이는 매우 어리석은 행동처럼 비춰질 것이다. 심지어 모든 사용자가 아니라 일부 사용자만이라도 검증 노드를 운영했다면, 공격자들이 완전한 승리를 거두기는 쉽지 않았을 것이다. 이 경우, 아마 사용자들은 각자가 올바르다고 믿는 체인을 따를 것이고, 이는 매우 큰 혼란을 초래 했을 것이다. 적어도 이로 인해 발생할 시장의 패닉과 지속적으로 발생하는 체인 분할로 인해 공격자들의 이익은 크게 감소했을 것이다. 이렇게 끊임없이 지속되는 갈등을 해결해야 할 것이라는 생각 자체가 공격에 대한 유인을 크게 떨어뜨릴 것이다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/598/0*7DZZ_B1J-QVLhd2R"><figcaption><em>이에 대한 Hasu의 의견을 들어보자.</em></figcaption></figure><p>만약 커뮤니티에 노드 운영자는 단 37명이고, 서명과 블록 헤더만 수동적으로 검증하는 사람들이 80000명이라면, 공격자가 승리할 것이다. 반대로 모든 사용자들이 노드를 운영한다면, 공격자는 패배할 것이다. 이러한 조직화된 공격에 대해 <a href="https://vitalik.ca/general/2020/08/17/philosophy.html">집단면역</a>을 갖추기 위한 구체적인 임계값이 정확히 무엇인지는 알 수 없지만, 단 한가지 사실은 분명하다. 노드는 많을수록 좋고, 적을수록 나쁘며, 최소한 수십 또는 수백 개 이상의 노드는 반드시 필요하다는 것이다.</p>\n<h3><strong>풀 노드 요구사양의 한계는 어디까지 인가?</strong></h3>\n<p>노드를 운영할 수 있는 사용자 수를 최대화하기 위해 일반 소비자용 하드웨어를 기준으로 논의해보자. 아마존 등을 통해 쉽게 구할 수 있는 블록체인에 특화된 하드웨어는 처리 능력을 다소 증가시킬 수 있겠지만, 실질적으로 블록체인의 확장성을 높이는데는 큰 도움이 되지 않는다.</p>\n<p>풀 노드가 수 많은 트랜잭션을 처리하기 위해 필요한 세가지 핵심 제약 사항은 다음과 같다.</p>\n<ul>\n<li>\n<strong>컴퓨팅 파워(computing power)</strong>: 노드를 실행하기 위해 필요한 안정적인 CPU 요구 사용률은 어느정도인가?</li>\n<li>\n<strong>대역폭(bandwidth)</strong>: 현재 인터넷 연결 환경의 현실을 고려할 때, 블록은 얼마나 많은 바이트를 포함할 수 있는가?</li>\n<li>\n<strong>저장용량(storage)</strong>: 사용자에게 디스크에 몇 기가바이트까지 저장하도록 요구할 수 있는가? 또한, 저장된 데이터를 얼마나 빨리 읽을 수 있어야 하는가? (즉, HDD로도 충분한가? 아니면 SSD가 필요한가?)</li>\n</ul>\n<p>“단순한” 기법을 통해 블록체인의 확장성을 높이려는 많은 잘못된 접근들은 주로 각 요소의 수치에 대해 지나치게 낙관적으로 추정하는 것에서 비롯된다. 위 세가지 요소를 각각 자세히 살펴보도록 하자.</p>\n<h4>컴퓨팅 파워(Computing Power)</h4>\n<ul>\n<li>\n<strong>오답</strong>: 블록 검증에 CPU의 100%를 사용할 수 있다.</li>\n<li>\n<strong>정답</strong>: CPU의 약 5~10%만 블록 검증에 사용할 수 있다.</li>\n</ul>\n<p>CPU 사용률에 대한 제한이 이렇게 낮은 데에는 크게 4가지 이유가 있다.</p>\n<ul>\n<li>DoS 공격(코드의 취약점을 이용하여 일반적인 트랜잭션보다 처리 시간이 오래 걸리도록 공격자가 조작한 트랜잭션)을 방어할 수 있는 안전 마진이 필요하다.</li>\n<li>노드들은 오프라인 상태에서도 체인을 동기화 할 수 있어야한다. 만약 1분 동안 네트워크 연결이 끊기더라도, 수 초 내에 체인을 따라갈 수 있어야 한다.</li>\n<li>노드를 운영하는 것이 배터리를 빠르게 소모시키거나, 다른 앱들을 지나치게 느리게 만들어서는 안된다.</li>\n<li>블록 생성 외에도 노드가 수행해야 하는 다른 작업도 있다. 주로 p2p 네트워크에서 들어오는 트랜잭션 및 요청을 검증하고 응답하는 것이다.</li>\n</ul>\n<p>최근까지 “왜 5–10% 밖에 사용할 수 없는지”에 대한 대부분의 설명은 다른 문제에 초점을 맞춰 왔었다. PoW에서는 블록이 랜덤하게 생성되기 때문에, 블록을 검증하는데 오랜 시간이 걸릴 경우 이는 동시에 많은 블록이 생성될 위험으로 이어질 수 있기 때문이다. 이 문제에 대해서는 많은 해결책(예: <a href="https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-eyal.pdf">Bitcoin NG</a>, PoS 등)이 존재한다. 그러나 이러한 해결책들은 <strong>위의 4가지 문제를 해결하지는 않으므로</strong>, 따라서 많은 이들이 예상했던 것과 달리 확장성을 크게 증가시키지 않는다.</p>\n<p>병렬처리는 결코 마법의 해결책이 아니다. 싱글 스레드(single-thread) 블록체인처럼 보이는 클라이언트 또한 이미 병렬화되어있다. 하나의 스레드는 서명을 검증하고, 다른 하나는 트랜잭션을 실행하고, 또 다른 별도의 스레드는 백그라운드에서 트랜잭션 풀을 처리한다. 그리고 스레드 사용률이 100%에 가까워질수록 노드를 운영하는데 필요한 에너지 소모량은 증가하고, DoS 공격에 대해 더 취약해질 것이다.</p>\n<h4>대역폭(Bandwidth)</h4>\n<ul>\n<li>\n<strong>오답</strong>: 2–3초마다 10MB의 블록을 생성한다면, 대부분의 사용자는 10MB/sec 이상의 네트워크를 사용하므로 이를 당연히 처리할 수 있다.</li>\n<li>\n<strong>정답</strong>: 1–5MB의 블록을 12초마다 생성할 ‘수’도 있다. 그러나 이 또한 쉽지 않다.</li>\n</ul>\n<p>오늘날 우리는 인터넷 서비스 업체들이 제공하는 매우 높은 대역폭에 대한 광고를 자주 마주치게 된다. 100 Mbps, 심지어 1 Gbps의 수치도 흔히 접할 수 있다. 하지만 광고에서 제시하는 대역폭과 실제 네트워크의 대역폭에는 큰 차이가 있는데, 이는 다음과 같은 여러 이유들 때문이다.</p>\n<ol>\n<li>“Mbps”는 “1초당 몇백만 비트인지”에 대한 단위이며, 비트는 바이트의 1/8이다. 따라서 광고에서 제시된 수치를 8로 나눠야지 바이트 기준의 Mbps 수치가 된다.</li>\n<li>모든 기업과 마찬가지로 인터넷 서비스 업체들도 종종 거짓말을 한다.</li>\n<li>동일한 인터넷 연결을 사용하는 다수의 애플리케이션이 있으므로 노드가 모든 대역폭을 사용할 수 없다.</li>\n<li>p2p 네트워크는 필연적으로 자체 오버헤드를 발생시킨다. 노드는 동일한 블록을 여러번 다운로드하거나 재업로드한다.(블록에 포함되기 <strong>전에</strong> 트랜잭션이 멤풀(mempool)을 통해 여러 곳으로 전송되는 것은 물론이다)</li>\n</ol>\n<p><a href="https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-eyal.pdf">트랜잭션 데이터 가스 비용이 감소</a>되자 2019년 Starkware 팀은 500kB 크기의 블록들을 퍼블리싱하는 실험을 진행할 수 있었는데, 실제로 이 실험에서 소수의 노드들은 해당 크기의 블록을 처리할 수 없었다. 물론 그 이후 큰 사이즈의 블록을 처리하기 위해 많은 개선이 이루어졌으며, 이는 앞으로도 계속해서 개선될 예정이다. 하지만 현재로서는 MB/sec 단위의 평균 대역폭이나 1초 수준의 레이턴시(latency)를 가정하거나, 이처럼 큰 사이즈의 블록을 생성하는 것들은 여전히 요원한 상황이다.</p>\n<p><strong>저장용량(Storage)</strong></p>\n<ul>\n<li>\n<strong>오답</strong>: 10 테라바이트</li>\n<li>\n<strong>정답</strong>: 512 기가바이트</li>\n</ul>\n<p>저장용량에 대한 주요 논점은 다른 모든것들이 그런것처럼 이론과 현실의 차이에 있다. <strong>이론상으로는</strong><em> </em>아마존에서 <a href="https://www.amazon.com/SAMSUNG-870-QVO-SATA-MZ-77Q8T0B/dp/B089C3TZL9/ref=sr_1_3?dchild=1&amp;keywords=8tb&amp;qid=1621637865&amp;s=pc&amp;sr=1-3">8TB SSD</a>(반드시 SSD나 NVME가 필요하다. HDD는 블록체인 상태를 저장하기에는 너무 느리기 때문이다)를 구매할 수 있다. <strong>실제로는</strong> 이 글을 작성하는 데 사용된 노트북은 512GB이고, 사람들에게 블록체인에 사용할 하드웨어를 직접 구매하라고 하면, 대부분은 매우 귀찮아서(혹은 800 달러나 하는 8 TB SSD를 구매할 여유가 없을 수도 있다.) 중앙화된 서비스를 이용할 것이다. 또한 블록체인에 적합한 일부 저장장치가 있다고 하더라도, 매우 활발하게 생성되는 블록체인의 데이터를 저장하다보면 디스크는 금방 꽉 차게 될 것이고, 여러분은 계속해서 새로운 저장장치를 구매할 수 밖에 없게 될 것이다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/420/0*m6E9ffYbXYY3w9tD"><figcaption><em>블록체인 프로토콜 연구자들을 대상으로 한 현재 보유중인 디스크 저장용량에 대한 설문조사. 표본이 작긴 하지만, 여전히 (의미는 있다)…</em></figcaption></figure><p>또한 저장공간의 크기는 새로운 노드가 네트워크에 참여하기 위해 필요한 시간을 결정한다. 기존 노드가 저장해야 하는 모든 데이터는 곧 새로운 노드가 다운로드해야 하는 데이터이다. 이 초기 동기화 시간(및 대역폭)은 사용자들이 노드를 운영하는데 주요 장애물로 작용한다. 이 글을 작성하는 동안 새로운 geth 노드를 동기화하는데 약 15시간이 소요됐다. 이더리움의 사용량이 10배가 되었다면 새로운 geth 노드를 동기화하는 것은 최소 일주일 이상이 걸릴 것이고, 이로 인해 인터넷 연결에 스로틀링(Throttling)이 발생할 가능성이 매우 높다. 이러한 요소는 공격 상황에서 더 중요해지는데, 공격을 성공적으로 방어하기 위해서는 이전에 노드를 운영하지 않았던 많은 사용자들이 새로운 노드를 실행하는것이 필요하기 때문이다.</p>\n<h3>상호작용 효과(Interaction effects)</h3>\n<p>이 세가지 비용들의 상호작용에 대한 효과도 존재한다. 데이터베이스는 내부적으로 데이터를 저장하고 읽어오기 위해 트리 구조를 사용하기 때문에, 데이터를 가져오는데 소요되는 비용은 데이터베이스 크기에 비례해 로그적으로 증가한다. 사실, 트리의 상위 레벨들은 RAM에 캐싱할 수 있으므로, 디스크 액세스 비용은 RAM에 캐싱된 데이터 크기의 배수로 데이터베이스의 크기에 비례하게 된다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/582/0*CW324HxNdDfglsrM"><figcaption><em>이 다이어그램은 설명의 편의를 위해 매우 단순하게 표현되었다. 각각의 데이터베이스는 서로 다른 방식으로 작동하며 많은 경우 메모리 부분은 (크지만) 단일 레이어이다(leveldb에서 사용되는 </em><a href="http://paperhub.s3.amazonaws.com/18e91eb4db2114a06ea614f0384f2784.pdf"><em>LSM trees</em></a><em>를 참고하라). 그러나 기본적인 원리는 같다.</em></figcaption></figure><p>예를 들어, 캐시가 4GB이고 데이터베이스의 각 레이어가 그 이전보다 4배 더 크다고 가정한다면, 약 64GB의 이더리움의 현재 상태 데이터는 상태는 약 2번의 액세스를 필요로 할것이다. 만약 이 상태 크기가 4배 더 증가하여 약 256GB가 된다면, 3번의 액세스를 필요로 할 것이다. 즉, 가스 리밋(gas limit)이 4배 증가하면 실질적으로 블록 검증 시간은 약 6배 증가할 수 있다. 이러한 효과는 더욱 강력해질수도 있는데, 하드디스크는 비어있을 때보다는 가득 찼을 때 읽고 쓰는 시간이 더 증가하기 때문이다.</p>\n<h3>이것이 이더리움에게 의미하는 바는 무엇인가?</h3>\n<p>오늘날 이더리움 블록체인 노드를 일반적인 하드웨어에서 운영하는 것이 가능은 하지만(이 글을 쓰는 동안에 나 또한 노트북으로 노드를 동기화했다!), 여전히 많은 사용자들에게는 어려운 일이다. 현재 우리는 병목 구간에 거의 근접해 있는데, <strong>코어 개발자들이 가장 우려하고 있는 것은 저장공간의 크기와 관련된 문제이다.</strong> 따라서 현재로써는, 연산과 데이터의 병목을 해결하기 위해 많은 노력을 기울이거나, 심지어 합의 알고리즘을 변경하더라도 가스 리밋을 대폭 증가시키는 것은 매우 어려울 것이다. <a href="https://blog.ethereum.org/2021/05/18/eth_state_problems/">이더리움의 최대 DoS 취약점을 해결하는 방법</a>도 가스 리밋을 단지 20% 증가시켰을 뿐이다.</p>\n<p>저장공간 크기에 대한 문제를 해결할 수 있는 유일한 방법은 <a href="https://hackmd.io/@vbuterin/state_expiry_paths">무상태성(statelessness)과 상태 만료(state expiry)</a>를 이용하는 것이다. <strong>무상태성</strong>은 영구적인 저장공간을 사용하지 않고도 체인을 검증할 수 있는 노드 클래스를 이용할 수 있게 해준다. <strong>상태 만료</strong>는 최근에 액세스되지 않은 상태들을 일시적으로 제거한 뒤, 이를 갱신하기 위해서는 사용자들이 직접 이에 대한 증명을 제출하도록 한다. 이러한 두가지 방법에 대한 작업은 이미 오래 전부터 계속해서 진행되고 있으며, 무상태성에 대한 개념 증명(proof-of-concept) 구현은 이미 착수 되었다. 이 두 가지 개선 사항을 결합하면 저장공간에 대한 문제를 완화하고 가스 리밋을 증가시킬 수 있는 여지를 만들어 낼 수 있다. <strong>하지만 무상태성과 상태 만료가 모두 성공적으로 도입되더라도, 다른 문제들이 완전히 해결되기 전에는 가스 리밋을 약 3배 수준까지 증가시키는 것이 최선일 것이다.</strong></p>\n<p>또 다른 중기적 솔루션은 ZK-SNARKs를 이용하여 트랜잭션을 검증하는 것이다. ZK-SNARKs를 이용하면 일반 사용자가 직접 스테이트를 저장하거나 블록을 검증할 필요가 없어질 수 있다. 물론 여전히 데이터 비가용성 공격으로부터 방어하기 위해 사용자들은 블록의 모든 데이터를 다운로드 해야 한다. 더불어 공격자가 유효하지 않은 블록을 강제로 포함시킬 수 없더라도, 만약 컨센서스 노드 운영에 어려움을 겪을 정도로 처리 용량이 지나치게 증가한다면 여전히 조직적인 검열 공격(censorship attack)이 발생할 위험이 있다. 따라서 ZK-SNARKs은 처리 용량을 무한히 늘릴 수는 없지만 상당히 큰 규모로(약 1~2배) 처리 용량을 늘릴 수 있다. 일부 체인은 레이어 1에서 이러한 방식을 도입하려고 하고 있지만, 이더리움은 이를 <a href="https://zksync.io/">zksync</a>, <a href="https://loopring.org/">Loopring</a>, <a href="https://medium.com/starkware/on-the-road-to-starknet-a-permissionless-stark-powered-l2-zk-rollup-83be53640880">Starknet</a> 과 같은 레이어 2 프로토콜(<a href="https://vitalik.ca/general/2021/01/05/rollup.html">ZK rollups</a>)을 통해 활용하고 있다.</p>\n<h3><strong>샤딩을 도입한다면?</strong></h3>\n<p><strong>샤딩은 앞에서 논의한 여러 한계점들을 근본적으로 해결할 수 있는데, 이는 블록체인에 포함되는 데이터와 단일 노드가 처리하고 저장해야 하는 데이터를 분리하기 때문이다.</strong> 각 노드들은 모든 블록을 직접 다운로드하고 실행하는 대신에, <a href="https://vitalik.ca/general/2021/04/07/sharding.html">진보된 암호수학적 기술</a>을 통해 블록들을 간접적으로 검증하게 된다.</p>\n<p>이로 인해 샤딩 체인은 비-샤딩 블록체인이 달성할 수 없는 매우 높은 수준의 트랜잭션 처리량을 안전하게 달성할 수 있다. 물론 이는 유효하지 않은 블록을 성공적으로 검증하는 완전 검증(full validation)방식을 효율적으로 대체할 수 있는 많은 정교한 암호학적 기술을 필요로하지만, 이는 어쨌든 가능한 상황이다. 이에 관한 <a href="https://hackmd.io/@vbuterin/das">이론</a>도 <a href="https://vitalik.ca/general/2021/01/26/snarks.html">잘 정립되어</a> 있으며, <a href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/sharding/beacon-chain.md">설계 초안</a>에 기반한 개념 증명에 대한 <a href="https://github.com/protolambda/eth2-das">작업도 이미 활발하게 진행</a>되고 있다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ru67pfWmPlvHkuIM"></figure><p>이더리움은 <strong>쿼드라틱(quadratic) 샤딩</strong>을 사용할 계획이며, 따라서 전체 확장성은 한 노드가 각 샤드에 대한 필수 관리 작업을 수행하는 비콘 체인과 단일 샤드를 모두 처리할 수 있는 수준으로 제한된다. 만약 샤드가 너무 크다면, 노드들은 개별 샤드를 더 이상 제대로 처리하지 못할것이며, 반대로 너무 많은 샤드가 있다면 노드들은 비콘 체인을 처리할 수 없게 될 것이다. 이 두가지 제약 조건의 곱이 전체 확장성의 상한선을 결정하게 되는 것이다.</p>\n<p>누군가는 여기서 더 나아가 큐빅(cubic) 샤딩 또는 심지어 기하급수적(exponential) 샤딩까지 도입하려 할 수 있다. 이러한 모델에서는 데이터 가용성 샘플링이 더욱 더 복잡해 질 것이지만, 어쨌든 가능은 할 것이다. 하지만 이더리움은 쿼드라틱 이상으로 더 나아가지 않을 것이다. 그 이유는 트랜잭션들의 샤드(shards-of-transactions)에서 트랜잭션들의 샤드의 샤드(shards-of-shards-of-transactions)로 변경하여 확보할 수 있는 추가적인 확장성이 매우 높은 위험을 수반할 수 밖에 없기 때문이다.</p>\n<p>그렇다면 구체적으로 어떠한 위험들이 있는가?</p>\n<h3><strong>최소 사용자 수</strong></h3>\n<p>비-샤딩 블록체인은 단 한명의 사용자만 네트워크에 참여하고 있는한 계속해서 운영될 수 있다. 하지만 샤딩 블록체인은 이와 다르게, 단일 노드가 모든 체인을 처리할 수 없다. 따라서 해당 체인을 최소한으로 함께 처리할 수 있는 충분한 수의 노드를 확보해야만 한다. 각 노드가 50 TPS를 처리할 수 있고, 체인은 10000 TPS를 처리할 수 있다면, 해당 체인에는 최소한 200개의 노드가 필요하다. 만약 노드의 수가 200개보다 낮아진다면, 노드들이 체인을 따라잡을 수 없거나 유효하지 않은 블록을 검증할 수 없게 될 것이고, 또는 구체적인 노드 소프트웨어의 설정값에 따라 수 많은 다른 오류가 발생할 수도 있다.</p>\n<p>현실적으로 안전한 수준의 최소 노드 수는 단순히 “체인 TPS를 노드 TPS로 나눈 것” 보다는 수 배 이상 더 높은데, 이는 <a href="https://hackmd.io/@vbuterin/das">데이터 가용성 샘플링(data availability sampling)</a>을 포함한 중복(redundancy) 작업을 필요로 하기 때문이다. 위의 예시에서, 이러한 안전한 최소 노드 수가 1000개라고 하자.</p>\n<p>샤딩 블록체인의 처리 용량이 10배 증가할 경우, 필요한 최소 노드 수 또한 10배 증가할 것이다. 이 때, 이런 질문을 할 수도 있다. “처음에는 낮은 수준의 처리 용량으로 시작하고, 실제로 필요한 수만큼의 사용자들이 확보가 되었을 때 이를 증가시키고, 사용자의 수가 줄어들 때는 감소시키면 되지 않을까?”</p>\n<p>이러한 방식에는 다음과 같은 몇가지 문제가 있다.</p>\n<ol>\n<li>블록체인 자체는 해당 체인에 실제로 고유한 사용자들이 몇명이나 있는지 정확히 파악할 수 없다. 따라서 적절한 샤드의 수를 파악하고 결정하는기 위해서는 일종의 거버넌스가 필요할 것이다. 이러한 처리 용량 제한에 대한 거버넌스는 <a href="https://en.bitcoin.it/wiki/Block_size_limit_controversy">분열과 갈등의 중심이 될 가능성이 높다.</a>\n</li>\n<li>만약 갑자기 많은 사용자들이 동시에 네트워크에서 빠져나간다면 어떻게 되는가?</li>\n<li>포크에 필요한 최소 사용자의 수를 높이는 것은 적대적 네트워크 점유 공격에 대응하기 어렵게 만든다.</li>\n</ol>\n<p>최소 사용자의 수가 1000 이하라면 거의 확실하게 문제가 없을 것이다. 반대로, 이 수가 1백만이라면 확실하게 문제가 발생할 것이다. 심지어 1만이라는 최소 사용자 수도 꽤 위험해지기 시작하는 수치이다. <strong>따라서, 샤드의 수를 수백개 이상으로 늘린 샤딩 블록체인이 타당하다고 보기는 매우 쉽지 않을 것이다.</strong></p>\n<h3><strong>기록 복구 가능성(History retrievability)</strong></h3>\n<p>사용자들이 가장 가치있게 여기는 블록체인의 중요한 속성은 바로 영구성(permanence)이다. 한 서버에 저장된 디지털 자산은 해당 기업이 그 생태계를 유지할 유인을 잃거나 또는 파산한다면 10년 내에 사라지게 될 것이다. 반대로, 이더리움의 NFT는 영원히 존재한다.</p>\n<blockquote>역주: 싸이월드에서 서비스 재개 가능성을 타진 하면서 <a href="https://www.chosun.com/economy/tech_it/2021/05/25/HJVV7TP5VJFLJNWBKDRICH5CSA/">약 38억원 어치의 도토리를 환불</a>할 것임을 밝혔다. 만약 싸이월드가 그대로 역사의 뒤안길로 사라졌다면, 이 도토리들은 어떻게 되었을까?</blockquote>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/800/0*_4fE7tyTRyPvxR4G"><figcaption><em>그렇다. 사람들은 당신의 크립토 키티를 2371년에도 찾아보고 다운로드 할 수 있을 것이다. 이는 분명한 사실이다.</em></figcaption></figure><p>하지만 블록체인의 용량이 지나치게 높아진다면, 이러한 모든 데이터를 저장하는 것에 어려움이 생길 수 있다. 어느 시점까지 히스토리 데이터의 일부를 어떤 노드도 저장하지 않을 위험이 커질 수 있다.</p>\n<p>이러한 위험을 측정하는 것은 비교적 쉽다. 블록체인 데이터 처리 용량을 MB/sec 단위로 측정하고, 이에 약 30을 곱해주면 매년 저장될 데이터의 테라바이트 단위 용량을 구할 수 있다. 현재 샤딩은 약 1.3MB/sec 의 처리 용량을 가정하고 있으므로, 대략 40 TB/year 만큼 데이터가 저장될 것이다. 만약 이를 10배 높인다면, 400 TB/year 가 될 것이다. 이러한 데이터에 대한 접근성을 더욱 높이기 위해서는 메타데이터(예: 롤업 트랜잭션 압축 해제)와 같은 것들이 필요할 수 있고, 이를 통해 연간 4 페타바이트 심지어 약 10년 후에는 연간 40페타바이트까지 확장할 수 있을 것이다. 인터넷 아카이브(Internet Archive)가 현재 <a href="https://archive.org/web/petabox.php">50 페타바이트</a> 정도를 사용하고 있는데, 이러한 수치는 샤딩 블록체인이 안전하게 확보할 수 있는 합리적인 상한선이라고 할 수 있다.</p>\n<p>따라서, 이러한 두가지 차원에서, <strong>이더리움 샤딩 설계는 사실 이미 의미있는 수준의 안전한 최댓값에 상당히 근접한 수치를 목표를 하고 있다.</strong> 구체적인 값들은 소폭 증가할 수 있겠지만, 여기에서 더 크게 증가하지는 않을 것이다.</p>\n<h3><strong>정리</strong></h3>\n<p>블록체인의 확장성을 높이는 방법에는 크게 두가지가 있다. 하나는 <strong>기술을 근본적으로 개선하는 것</strong>이고, 다른 하나는 단순히 <strong>파라미터 값을 늘리는 것</strong>이다. 언뜻 보기에 파라미터 값을 늘리는것은 매우 매력적으로 보인다. 단순하게 계산을 해보면 일반적인 노트북으로 ZK-SNARKs, 롤업, 샤딩과 같은 기술 없이 초당 수천건의 트랜잭션을 처리하는것에는 크게 문제가 없을 것처럼 보인다. 안타깝지만, 이러한 접근 방식에는 근본적으로 결함이 있을 수 밖에 없는 여러가지 미묘한 이유가 있다.</p>\n<p>블록체인 노드를 운영하는 컴퓨터는 체인을 검증하는데 100%의 CPU 파워를 할당할 수 없다. 예를 들어, 예상치 못한 DoS 공격에 대비하기 위해 높은 수준의 안전마진이 필요하고, 멤풀에 있는 트랜잭션들을 처리하는 작업등을 위해 여유 CPU 용량이 필요하다. 무엇보다 여러분은 해당 컴퓨터에서 오로지 노드만 운영할 수 있고, 다른 어떤 애플리케이션도 동시에 사용할 수 없는 상황을 바라지는 않을 것이다. 비슷한 이유로 대역폭에도 오버헤드가 발생하게 된다. 10MB/s 라는 수치는 초당 10MB의 블록을 받을 수 있다는 것을 의미하는게 아니다! 아마도 12초당 1~5MB 정도의 블록을 받을 수 있을 것이다. 저장 용량도 마찬가지다. 요컨대, 노드를 운영하는데 필요한 하드웨어 요구사항을 높여 노드 운영을 특수한 참여자에게만 제한하는것은 올바른 해결책이 아니다. <strong>블록체인이 탈중앙화되기 위해서 가장 중요한 것은 일반적인 사용자들이 직접 노드를 운영할 수 있도록 하고, 노드를 직접 운영하는 것이 지극히 일상적인 행위가 되는 문화를 만드는 것이다.</strong></p>\n<p>반대로, 기술을 근본적으로 개선하는 것은 해결책이 될 수 있다. <strong>현재 이더리움의 가장 큰 병목은 저장 용량에 있는데, 이는 무상태성(statelessness)과 상태 만료(state expiry)와 같은 방법들을 통해 이를 해결할 수 있으며</strong>, 노드 운영의 효율성을 현재 방식에 비해 최대 약 3배까지 끌어올릴 수 있다. <strong>샤딩을 도입하다면 이는 더 크게 증가할 수 있다.</strong> 샤딩 체인에서는 단일 노드가 모든 트랜잭션을 처리할 필요가 없어지기 때문이다.</p>\n<p>하지만 심지어 이러한 방식에도 한계가 존재한다. 처리 용량이 증가할수록 최소한으로 필요한 사용자의 수가 증가하게 되고, 체인을 아카이빙(archiving)하는 비용도 증가하며, 더불어 어느 누구도 체인 데이터를 아카이빙하지 않을 경우 데이터를 모두 잃어버릴 위험 또한 증가하게 된다. 물론, 이에 대해 크게 걱정할 필요는 없다. 이러한 한계에 대한 기준 자체가 충분히 높기 때문에, 블록체인의 안전성을 완전히 보장한 상태에서 초당 약 수백만건의 트랜잭션을 처리할 수 있을 것이다. 그러나 블록체인의 핵심 가치인 탈중앙성을 희생하지 않고 이러한 것들을 달성하기 위해서는 앞으로도 많은 노력이 필요할 것이다.</p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=802b3e036384" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%99%95%EC%9E%A5%EC%84%B1%EC%9D%98-%ED%95%9C%EA%B3%84-the-limits-to-blockchain-scalability-802b3e036384">블록체인 확장성의 한계(The Limits to Blockchain Scalability)</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                enclosure: {},
                categories: [
                  "ethereum",
                  "research",
                  "layer-2",
                  "vitalik-buterin",
                  "blockchain",
                ],
              },
              {
                title: "Tokamak Network Biweekly Report #3 [EN/KR]",
                pubDate: "2021-05-26 09:03:47",
                link:
                  "https://medium.com/onther-tech/tokamak-network-biweekly-report-3-en-kr-d9355600226b?source=rss----eb8117f0bafd---4",
                guid: "https://medium.com/p/d9355600226b",
                author: "Onther",
                thumbnail:
                  "https://cdn-images-1.medium.com/max/1024/1*SVdKHRPqtjFaipUIFqN5qg.jpeg",
                description:
                  '\n<h3>Tokamak Network(TON) Biweekly Report: May.9–22</h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*SVdKHRPqtjFaipUIFqN5qg.jpeg"></figure><h3><strong>Ecosystem</strong></h3>\n<p><strong>1.1. Staking Update</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/834/1*cGPHga-J0tze_4C1XaBmwQ.png"></figure><p>As of May 22nd, the total staked TON has increased to 11,117,754.2 TON by 5.48% from 10,539,938 TON on May 5th.</p>\n<p>Additionally, the winner <a href="https://etherscan.io/address/0xe300edA0ED3E6D1C89B1568d47b8D5377FD21327">0xe300…1327</a> of the 17th Power TON game, which is being held for the staking participants, received 25,090.72 TON on May 23rd. Congratulations!</p>\n<p>If you participate in Tokamak Network’s staking,</p>\n<ul>\n<li><a href="https://staking-simulator.tokamak.network/">45% APY</a></li>\n<li>Power TON game reward</li>\n<li>And other various benefits and events will be waiting for you.</li>\n</ul>\n<p><strong>1.2. Transaction</strong></p>\n<p>Tokamak Network had 1,329 transactions in the last two weeks, which is an increase of 19.3% from 1,114 transactions from the previous two weeks (April 25 — May 8).</p>\n<p><strong>1.3. DAO Update</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/905/1*SiUctFl4ZKNRc3NxZuzgAA.png"></figure><p>As a result of the vote in favor of the DAO #3 agenda, the research grant for Zero-Knowledge Virtual Machine was delivered to GIST (Gwangju Institute of Science and Technology) on the 14th.</p>\n<p><strong>1.4. Price</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/792/1*990PhtCe5mWV6Nb-OGqZjw.png"></figure><p>As of May 22nd, Tokamak Network is ranked 135th on the market cap rank list by <a href="https://www.coingecko.com/en/coins/tokamak-network/historical_data/usd#panel">CoinGecko</a> with a market cap of $367,627,243. TON was at its highest at $16.68 and lowest at $5.31 during the past two weeks. Total trading volume increased by 7.1% to $1,233,592,724 compared to $1,151,798,078 from the last 2 weeks. Meanwhile, Uniswap had the liquidity decreased by 24.14% to $3,231,257 compared to 4,259,619, and the total trading volume increased by 79.52% to $6,376,560 compared to $ 3,552,097. TON is currently tradable on Upbit, Upbit Indonesia, and <a href="https://info.uniswap.org/pair/0x2a449a6076001080c833324bb7a3dcd017f15548">Uniswap</a>.</p>\n<h3><strong>Technology Development</strong></h3>\n<p><strong>2.1. Research</strong></p>\n<p>Tokamak Network posted 5 Korean and 1 English research article. They can be found on the blog of Onther, the developer of Tokamak Network.</p>\n<p><strong>Korean</strong></p>\n<blockquote><a href="https://medium.com/onther-tech/how-does-optimisms-rollup-really-work-249797c91336?source=collection_home---4------1-----------------------">How does Optimism’s Rollup really work?</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EB%B2%A0%EB%A5%BC%EB%A6%B0-%ED%95%98%EB%93%9C%ED%8F%AC%ED%81%AC-%EC%9D%B4%ED%9B%84-%ED%86%A0%EC%B9%B4%EB%A7%89-%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%82%B9-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B0%80%EC%8A%A4-%EC%B5%9C%EC%A0%81%ED%99%94-f87aedc7cc8c?source=collection_home---4------3-----------------------">Gas optimization of the Tokamak staking system after the Berlin hard fork</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">Using Optimistic Rollup</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">Using ERC20 in Optimistic Rollup</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d">Using ERC721 in Optimistic Rollup</a></blockquote>\n<p><strong>English</strong></p>\n<blockquote><a href="https://medium.com/onther-tech/optimistic-rollup-is-not-secure-enough-than-you-think-cb23e6e6f11c?source=collection_home---4------0-----------------------">Optimistic Rollup is Not Secure Enough Than You Think</a></blockquote>\n<p><strong>2.2. Tech Development</strong></p>\n<p>Tokamak Network strives to provide a variety of Layer 2 protocols as an On-demand Layer 2 platform.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*EvMJ8F8fyMPwMMkZ.jpeg"></figure><ul><li>In collaboration with Atomrigs Lab, Inc, we plan to launch the decentralized ‘Launch Pad’ (tentative name) in June. The features of the decentralized Launch Pad, adopting features of DeFi platforms, are as follows.</li></ul>\n<p><em>1) Decentralized</em></p>\n<p><em>2) Asset storage through a smart contract</em></p>\n<p><em>3) Quick and easy accessibility</em></p>\n<p><em>4) Open-source &amp; verified audit</em></p>\n<p><em>5) Transparent governance</em></p>\n<p><em>6) Quick and easy project launch</em></p>\n<p>In addition, TON, the ecosystem token of Tokamak Network, will be used in various ways in the decentralized Launch Pad.</p>\n<ul>\n<li>We started to change and upgrade py-evm, which is implemented in Python with high productivity, to py-ovm. py-ovm will be used for PoC or for communication between developers.</li>\n<li>Tokamak Network is currently conducting research and developing technology to apply Optimism Rollup to Tokamak Network. Research materials related to this are constantly being posted on the Onther blog.</li>\n<li>On the Tokamak Network’s GitHub, there have been 38 commits in 4 repositories in the last two weeks. For detailed development progress, please visit <a href="https://github.com/Onther-Tech?page=1">Onther Inc. Technology · Github</a>.</li>\n</ul>\n<h3><strong>Community</strong></h3>\n<p><strong>3.1. News</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/600/1*dxlo3nK60IX3vl8AudZgfA.png"></figure><ul><li>This Tuesday, the 25th of May, Aiden, a researcher at Tokamak Network, will hold a presentation about ‘Cross-chain AMM and Layer 2’ in an online webinar <a href="https://www.meetup.com/Seoul-Ethereum-Meetup/events/278318594">‘DeFi Beyond Hype’</a> co-hosted by the Blockchain Law Society, Seoul Ethereum Meetup, and CoinDesk Korea and sponsored by Paxnet News.</li></ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/917/1*fIXqgWE2MobnIzGzQnbKNg.png"></figure><ul><li>This Wednesday, the 26th of May, Darren, the blockchain developer at Tokamak Network, plans to give an explanation and demonstration of Optimystic Rollup at <a href="https://www.meetup.com/ko-KR/Jeju-Blockchain-Meetup/events/278374882/">Jeju blockchain developers’ meeting</a> sponsored by CONSENSYS.</li></ul>\n<p><strong>3.2. Marketing</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/560/0*8a5GKwhmC4NKV66f"></figure><p>Events 2 and 3 ended on May 13 with the 5th payment of the NFT event held by Tokamak Network from April. This NFT is a token provided to those who have contributed to the development of the healthy ecosystem of Tokamak Network and will be used in various Tokamak Network ecosystem activities in the future.</p>\n<p><strong>3.3. Community</strong></p>\n<p>Tokamak Network operates a variety of communities. The official community channels of Tokamak Network are:</p>\n<ul>\n<li>Telegram: <a href="https://t.me/tokamak_network">https://t.me/tokamak_network</a>\n</li>\n<li>Discord: <a href="https://discord.gg/SZw2WSR">https://discord.gg/SZw2WSR</a>\n</li>\n<li>Twitter: <a href="https://twitter.com/tokamak_network">https://twitter.com/tokamak_network</a>\n</li>\n<li>Medium: <a href="https://medium.com/onther-tech">https://medium.com/onther-tech</a>\n</li>\n</ul>\n<p><strong>3.4. New Member</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/607/1*qOX2lIZoo5sh5Uk6JH25Kg.png"></figure><p>We would like to introduce a new member of Tokamak Network. <strong>Onuwa Nnachi Isaac</strong> has joined Tokamak Network as a front-end engineer and he is an open-source engineer with a passion for decentralized economy. He has a career in designing, implementing, and maintaining Dapps, and has contributed to various blockchain projects including Ethereum, Status, Gitcoin, Livepeer, and Gitcoin.</p>\n<p><strong>3.5. Job openings</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*e_GfbP4AoY0sAX_F"></figure><p>Onther, the developer of Tokamak Network, is hiring blockchain technology specialists. Layer2 (plasma/rollup), client developer Mathematician / ZKP Researcher, Smart Contract Developer, Blockchain Researcher, Economist (Governance), Web UI/UX Designer, and other job openings are available. Please visit Onther blog to find <a href="https://medium.com/onther-tech/job-openings-blockchain-tech-902098537088">more details</a>.</p>\n<p><strong>Note</strong>: There are comments and direct messages from impersonators pretending to be members of Tokamak Network and Onther.</p>\n<p>In any case, Onther and Tokamak Network <strong>NEVER </strong>ask for deposits or request private keys through comments or direct messages.</p>\n<h3>Ecosystem</h3>\n<p><strong>1.1. Staking Update</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/834/1*cGPHga-J0tze_4C1XaBmwQ.png"></figure><p>2021년 5월 22일 기준 스테이킹 총량은 11,117,754.2 TON으로 5월 8일 스테이킹 수량인 10,539,938 TON 대비 5.48 %가 증가했습니다.</p>\n<p>이와 함께 스테이킹에 참여한 분들을 대상으로 진행되고 있는 17회 Power TON 게임의 당첨자는 <a href="https://etherscan.io/address/0xe300edA0ED3E6D1C89B1568d47b8D5377FD21327">0xe300…1327</a>로 5월 23일 25,090.72 TON을 수령했습니다. 축하합니다!</p>\n<p>토카막 네트워크의 스테이킹에 참여하시면</p>\n<ul>\n<li><a href="https://staking-simulator.tokamak.network/">45%의 APY</a></li>\n<li>Power TON 게임 참여</li>\n<li>비정기적 이벤트 참여 등 다양한 혜택을 받으실 수 있습니다.</li>\n</ul>\n<p><strong>1.2. Transaction</strong></p>\n<p>토카막 네트워크의 트랜잭션은 지난 2주간 1,329건이 발생했으며, 4월 25일-5월 8일 1,114건 대비 19.3% 증가를 기록했습니다.</p>\n<p><strong>1.3. DAO update</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/905/1*SiUctFl4ZKNRc3NxZuzgAA.png"></figure><p>DAO #3 아젠다의 찬성 투표 결과로 GIST(광주과학기술원)에 Zero Knowledge Virtual Machine 연구지원금이 14일에 전달 완료되었습니다.</p>\n<p><strong>1.4. Market Cap</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/792/1*990PhtCe5mWV6Nb-OGqZjw.png"></figure><p>토카막 네트워크는 5월 22일 <a href="https://www.coingecko.com/en/coins/tokamak-network/historical_data/usd#panel">코인게코</a> 기준, 시가총액 $367,627,243을 기록해 135위에 등재되었습니다. 2주간 최고 $16.68, 최저 $5.31이었으며, 거래량은 총 거래액은 지난 2주 $1,151,798,078 대비 $1,233,592,724으로 7.1% 증가했습니다. 유니스왑에서 지난 2주간 liquidity는 $4,259,619에서 $3,231,257로 24.14% 감소했으며, 총 거래량은 $3,552,097에서 $6,376,560으로 79.52% 증가했습니다. 현재 토카막 네트워크는 업비트, 업비트 인도네시아, <a href="https://v2.info.uniswap.org/pair/0x2a449a6076001080c833324bb7a3dcd017f15548">유니스왑</a>에서 거래가 가능합니다.</p>\n<h3>Technology Development</h3>\n<p><strong>2.1. Research</strong></p>\n<p>토카막 네트워크는 해당 기간동안 5건의 국문 리서치 자료 및 1건의 영문 리서치를 포스팅했습니다. 해당 포스팅은 토카막 네트워크의 개발사 온더의 블로그에서 확인이 가능합니다.</p>\n<p><strong>국문</strong></p>\n<blockquote><a href="https://medium.com/onther-tech/how-does-optimisms-rollup-really-work-249797c91336?source=collection_home---4------1-----------------------">How does Optimism’s Rollup really work?</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EB%B2%A0%EB%A5%BC%EB%A6%B0-%ED%95%98%EB%93%9C%ED%8F%AC%ED%81%AC-%EC%9D%B4%ED%9B%84-%ED%86%A0%EC%B9%B4%EB%A7%89-%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%82%B9-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B0%80%EC%8A%A4-%EC%B5%9C%EC%A0%81%ED%99%94-f87aedc7cc8c?source=collection_category---4------3-----------------------">베를린 하드포크 이후 토카막 스테이킹 시스템의 가스 최적화</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">옵티미스틱 롤업 사용하기</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">옵티미스틱 롤업에서 ERC20 사용하기</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d">옵티미스틱 롤업에서 ERC721 사용하기</a></blockquote>\n<p><strong>영문</strong></p>\n<blockquote><a href="https://medium.com/onther-tech/optimistic-rollup-is-not-secure-enough-than-you-think-cb23e6e6f11c?source=collection_home---4------0-----------------------">Optimistic Rollup is Not Secure Enough Than You Think</a></blockquote>\n<p><strong>2.2. Tech Development</strong></p>\n<p>토카막 네트워크는 온디맨드 레이어 2 플랫폼으로 다양한 레이어 2 프로토콜을 제공하고자 노력하고 있습니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*sc0pjzgxiQUMTP-P.jpeg"></figure><ul><li>\n<a href="https://www.facebook.com/atomrigsC/?__cft__%5B0%5D=AZWZuTzEnlKXPTa5UQrQOcgnEtSE46nTqPR8VkD_pRngEX2ryfCLTIBfwfezW8k6RQlR_oTncKaSwMdhtoWfkna4ySo1Cl0W1AT6fiJAuVf0WLkt7kao0nrgdSM8_epdLAuvOKtS0cqr7a87Oe8LXYQDY7uXHZZ05GJpanmUjf2NKptefZ4zBL2HPHeFZYzo_W8&amp;__tn__=kK-R">Atomrigs Lab, Inc</a> 과 협업으로 오는 6월 탈중앙화된 ‘론치패드’(가칭)를 공개할 예정입니다. 디파이 플랫폼의 특징을 차용한 탈중앙화된 론치패드의 특징은 다음과 같습니다.</li></ul>\n<p>1) 탈중앙화</p>\n<p>2) 스마트 콘트렉트를 통한 자산 보관</p>\n<p>3) 신속하고 간편한 접근성</p>\n<p>4) 오픈 소스 &amp; 검증된 오딧</p>\n<p>5) 투명한 거버넌스</p>\n<p>6) 신속하고 간편한 프로젝트 론칭</p>\n<p>아울러 토카막 네트워크의 생태계 토큰인 ‘TON’은 이번에 공개할 탈중앙화 론치패드에서 다방면으로 활용될 예정입니다.</p>\n<ul>\n<li>개발생산성이 높은 파이썬으로 구현된 py-evm을 py-ovm으로 변경 및 업그레이드 작업을 시작했습니다. py-ovm은 PoC나 개발자들간 커뮤니케이션을 위한 용도로 사용될 예정입니다.</li>\n<li>토카막 네트워크는 현재 Optimism 롤업을 토카막 네트워크에 적용하기 위한 리서치와 기술을 개발 중입니다. 이와 관련된 리서치 자료는 온더 블로그에 함께 지속적으로 포스팅 중입니다.</li>\n<li>토카막 네트워크의 GitHub 에서는 지난 2주간 4개의 레포지토리에서 38개의 커밋이 발생했습니다. 자세한 개발 진행 상황은 <a href="https://github.com/Onther-Tech?page=1">Onther Inc. Technology · GitHub</a>에서 확인이 가능합니다.</li>\n</ul>\n<h3>Community</h3>\n<p><strong>3.1. News</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/600/1*dxlo3nK60IX3vl8AudZgfA.png"></figure><ul><li>오는 25일 화요일, 블록체인법학회, 서울이더리움밋업, 코인데스크코리아가 공동주최하고, 팍스넷뉴스가 후원하는 온라인 웨비나 <a href="https://www.meetup.com/Seoul-Ethereum-Meetup/events/278318594">‘DeFi Beyond Hype’</a>에 토카막 네트워크 연구원 Aiden은 ‘Cross chain AMM and Layer 2’라는 주제의 발표를 진행할 예정입니다.</li></ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/917/1*fIXqgWE2MobnIzGzQnbKNg.png"></figure><ul><li>토카막 네트워크의 블록체인 개발자 Darren은 5월 26일, CONSENSYS가 후원하는 <a href="https://www.meetup.com/ko-KR/Jeju-Blockchain-Meetup/events/278374882/">제주 블록체인 개발자 모임</a>에서 옵티미스틱 롤업에 대한 설명과 데모를 강연할 계획입니다.</li></ul>\n<p><strong>3.2. Marketing</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/560/0*LWFHwIT34ptxYPDJ"></figure><p>토카막 네트워크가 지난 4월부터 진행한 <a href="https://medium.com/onther-tech/tokamak-network-dao-beta-launch-celebration-nft-giveaway-b749e54a55d9">NFT 이벤트</a>의 5번째 지급과 함께 2, 3번 이벤트가 5월 13일 종료되었습니다. 해당 NFT는 토카막 네트워크의 건전한 생태계 발전에 기여하신 분께 제공하는 징표이며, 향후 다양한 토카막 네트워크 생태계 활동에 활용될 예정입니다.</p>\n<p><strong>3.3. Community</strong></p>\n<p>현재 토카막 네트워크는 다양한 커뮤니티를 운영 중에 있습니다. 토카막 네트워크의 공식 커뮤니티 채널은 다음과 같습니다.</p>\n<ul>\n<li>Telegram: <a href="https://t.me/tokamak_network">https://t.me/tokamak_network</a>\n</li>\n<li>Discord: <a href="https://discord.gg/SZw2WSR">https://discord.gg/SZw2WSR</a>\n</li>\n<li>Twitter: <a href="https://twitter.com/tokamak_network">https://twitter.com/tokamak_network</a>\n</li>\n<li>Medium: <a href="https://medium.com/onther-tech">https://medium.com/onther-tech</a>\n</li>\n</ul>\n<p><strong>3.4. New Member</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/607/1*qOX2lIZoo5sh5Uk6JH25Kg.png"></figure><p>토카막 네트워크의 새로운 멤버를 소개합니다. 프론트앤드 엔지니어로 토카막 네트워크에 합류한 <strong>Onuwa Nnachi Isaac</strong>은 탈중앙화된 경제에 대한 열정을 가진 오픈소스 엔지니어입니다. DAPP의 설계, 구현 및 유지 관리의 커리어를 가지고, Ethereum, Status, Gitcoin, Livepeer, Gitcoin 등 다양한 블록체인 프로젝트에 기여했습니다.</p>\n<p><strong>3.5. Job offer</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*37AFZ8lyoXgebD0O"></figure><p>토카막 네트워크의 개발사 온더는 블록체인 기술 관련 채용을 진행 중입니다. Layer2(plasma/rollup), client developerMathematician / ZKP Researcher, Smart Contract Developer, Blockchain Researcher, Economist(Governance), Web UI/UX Designer 등 다양한 직군에서 모집을 진행하오니 자세한 내용은 <a href="https://medium.com/onther-tech/job-openings-blockchain-tech-902098537088">온더 블로그</a>를 참고 부탁드립니다.</p>\n<p><strong>주의: </strong>최근 온더와 토카막 네트워크를 사칭하는 계정의 댓글 및 개인 메시지가 있습니다.</p>\n<p>온더와 토카막 네트워크는 어떤 경우에도 댓글, 개인 메시지 등을 통한 입금 유도 및 개인키 요구 등을 하지 않습니다.</p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d9355600226b" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/tokamak-network-biweekly-report-3-en-kr-d9355600226b">Tokamak Network Biweekly Report #3 [EN/KR]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                content:
                  '\n<h3>Tokamak Network(TON) Biweekly Report: May.9–22</h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*SVdKHRPqtjFaipUIFqN5qg.jpeg"></figure><h3><strong>Ecosystem</strong></h3>\n<p><strong>1.1. Staking Update</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/834/1*cGPHga-J0tze_4C1XaBmwQ.png"></figure><p>As of May 22nd, the total staked TON has increased to 11,117,754.2 TON by 5.48% from 10,539,938 TON on May 5th.</p>\n<p>Additionally, the winner <a href="https://etherscan.io/address/0xe300edA0ED3E6D1C89B1568d47b8D5377FD21327">0xe300…1327</a> of the 17th Power TON game, which is being held for the staking participants, received 25,090.72 TON on May 23rd. Congratulations!</p>\n<p>If you participate in Tokamak Network’s staking,</p>\n<ul>\n<li><a href="https://staking-simulator.tokamak.network/">45% APY</a></li>\n<li>Power TON game reward</li>\n<li>And other various benefits and events will be waiting for you.</li>\n</ul>\n<p><strong>1.2. Transaction</strong></p>\n<p>Tokamak Network had 1,329 transactions in the last two weeks, which is an increase of 19.3% from 1,114 transactions from the previous two weeks (April 25 — May 8).</p>\n<p><strong>1.3. DAO Update</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/905/1*SiUctFl4ZKNRc3NxZuzgAA.png"></figure><p>As a result of the vote in favor of the DAO #3 agenda, the research grant for Zero-Knowledge Virtual Machine was delivered to GIST (Gwangju Institute of Science and Technology) on the 14th.</p>\n<p><strong>1.4. Price</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/792/1*990PhtCe5mWV6Nb-OGqZjw.png"></figure><p>As of May 22nd, Tokamak Network is ranked 135th on the market cap rank list by <a href="https://www.coingecko.com/en/coins/tokamak-network/historical_data/usd#panel">CoinGecko</a> with a market cap of $367,627,243. TON was at its highest at $16.68 and lowest at $5.31 during the past two weeks. Total trading volume increased by 7.1% to $1,233,592,724 compared to $1,151,798,078 from the last 2 weeks. Meanwhile, Uniswap had the liquidity decreased by 24.14% to $3,231,257 compared to 4,259,619, and the total trading volume increased by 79.52% to $6,376,560 compared to $ 3,552,097. TON is currently tradable on Upbit, Upbit Indonesia, and <a href="https://info.uniswap.org/pair/0x2a449a6076001080c833324bb7a3dcd017f15548">Uniswap</a>.</p>\n<h3><strong>Technology Development</strong></h3>\n<p><strong>2.1. Research</strong></p>\n<p>Tokamak Network posted 5 Korean and 1 English research article. They can be found on the blog of Onther, the developer of Tokamak Network.</p>\n<p><strong>Korean</strong></p>\n<blockquote><a href="https://medium.com/onther-tech/how-does-optimisms-rollup-really-work-249797c91336?source=collection_home---4------1-----------------------">How does Optimism’s Rollup really work?</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EB%B2%A0%EB%A5%BC%EB%A6%B0-%ED%95%98%EB%93%9C%ED%8F%AC%ED%81%AC-%EC%9D%B4%ED%9B%84-%ED%86%A0%EC%B9%B4%EB%A7%89-%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%82%B9-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B0%80%EC%8A%A4-%EC%B5%9C%EC%A0%81%ED%99%94-f87aedc7cc8c?source=collection_home---4------3-----------------------">Gas optimization of the Tokamak staking system after the Berlin hard fork</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">Using Optimistic Rollup</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">Using ERC20 in Optimistic Rollup</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d">Using ERC721 in Optimistic Rollup</a></blockquote>\n<p><strong>English</strong></p>\n<blockquote><a href="https://medium.com/onther-tech/optimistic-rollup-is-not-secure-enough-than-you-think-cb23e6e6f11c?source=collection_home---4------0-----------------------">Optimistic Rollup is Not Secure Enough Than You Think</a></blockquote>\n<p><strong>2.2. Tech Development</strong></p>\n<p>Tokamak Network strives to provide a variety of Layer 2 protocols as an On-demand Layer 2 platform.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*EvMJ8F8fyMPwMMkZ.jpeg"></figure><ul><li>In collaboration with Atomrigs Lab, Inc, we plan to launch the decentralized ‘Launch Pad’ (tentative name) in June. The features of the decentralized Launch Pad, adopting features of DeFi platforms, are as follows.</li></ul>\n<p><em>1) Decentralized</em></p>\n<p><em>2) Asset storage through a smart contract</em></p>\n<p><em>3) Quick and easy accessibility</em></p>\n<p><em>4) Open-source &amp; verified audit</em></p>\n<p><em>5) Transparent governance</em></p>\n<p><em>6) Quick and easy project launch</em></p>\n<p>In addition, TON, the ecosystem token of Tokamak Network, will be used in various ways in the decentralized Launch Pad.</p>\n<ul>\n<li>We started to change and upgrade py-evm, which is implemented in Python with high productivity, to py-ovm. py-ovm will be used for PoC or for communication between developers.</li>\n<li>Tokamak Network is currently conducting research and developing technology to apply Optimism Rollup to Tokamak Network. Research materials related to this are constantly being posted on the Onther blog.</li>\n<li>On the Tokamak Network’s GitHub, there have been 38 commits in 4 repositories in the last two weeks. For detailed development progress, please visit <a href="https://github.com/Onther-Tech?page=1">Onther Inc. Technology · Github</a>.</li>\n</ul>\n<h3><strong>Community</strong></h3>\n<p><strong>3.1. News</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/600/1*dxlo3nK60IX3vl8AudZgfA.png"></figure><ul><li>This Tuesday, the 25th of May, Aiden, a researcher at Tokamak Network, will hold a presentation about ‘Cross-chain AMM and Layer 2’ in an online webinar <a href="https://www.meetup.com/Seoul-Ethereum-Meetup/events/278318594">‘DeFi Beyond Hype’</a> co-hosted by the Blockchain Law Society, Seoul Ethereum Meetup, and CoinDesk Korea and sponsored by Paxnet News.</li></ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/917/1*fIXqgWE2MobnIzGzQnbKNg.png"></figure><ul><li>This Wednesday, the 26th of May, Darren, the blockchain developer at Tokamak Network, plans to give an explanation and demonstration of Optimystic Rollup at <a href="https://www.meetup.com/ko-KR/Jeju-Blockchain-Meetup/events/278374882/">Jeju blockchain developers’ meeting</a> sponsored by CONSENSYS.</li></ul>\n<p><strong>3.2. Marketing</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/560/0*8a5GKwhmC4NKV66f"></figure><p>Events 2 and 3 ended on May 13 with the 5th payment of the NFT event held by Tokamak Network from April. This NFT is a token provided to those who have contributed to the development of the healthy ecosystem of Tokamak Network and will be used in various Tokamak Network ecosystem activities in the future.</p>\n<p><strong>3.3. Community</strong></p>\n<p>Tokamak Network operates a variety of communities. The official community channels of Tokamak Network are:</p>\n<ul>\n<li>Telegram: <a href="https://t.me/tokamak_network">https://t.me/tokamak_network</a>\n</li>\n<li>Discord: <a href="https://discord.gg/SZw2WSR">https://discord.gg/SZw2WSR</a>\n</li>\n<li>Twitter: <a href="https://twitter.com/tokamak_network">https://twitter.com/tokamak_network</a>\n</li>\n<li>Medium: <a href="https://medium.com/onther-tech">https://medium.com/onther-tech</a>\n</li>\n</ul>\n<p><strong>3.4. New Member</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/607/1*qOX2lIZoo5sh5Uk6JH25Kg.png"></figure><p>We would like to introduce a new member of Tokamak Network. <strong>Onuwa Nnachi Isaac</strong> has joined Tokamak Network as a front-end engineer and he is an open-source engineer with a passion for decentralized economy. He has a career in designing, implementing, and maintaining Dapps, and has contributed to various blockchain projects including Ethereum, Status, Gitcoin, Livepeer, and Gitcoin.</p>\n<p><strong>3.5. Job openings</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*e_GfbP4AoY0sAX_F"></figure><p>Onther, the developer of Tokamak Network, is hiring blockchain technology specialists. Layer2 (plasma/rollup), client developer Mathematician / ZKP Researcher, Smart Contract Developer, Blockchain Researcher, Economist (Governance), Web UI/UX Designer, and other job openings are available. Please visit Onther blog to find <a href="https://medium.com/onther-tech/job-openings-blockchain-tech-902098537088">more details</a>.</p>\n<p><strong>Note</strong>: There are comments and direct messages from impersonators pretending to be members of Tokamak Network and Onther.</p>\n<p>In any case, Onther and Tokamak Network <strong>NEVER </strong>ask for deposits or request private keys through comments or direct messages.</p>\n<h3>Ecosystem</h3>\n<p><strong>1.1. Staking Update</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/834/1*cGPHga-J0tze_4C1XaBmwQ.png"></figure><p>2021년 5월 22일 기준 스테이킹 총량은 11,117,754.2 TON으로 5월 8일 스테이킹 수량인 10,539,938 TON 대비 5.48 %가 증가했습니다.</p>\n<p>이와 함께 스테이킹에 참여한 분들을 대상으로 진행되고 있는 17회 Power TON 게임의 당첨자는 <a href="https://etherscan.io/address/0xe300edA0ED3E6D1C89B1568d47b8D5377FD21327">0xe300…1327</a>로 5월 23일 25,090.72 TON을 수령했습니다. 축하합니다!</p>\n<p>토카막 네트워크의 스테이킹에 참여하시면</p>\n<ul>\n<li><a href="https://staking-simulator.tokamak.network/">45%의 APY</a></li>\n<li>Power TON 게임 참여</li>\n<li>비정기적 이벤트 참여 등 다양한 혜택을 받으실 수 있습니다.</li>\n</ul>\n<p><strong>1.2. Transaction</strong></p>\n<p>토카막 네트워크의 트랜잭션은 지난 2주간 1,329건이 발생했으며, 4월 25일-5월 8일 1,114건 대비 19.3% 증가를 기록했습니다.</p>\n<p><strong>1.3. DAO update</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/905/1*SiUctFl4ZKNRc3NxZuzgAA.png"></figure><p>DAO #3 아젠다의 찬성 투표 결과로 GIST(광주과학기술원)에 Zero Knowledge Virtual Machine 연구지원금이 14일에 전달 완료되었습니다.</p>\n<p><strong>1.4. Market Cap</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/792/1*990PhtCe5mWV6Nb-OGqZjw.png"></figure><p>토카막 네트워크는 5월 22일 <a href="https://www.coingecko.com/en/coins/tokamak-network/historical_data/usd#panel">코인게코</a> 기준, 시가총액 $367,627,243을 기록해 135위에 등재되었습니다. 2주간 최고 $16.68, 최저 $5.31이었으며, 거래량은 총 거래액은 지난 2주 $1,151,798,078 대비 $1,233,592,724으로 7.1% 증가했습니다. 유니스왑에서 지난 2주간 liquidity는 $4,259,619에서 $3,231,257로 24.14% 감소했으며, 총 거래량은 $3,552,097에서 $6,376,560으로 79.52% 증가했습니다. 현재 토카막 네트워크는 업비트, 업비트 인도네시아, <a href="https://v2.info.uniswap.org/pair/0x2a449a6076001080c833324bb7a3dcd017f15548">유니스왑</a>에서 거래가 가능합니다.</p>\n<h3>Technology Development</h3>\n<p><strong>2.1. Research</strong></p>\n<p>토카막 네트워크는 해당 기간동안 5건의 국문 리서치 자료 및 1건의 영문 리서치를 포스팅했습니다. 해당 포스팅은 토카막 네트워크의 개발사 온더의 블로그에서 확인이 가능합니다.</p>\n<p><strong>국문</strong></p>\n<blockquote><a href="https://medium.com/onther-tech/how-does-optimisms-rollup-really-work-249797c91336?source=collection_home---4------1-----------------------">How does Optimism’s Rollup really work?</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EB%B2%A0%EB%A5%BC%EB%A6%B0-%ED%95%98%EB%93%9C%ED%8F%AC%ED%81%AC-%EC%9D%B4%ED%9B%84-%ED%86%A0%EC%B9%B4%EB%A7%89-%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%82%B9-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B0%80%EC%8A%A4-%EC%B5%9C%EC%A0%81%ED%99%94-f87aedc7cc8c?source=collection_category---4------3-----------------------">베를린 하드포크 이후 토카막 스테이킹 시스템의 가스 최적화</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">옵티미스틱 롤업 사용하기</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">옵티미스틱 롤업에서 ERC20 사용하기</a></blockquote>\n<blockquote><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d">옵티미스틱 롤업에서 ERC721 사용하기</a></blockquote>\n<p><strong>영문</strong></p>\n<blockquote><a href="https://medium.com/onther-tech/optimistic-rollup-is-not-secure-enough-than-you-think-cb23e6e6f11c?source=collection_home---4------0-----------------------">Optimistic Rollup is Not Secure Enough Than You Think</a></blockquote>\n<p><strong>2.2. Tech Development</strong></p>\n<p>토카막 네트워크는 온디맨드 레이어 2 플랫폼으로 다양한 레이어 2 프로토콜을 제공하고자 노력하고 있습니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*sc0pjzgxiQUMTP-P.jpeg"></figure><ul><li>\n<a href="https://www.facebook.com/atomrigsC/?__cft__%5B0%5D=AZWZuTzEnlKXPTa5UQrQOcgnEtSE46nTqPR8VkD_pRngEX2ryfCLTIBfwfezW8k6RQlR_oTncKaSwMdhtoWfkna4ySo1Cl0W1AT6fiJAuVf0WLkt7kao0nrgdSM8_epdLAuvOKtS0cqr7a87Oe8LXYQDY7uXHZZ05GJpanmUjf2NKptefZ4zBL2HPHeFZYzo_W8&amp;__tn__=kK-R">Atomrigs Lab, Inc</a> 과 협업으로 오는 6월 탈중앙화된 ‘론치패드’(가칭)를 공개할 예정입니다. 디파이 플랫폼의 특징을 차용한 탈중앙화된 론치패드의 특징은 다음과 같습니다.</li></ul>\n<p>1) 탈중앙화</p>\n<p>2) 스마트 콘트렉트를 통한 자산 보관</p>\n<p>3) 신속하고 간편한 접근성</p>\n<p>4) 오픈 소스 &amp; 검증된 오딧</p>\n<p>5) 투명한 거버넌스</p>\n<p>6) 신속하고 간편한 프로젝트 론칭</p>\n<p>아울러 토카막 네트워크의 생태계 토큰인 ‘TON’은 이번에 공개할 탈중앙화 론치패드에서 다방면으로 활용될 예정입니다.</p>\n<ul>\n<li>개발생산성이 높은 파이썬으로 구현된 py-evm을 py-ovm으로 변경 및 업그레이드 작업을 시작했습니다. py-ovm은 PoC나 개발자들간 커뮤니케이션을 위한 용도로 사용될 예정입니다.</li>\n<li>토카막 네트워크는 현재 Optimism 롤업을 토카막 네트워크에 적용하기 위한 리서치와 기술을 개발 중입니다. 이와 관련된 리서치 자료는 온더 블로그에 함께 지속적으로 포스팅 중입니다.</li>\n<li>토카막 네트워크의 GitHub 에서는 지난 2주간 4개의 레포지토리에서 38개의 커밋이 발생했습니다. 자세한 개발 진행 상황은 <a href="https://github.com/Onther-Tech?page=1">Onther Inc. Technology · GitHub</a>에서 확인이 가능합니다.</li>\n</ul>\n<h3>Community</h3>\n<p><strong>3.1. News</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/600/1*dxlo3nK60IX3vl8AudZgfA.png"></figure><ul><li>오는 25일 화요일, 블록체인법학회, 서울이더리움밋업, 코인데스크코리아가 공동주최하고, 팍스넷뉴스가 후원하는 온라인 웨비나 <a href="https://www.meetup.com/Seoul-Ethereum-Meetup/events/278318594">‘DeFi Beyond Hype’</a>에 토카막 네트워크 연구원 Aiden은 ‘Cross chain AMM and Layer 2’라는 주제의 발표를 진행할 예정입니다.</li></ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/917/1*fIXqgWE2MobnIzGzQnbKNg.png"></figure><ul><li>토카막 네트워크의 블록체인 개발자 Darren은 5월 26일, CONSENSYS가 후원하는 <a href="https://www.meetup.com/ko-KR/Jeju-Blockchain-Meetup/events/278374882/">제주 블록체인 개발자 모임</a>에서 옵티미스틱 롤업에 대한 설명과 데모를 강연할 계획입니다.</li></ul>\n<p><strong>3.2. Marketing</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/560/0*LWFHwIT34ptxYPDJ"></figure><p>토카막 네트워크가 지난 4월부터 진행한 <a href="https://medium.com/onther-tech/tokamak-network-dao-beta-launch-celebration-nft-giveaway-b749e54a55d9">NFT 이벤트</a>의 5번째 지급과 함께 2, 3번 이벤트가 5월 13일 종료되었습니다. 해당 NFT는 토카막 네트워크의 건전한 생태계 발전에 기여하신 분께 제공하는 징표이며, 향후 다양한 토카막 네트워크 생태계 활동에 활용될 예정입니다.</p>\n<p><strong>3.3. Community</strong></p>\n<p>현재 토카막 네트워크는 다양한 커뮤니티를 운영 중에 있습니다. 토카막 네트워크의 공식 커뮤니티 채널은 다음과 같습니다.</p>\n<ul>\n<li>Telegram: <a href="https://t.me/tokamak_network">https://t.me/tokamak_network</a>\n</li>\n<li>Discord: <a href="https://discord.gg/SZw2WSR">https://discord.gg/SZw2WSR</a>\n</li>\n<li>Twitter: <a href="https://twitter.com/tokamak_network">https://twitter.com/tokamak_network</a>\n</li>\n<li>Medium: <a href="https://medium.com/onther-tech">https://medium.com/onther-tech</a>\n</li>\n</ul>\n<p><strong>3.4. New Member</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/607/1*qOX2lIZoo5sh5Uk6JH25Kg.png"></figure><p>토카막 네트워크의 새로운 멤버를 소개합니다. 프론트앤드 엔지니어로 토카막 네트워크에 합류한 <strong>Onuwa Nnachi Isaac</strong>은 탈중앙화된 경제에 대한 열정을 가진 오픈소스 엔지니어입니다. DAPP의 설계, 구현 및 유지 관리의 커리어를 가지고, Ethereum, Status, Gitcoin, Livepeer, Gitcoin 등 다양한 블록체인 프로젝트에 기여했습니다.</p>\n<p><strong>3.5. Job offer</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*37AFZ8lyoXgebD0O"></figure><p>토카막 네트워크의 개발사 온더는 블록체인 기술 관련 채용을 진행 중입니다. Layer2(plasma/rollup), client developerMathematician / ZKP Researcher, Smart Contract Developer, Blockchain Researcher, Economist(Governance), Web UI/UX Designer 등 다양한 직군에서 모집을 진행하오니 자세한 내용은 <a href="https://medium.com/onther-tech/job-openings-blockchain-tech-902098537088">온더 블로그</a>를 참고 부탁드립니다.</p>\n<p><strong>주의: </strong>최근 온더와 토카막 네트워크를 사칭하는 계정의 댓글 및 개인 메시지가 있습니다.</p>\n<p>온더와 토카막 네트워크는 어떤 경우에도 댓글, 개인 메시지 등을 통한 입금 유도 및 개인키 요구 등을 하지 않습니다.</p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d9355600226b" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/tokamak-network-biweekly-report-3-en-kr-d9355600226b">Tokamak Network Biweekly Report #3 [EN/KR]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                enclosure: {},
                categories: [
                  "ethereum",
                  "blockchain",
                  "report",
                  "weekly",
                  "tokamak-network",
                ],
              },
              {
                title:
                  "TON is officially supported in Samsung Blockchain Wallet [EN/KR]",
                pubDate: "2021-05-26 07:03:31",
                link:
                  "https://medium.com/onther-tech/ton-is-officially-supported-in-samsung-blockchain-wallet-en-kr-36128ab6f103?source=rss----eb8117f0bafd---4",
                guid: "https://medium.com/p/36128ab6f103",
                author: "Onther",
                thumbnail:
                  "https://cdn-images-1.medium.com/max/1024/0*nTxbXTDf53xdfgPt",
                description:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*nTxbXTDf53xdfgPt"></figure><p>Hello!</p>\n<p>This is On-demand Ethereum Layer 2 platform, Tokamak Network.</p>\n<p>Samsung Blockchain Wallet officially supports Tokamak Staking Service and TON, the ecosystem token of Tokamak Network.</p>\n<h3><strong>What is the Samsung Blockchain Wallet?</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*7IAGozW8LmXviYo3"></figure><p>Samsung Blockchain Wallet is a virtual asset wallet that allows you to easily and safely manage virtual assets based on the Trusted Execution Environment (TEE) and the robust security technology of Samsung Knox. It also features a variety of blockchain-based content such as finance and games using DApps.</p>\n<h3><strong>What does it support?</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/671/0*8hP2fVeKJn07d20L"></figure><p>Users will be able to proceed with deposit, withdrawal, and storage of TON on mobile through Samsung Blockchain Wallet. Handy staking feature will be also supported through the Simple Staking application registered in the DApps tab.</p>\n<h3><strong>About Tokamak Network Staking &amp; Simple Staking App</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/664/0*C7Bl9Ce5H1FfS1yk"></figure><p>Tokamak Network’s staking is currently operated by delegating to four operators, Tokamak Network Foundation, Level 19, DSRV, and Talken. A total of 11 million TON, which accounts for 53% of the distribution volume from the official launch in September 2020 to the present, are staked, and you can receive about 45% annual rewards. In addition, the support of Tokamak Network Simple Staking application by Samsung Blockchain Wallet adopts a UX that reflects the characteristics of mobile and users participating in staking, so you can experience staking more easily and conveniently.</p>\n<p>We are very pleased to introduce the Tokamak Staking app to be supported in the Samsung Blockchain Wallet which has been verified for its stability.</p>\n<p>We also expect more users to join the community of Tokamak Network through mobile support, which in the process will increase the level of trust in the Layer 2 network.</p>\n<p>We are deeply grateful to everyone who participates in the Tokamak Network ecosystem.</p>\n<p>안녕하세요!</p>\n<p>온디맨드 이더리움 레이어 2 플랫폼 ‘토카막 네트워크’입니다.</p>\n<p>삼성 블록체인 월렛(Samsung Blockchain Wallet)에서 토카막 네트워크의 생태계 토큰인 ‘TON’과 스테이킹 서비스를 공식 지원하게 되었습니다.</p>\n<h3><strong>What is the Samsung Blockchain Wallet?</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*RZhkjdjmYEBhlhc5"></figure><p>Samsung Blockchain Wallet은 Trusted Execution Environment(TEE)와 Samsung Knox의 강력한 보안 기술을 바탕으로 가상자산을 간편하고, 안전하게 관리할 수 있는 가상자산 지갑입니다. 또 DApp을 활용해 금융, 게임 등 블록체인 기반의 다양한 콘텐츠를 즐길 수 있는 것이 특징입니다.</p>\n<p><strong>What does it support?</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/671/0*xtS3oNlzU3-QaZqB"></figure><p>앞으로 사용자는 삼성 블록체인 월렛을 통해 자유롭게 모바일로 TON의 입출금 및 보관, DApps 탭에 등록된 심플 스테이킹 애플리케이션을 통해 간편하게 스테이킹을 진행할 수 있습니다.</p>\n<h3><strong>About Tokamak Network Staking &amp; Simple Staking App</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/664/0*duix-esJAFjId4XF"></figure><p>토카막 네트워크의 스테이킹은 현재 토카막 네트워크 재단, Level 19, DSRV, Talken 총 4개의 오퍼레이터에게 위임하여 운영하는 구조로 운영되고 있습니다. 2020년 9월 정식 출시 이후부터 현재까지 유통량의 53%에 달하는 총 1천1백만 여 TON이 스테이킹되어 있으며 약 연 45%의 리워드를 받을 수 있습니다. 아울러 이번에 삼성 블록체인 월렛에서 지원하는 토카막 네트워크 심플 스테이킹 애플리케이션은 모바일의 특성 및 스테이킹에 참여하는 사용자 행태를 반영한 UX를 채택해 더욱 쉽고 간편하게 스테이킹을 경험할 수 있습니다.</p>\n<p>저희는 안정성이 검증된 삼성 블록체인월렛에 토카막 스테이킹 앱이 탑재되고, 이를 소개할 수 있어 매우 기쁘게 생각합니다.</p>\n<p>또한 모바일 지원을 통해 더욱 많은 사용자가 토카막 네트워크의 커뮤니티에 참여하고, 이 과정에서 레이어 2 네트워크의 신뢰 수준이 높아질 것으로 기대합니다.</p>\n<p>토카막 네트워크 생태계에 참여해주시는 모든 분들께 깊은 감사드립니다.</p>\n<h3>* Tokamak Official Channels</h3>\n<p>📌Tokamak Global Telegram: <a href="https://t.me/tokamak_network">https://t.me/tokamak_network</a><br>📌Tokamak Global Discord: <a href="https://discord.gg/WjwRezbJY8">https://discord.gg/WjwRezbJY8</a><br>📌Tokamak Network Homepage: <a href="https://tokamak.network/#/">https://tokamak.network/#/</a><br>📌Tokamak Network Twitter: <a href="https://twitter.com/tokamak_network">https://twitter.com/tokamak_network</a><br>📌Tokamak Network Medium: <a href="https://medium.com/onther-tech">https://medium.com/onther-tech</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=36128ab6f103" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/ton-is-officially-supported-in-samsung-blockchain-wallet-en-kr-36128ab6f103">TON is officially supported in Samsung Blockchain Wallet [EN/KR]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                content:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*nTxbXTDf53xdfgPt"></figure><p>Hello!</p>\n<p>This is On-demand Ethereum Layer 2 platform, Tokamak Network.</p>\n<p>Samsung Blockchain Wallet officially supports Tokamak Staking Service and TON, the ecosystem token of Tokamak Network.</p>\n<h3><strong>What is the Samsung Blockchain Wallet?</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*7IAGozW8LmXviYo3"></figure><p>Samsung Blockchain Wallet is a virtual asset wallet that allows you to easily and safely manage virtual assets based on the Trusted Execution Environment (TEE) and the robust security technology of Samsung Knox. It also features a variety of blockchain-based content such as finance and games using DApps.</p>\n<h3><strong>What does it support?</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/671/0*8hP2fVeKJn07d20L"></figure><p>Users will be able to proceed with deposit, withdrawal, and storage of TON on mobile through Samsung Blockchain Wallet. Handy staking feature will be also supported through the Simple Staking application registered in the DApps tab.</p>\n<h3><strong>About Tokamak Network Staking &amp; Simple Staking App</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/664/0*C7Bl9Ce5H1FfS1yk"></figure><p>Tokamak Network’s staking is currently operated by delegating to four operators, Tokamak Network Foundation, Level 19, DSRV, and Talken. A total of 11 million TON, which accounts for 53% of the distribution volume from the official launch in September 2020 to the present, are staked, and you can receive about 45% annual rewards. In addition, the support of Tokamak Network Simple Staking application by Samsung Blockchain Wallet adopts a UX that reflects the characteristics of mobile and users participating in staking, so you can experience staking more easily and conveniently.</p>\n<p>We are very pleased to introduce the Tokamak Staking app to be supported in the Samsung Blockchain Wallet which has been verified for its stability.</p>\n<p>We also expect more users to join the community of Tokamak Network through mobile support, which in the process will increase the level of trust in the Layer 2 network.</p>\n<p>We are deeply grateful to everyone who participates in the Tokamak Network ecosystem.</p>\n<p>안녕하세요!</p>\n<p>온디맨드 이더리움 레이어 2 플랫폼 ‘토카막 네트워크’입니다.</p>\n<p>삼성 블록체인 월렛(Samsung Blockchain Wallet)에서 토카막 네트워크의 생태계 토큰인 ‘TON’과 스테이킹 서비스를 공식 지원하게 되었습니다.</p>\n<h3><strong>What is the Samsung Blockchain Wallet?</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*RZhkjdjmYEBhlhc5"></figure><p>Samsung Blockchain Wallet은 Trusted Execution Environment(TEE)와 Samsung Knox의 강력한 보안 기술을 바탕으로 가상자산을 간편하고, 안전하게 관리할 수 있는 가상자산 지갑입니다. 또 DApp을 활용해 금융, 게임 등 블록체인 기반의 다양한 콘텐츠를 즐길 수 있는 것이 특징입니다.</p>\n<p><strong>What does it support?</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/671/0*xtS3oNlzU3-QaZqB"></figure><p>앞으로 사용자는 삼성 블록체인 월렛을 통해 자유롭게 모바일로 TON의 입출금 및 보관, DApps 탭에 등록된 심플 스테이킹 애플리케이션을 통해 간편하게 스테이킹을 진행할 수 있습니다.</p>\n<h3><strong>About Tokamak Network Staking &amp; Simple Staking App</strong></h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/664/0*duix-esJAFjId4XF"></figure><p>토카막 네트워크의 스테이킹은 현재 토카막 네트워크 재단, Level 19, DSRV, Talken 총 4개의 오퍼레이터에게 위임하여 운영하는 구조로 운영되고 있습니다. 2020년 9월 정식 출시 이후부터 현재까지 유통량의 53%에 달하는 총 1천1백만 여 TON이 스테이킹되어 있으며 약 연 45%의 리워드를 받을 수 있습니다. 아울러 이번에 삼성 블록체인 월렛에서 지원하는 토카막 네트워크 심플 스테이킹 애플리케이션은 모바일의 특성 및 스테이킹에 참여하는 사용자 행태를 반영한 UX를 채택해 더욱 쉽고 간편하게 스테이킹을 경험할 수 있습니다.</p>\n<p>저희는 안정성이 검증된 삼성 블록체인월렛에 토카막 스테이킹 앱이 탑재되고, 이를 소개할 수 있어 매우 기쁘게 생각합니다.</p>\n<p>또한 모바일 지원을 통해 더욱 많은 사용자가 토카막 네트워크의 커뮤니티에 참여하고, 이 과정에서 레이어 2 네트워크의 신뢰 수준이 높아질 것으로 기대합니다.</p>\n<p>토카막 네트워크 생태계에 참여해주시는 모든 분들께 깊은 감사드립니다.</p>\n<h3>* Tokamak Official Channels</h3>\n<p>📌Tokamak Global Telegram: <a href="https://t.me/tokamak_network">https://t.me/tokamak_network</a><br>📌Tokamak Global Discord: <a href="https://discord.gg/WjwRezbJY8">https://discord.gg/WjwRezbJY8</a><br>📌Tokamak Network Homepage: <a href="https://tokamak.network/#/">https://tokamak.network/#/</a><br>📌Tokamak Network Twitter: <a href="https://twitter.com/tokamak_network">https://twitter.com/tokamak_network</a><br>📌Tokamak Network Medium: <a href="https://medium.com/onther-tech">https://medium.com/onther-tech</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=36128ab6f103" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/ton-is-officially-supported-in-samsung-blockchain-wallet-en-kr-36128ab6f103">TON is officially supported in Samsung Blockchain Wallet [EN/KR]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                enclosure: {},
                categories: [
                  "samsung",
                  "tokamak-network",
                  "ethereum",
                  "wallet",
                  "blockchain",
                ],
              },
              {
                title: "Optimism Transaction[KR]",
                pubDate: "2021-05-26 06:51:16",
                link:
                  "https://medium.com/onther-tech/optimism-transaction-b5de4f1b82e1?source=rss----eb8117f0bafd---4",
                guid: "https://medium.com/p/b5de4f1b82e1",
                author: "신건우(Thomas Shin)",
                thumbnail:
                  "https://cdn-images-1.medium.com/max/1024/0*4whdERNDAqepsQI9.jpg",
                description:
                  '\n<h3>Optimism Transaction (sequencer transaction and queue transaction)[KR]</h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*4whdERNDAqepsQI9.jpg"><figcaption><a href="https://optimism.io/">https://optimism.io/</a></figcaption></figure><p>옵티미즘은 <a href="https://medium.com/onther-tech/almost-everything-you-need-to-know-about-optimistic-rollup-aa4eea74c2ad">옵티미스틱 롤업</a> 구현체다. 옵티미스틱 롤업은 레이어 2 솔루션으로 이더리움을 레이어 1 체인으로 사용한다. 이 글은 옵티미즘의 기본 개념을 이해하고 있는 독자를 대상으로, 옵티미즘 트랜잭션이 어떻게 처리되는지 살펴본다.</p>\n<blockquote>옵티미즘은 <a href="https://optimismpbc.medium.com/optimistically-cautious-767a898f90c8">7월에 출시될 예정</a>이며 토카막 네트워크 역시 옵티미스틱 롤업을 기반으로 한 레이어 2 서비스를 준비하고 있다. 옵티미스틱 롤업과 옵티미즘에 대한 글은 <a href="https://medium.com/onther-tech/almost-everything-you-need-to-know-about-optimistic-rollup-aa4eea74c2ad">여기1</a>, <a href="https://medium.com/onther-tech/how-does-optimisms-rollup-really-work-249797c91336">여기2</a>서 확인할 수 있다. (옵티미즘 코드는 모두 <a href="https://github.com/ethereum-optimism/optimism/tree/cc209be13ccefc9d0c376413c81cf39be04d8f05">cc209be</a> 커밋을 기준으로 한다.)</blockquote>\n<h3>이더리움 트랜잭션</h3>\n<p><strong>이더리움은 트랜잭션 기반의 상태 머신이다.</strong> 컴퓨터 과학에서 <a href="https://en.wikipedia.org/wiki/Finite-state_machine">상태 머신</a>이란 인풋을 읽고 현재 상태를 기반으로 새로운 상태로 변환하는 머신을 말한다. 이더리움 상태 머신은 제네시스 상태로 시작한다. 트랜잭션이 실행되면 최종 상태로 변환하는데, 이 최종 상태가 바로 이더리움의 현재 상태다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*n4FytzIRfkrW6cHP.png"><figcaption><a href="https://preethikasireddy.medium.com/how-does-ethereum-work-anyway-22d1df506369">https://preethikasireddy.medium.com/how-does-ethereum-work-anyway-22d1df506369</a></figcaption></figure><p>트랜잭션은 메시지 콜을 하거나 새로운 컨트랙트를 배포하기 위해 EOA(Externally owned account)가 서명한 데이터를 말한다. 트랜잭션은 이더리움 네트워크에서 처리되어 블록에 기록으로 남게 된다. 메시지 콜은 다른 어카운트에 메시지를 보내는 것을 말하는데, 여기서 메시지는 어카운트 간의 전송되는 데이터를 말한다.</p>\n<p>이더리움 클라이언트는 메시지 콜을 하는 트랜잭션을 받으면 이를 <a href="https://github.com/ethereum/go-ethereum/blob/3e795881ea6d68c32da5da3c95f0d458a64e35c3/core/types/transaction.go#L527">메시지로 변환</a>한다. 이 메시지는 <a href="https://github.com/ethereum/go-ethereum/blob/3e795881ea6d68c32da5da3c95f0d458a64e35c3/core/state_transition.go#L177">현재 상태를 기반으로 실행</a>되어 새로운 상태를 만든다.</p>\n<h3>옵티미즘 트랜잭션</h3>\n<p>유저는 옵티미즘에서 3가지 종류의 트랜잭션을 만들 수 있다.</p>\n<ol>\n<li>레이어 2 트랜잭션</li>\n<li>레이어 1 ⇒ 레이어 2 트랜잭션</li>\n<li>레이어 2 ⇒ 레이어 1 트랜잭션</li>\n</ol>\n<blockquote>이 글에서는 레이어 2 트랜잭션과 레이어 1 ⇒ 레이어 2 트랜잭션만을 다룬다. 레이어 2 ⇒ 레이어 1 트랜잭션은 이후에 작성될 Message Relayer를 설명하는 글에서 자세히 다룰 예정이다.</blockquote>\n<p>유저는 메시지 콜 또는 새로운 컨트랙트를 배포하기 위해 이더리움의 트랜잭션 포맷과 같은 레이어 2 트랜잭션을 시퀀서(현재 옵티미즘은 단일 시퀀서만을 지원한다.)에게 제출한다. 이렇게 시퀀서에게 직접 제출하는 레이어 2 트랜잭션을 <strong>시퀀서 트랜잭션(sequencer transaction)</strong>이라고 부른다.</p>\n<p>레이어 1 ⇒ 레이어 2 트랜잭션은 <strong>큐 트랜잭션(queue transaction)</strong>이라고 부른다. 큐 트랜잭션은 레이어 1에서 만들어져서 레이어 2에서 실행된다. 시퀀서 트랜잭션과 큐 트랜잭션이 옵티미즘에서 어떻게 만들어지고 실행되는지 하나씩 살펴보자.</p>\n<h4>시퀀서 트랜잭션</h4>\n<p>시퀀서 트랜잭션은 이더리움과 동일한 방식으로 만들어져서 시퀀서에게 전송된다. 시퀀서는 트랜잭션을 전달받으면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/internal/ethapi/api.go#L1775">메타 정보를 새로 만드는데</a>, 메타 정보는 실행 환경에 필요한 컨텍스트 정보라고 할 수 있다. 시퀀서는 메타 정보를 만들고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/internal/ethapi/api.go#L1776">이를 트랜잭션에 추가</a>한다.</p>\n<pre>type TransactionMeta struct {<br>   L1BlockNumber     *big.Int<br>   L1Timestamp       uint64<br>   SignatureHashType SignatureHashType<br>   QueueOrigin       *big.Int<br>   Index             *uint64<br>   QueueIndex        *uint64<br><strong>   </strong>RawTransaction    []byte<strong><br></strong>}</pre>\n<ul>\n<li>L1BlockNumber: 레이어 1 컨텍스트의 블록 넘버 값이다. 시퀀서 트랜잭션은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/sync_service.go#L741">레이어 2 컨텍스트의 블록 넘버 값</a>을 사용한다.</li>\n<li>L1Timestamp: 레이어 1 컨텍스트의 타임스탬프 값이다. 시퀀서 트랜잭션은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/sync_service.go#L740">레이어 2 컨텍스트의 타임스탬프 값</a>을 사용한다.</li>\n<li>\n<a href="https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-types.md">SignatureHashType</a>: 트랜잭션의 인코딩 포맷에 따라 SighashEIP155 = 0, SighashEthSign = 1 그리고 CreateEOA = 2 값중 하나를 가진다.</li>\n<li>QueueOrigin: QueueOriginSequencer = 0 과 QueueOriginL1ToL2 = 1 값으로 옵티미즘 트랜잭션 타입을 구분한다. QueueOriginSequencer 는 시퀀서 트랜잭션 타입이고, QueueOriginL1ToL2 는 큐 트랜잭션 타입이다.</li>\n<li>Index: 레이어 2 체인의 블록 넘버다(옵티미즘의 블록은 트랜잭션 하나만 담는다). 큐 트랜잭션은 이 값을 가지지 않는다.</li>\n<li>QueueIndex: queue에 쌓인 큐 트랜잭션의 인덱스 값을 가진다. 시퀀서 트랜잭션은 이 값을 가지지 않는다.</li>\n<li>RawTransaction: <a href="https://github.com/ethereum-optimism/optimism/blob/develop/l2geth/ethclient/ethclient.go#L513">트랜잭션 데이터를 RLP 인코딩한 값</a>이 들어간다.</li>\n</ul>\n<p>유저가 시퀀서에게 트랜잭션을 보내면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/ethclient/ethclient.go#L512">SendTransaction 함수</a>가 호출된다. SendTransaction 함수는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/ethclient/ethclient.go#L513">트랜잭션 데이터를 RLP 인코딩</a>하고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/ethclient/ethclient.go#L517">SendRawTransaction 함수를 호출</a>한다. <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/internal/ethapi/api.go#L1761">SendRawTransaction 함수</a>는 위와 같이 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/internal/ethapi/api.go#L1775-L1776">메타 정보를 생성</a>하면서 RawTransaction 필드값에 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/ethclient/ethclient.go#L513">트랜잭션 데이터를 RLP 인코딩한 값</a>을 넣는다.</p>\n<p>옵티미즘의 트랜잭션을 실행하기 위해서는 이더리움과 마찬가지로 트랜잭션을 메시지로 변환해야 한다. 옵티미즘은 이를 위해 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_processor.go#L93">AsOvmMessage 함수를 호출</a>한다. 옵티미즘의 메시지는 다음과 같이 구성되어 있다.</p>\n<pre>type Message interface {<br>   From() common.Address<br>   To() *common.Address<br>   GasPrice() *big.Int<br>   Gas() uint64<br>   Value() *big.Int<br>   Nonce() uint64<br>   CheckNonce() bool<br>   Data() []byte<br>   L1MessageSender() *common.Address<br>   L1BlockNumber() *big.Int<br>   QueueOrigin() *big.Int<br>   SignatureHashType() types.SignatureHashType<br>}</pre>\n<p>AsOvmMessage 함수는 메시지의 데이터를 다음과 같이 수정한다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MPSdpszxyicrZTizxt-znA.png"></figure><ol>\n<li>메시지의 to 필드의 값을 OVM_SequencerEntrypoint 컨트랙트 주소로 변경한다.</li>\n<li>메시지의 data 필드의 값을 트랜잭션 메타 정보의 RawTransaction 값으로 변경한다.</li>\n</ol>\n<p>옵티미즘은 이렇게 수정된 OVM 메시지를 실행하기 전에 OVM 메시지를 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition.go#L213">한번 더 수정</a>한다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VvAzrPykccsdMmLO9wiYjw.png"></figure><ol>\n<li>메시지의 to 필드의 값을 OVM_ExecutionManager 컨트랙트 주소로 변경한다.</li>\n<li>메시지의 data 필드의 값을 OVM_ExecutionManager 컨트랙트의 run 함수를 호출하는 바이트코드로 변경한다. run 함수의 인자값은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L26-L34">수정된 OVM 메시지를 기반으로 OVM 트랜잭션를 만들어 이를 인코딩한 값</a>과 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L39">OVM_StateManager 컨트랙트의 주소</a>가 된다.</li>\n</ol>\n<p>OVM 트랜잭션은 아래와 같이 구성되어 있다. 시퀀서 트랜잭션의 entrypoint 필드값은 항상 SequencerEntrypoint 컨트랙트의 주소가 된다.</p>\n<pre>struct Transaction {<br>    uint256 timestamp;<br>    uint256 blockNumber;<br>    QueueOrigin l1QueueOrigin;<br>    address l1TxOrigin;<br>    address entrypoint;<br>    uint256 gasLimit;<br>    bytes data;<br>}</pre>\n<p>최종적으로, 옵티미즘은 위와 같이 수정된 OVM 메시지를 현재 옵티미즘 상태를 기반으로 실행하여 새로운 상태를 만들어 낸다. 이제 이렇게 수정된 메시지를 시퀀서가 어떻게 실행하는지 살펴보자.</p>\n<h4>시퀀서 트랜잭션 실행</h4>\n<p>수정된 OVM 메시지는 결국 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L159">ExecutionManager 컨트랙트의 run 함수</a>를 호출하게 된다. run 함수의 인자값은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L26-L34">인코딩된 트랜잭션 데이터</a>와 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L39">StateManager 컨트랙트의 주소</a>다.</p>\n<p>OVM에서 트랜잭션의 실행은 모두 ExecutionManager 컨트랙트의 run 함수로부터 시작한다. 그 이유는 OVM의 샌드박스된 환경에서 트랜잭션이 실행되어야 하기 때문이다(이에 대한 자세한 내용은 이전에 작성한 <a href="https://medium.com/onther-tech/how-does-optimisms-rollup-really-work-249797c91336?source=your_stories_page-------------------------------------">옵티미즘 글</a>에서 확인할 수 있다.). run 함수는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L207-L212">ovmCALL 함수</a>를 호출하고 최종적으로 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L947">_handleExternalMessage 함수</a>를 호출한다. _handleExternalMessage 함수는 (success, returndata) = _contract.call{gas: _gasLimit}(_data) 함수를 호출하는데, 여기서 <strong>_contract는 SequencerEntrypoint 컨트랙트 주소고, </strong><strong>_data는 유저가 전송한 트랜잭션을 RLP 인코딩한 데이터다.</strong> 결국 이 코드는 SequencerEntrypoint 컨트랙트에 메시지 콜을 하게 된다.</p>\n<pre>function run(<br>    Lib_OVMCodec.Transaction memory _transaction,<br>    address _ovmStateManager<br>)</pre>\n<p><a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol">OVM_SequencerEntrypoint 컨트랙트</a>에는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L35">fallback 함수</a>만 존재한다. <strong>따라서 ExecutionManager 컨트랙트의 run 함수는 결국 SequencerEntrypoint 컨트랙트의 fallback 함수를 호출하게 된다.</strong></p>\n<p>fallback 함수는 우선 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L41-L45">인코딩된 트랜잭션 데이터를 디코딩</a>한다. 디코딩된 트랜잭션 데이터는 아래와 같다.</p>\n<pre>struct EIP155Tx {<br>    uint256 nonce;<br>    uint256 gasPrice;<br>    uint256 gasLimit;<br>    address to;<br>    uint256 value;<br>    bytes data;<br>    uint8 v;<br>    bytes32 r;<br>    bytes32 s;<br>    uint256 chainId;<br>    uint8 recoveryParam;<br>    bool isCreate;       <br>}</pre>\n<p>이후 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/libraries/codec/Lib_EIP155Tx.sol#L187">디코딩된 트랜잭션의 서명값(v, r, s)을 이용해서 트랜잭션을 보낸 어카운트의 주소를 구한다</a>. 어카운트 주소를 구하면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L50-L53">해당 주소로 배포된 EOA 컨트랙트가 존재하는지 확인</a>(확인하기 위해서 어카운트의 codesize를 확인한다.)한다. 만약 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L55-L63">EOA 컨트랙트가 존재하지 않으면 EOA 컨트랙트를 새로 배포</a>한다. 마지막으로 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L65-L71">EOA 컨트랙트의 </a><a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L65-L71">execute(bytes) 함수를 호출</a>하는 메시지 콜을 하게 된다.</p>\n<p>여기에 EOA 컨트랙트라는 낯선 용어가 나타난다. 이를 이해하기 위해서는 옵티미즘이 어카운트와 상태를 어떻게 처리하는지 알아야 한다.</p>\n<p>우선 옵티미즘의 모든 어카운트는 컨트랙트 어카운트다. 즉, 옵티미즘에는 EOA가 존재하지 않는다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MGiIZDQO-bEe4wMeK27G7A.png"></figure><p>이를 실현하기 위해 옵티미즘은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol">OVM_ECDSAContractAccount 컨트랙트</a>를 만들었다. 따라서 옵티미즘의 EOA는 모두 ECDSAContractAccount 컨트랙트이고, 이를 EOA 컨트랙트라고 부른다. <strong>이 컨트랙트에는 execute 함수가 존재하는데, 이 함수는 이더리움의 EOA와 동일한 방식으로 동작한다.</strong> 이 함수가 호출되면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L76-L79">트랜잭션의 서명값을 통해 어카운트 주소</a>를 확인하고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L81-L85">nonce 값도 확인</a>한다. 그후 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L94-L101">수수료를 지불</a>한 뒤 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L124">nonce를 1 증가</a>시키고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L143">유저가 생성한 트랜잭션을 호출</a>한다.</p>\n<p>그리고 옵티미즘의 모든 어카운트의 상태는 StateManager 컨트랙트에 의해 관리된다. 예를 들어, EOA 컨트랙트가 존재하는지 확인하고, <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1256">EOA 컨트랙트를 새로 배포</a>하고, <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1204">어카운트의 nonce를 확인</a>하고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1187">nonce를 1 증가</a>시키는 것 모두 StateManager 컨트랙트가 관여한다.</p>\n<p>최종적으로, ExecutionManager 컨트랙트의 run 함수를 시발점으로 유저가 생성한 트랜잭션이 OVM의 샌드박스된 환경에서 실행되고, 변경된 어카운트와 스토리지는 모두 StateManager 컨트랙트에서 처리된다.</p>\n<h4>큐 트랜잭션</h4>\n<p>큐 트랜잭션은 레이어 1에서 만들어진 레이어 2 트랜잭션이다. 큐 트랜잭션을 만드는 이유는 시퀀서가 특정 유저를 검열(레이어 2에서 검열을 받는 유저는 레이어 1에서 트랜잭션을 만들어 검열을 회피할 수 있다.)하거나 레이어 1에서 레이어 2로 자산을 옮기기 위해서다.</p>\n<p>큐 트랜잭션을 만들기 위해서는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L257">CanonicalTransactionChain 컨트랙트의 </a><a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L257">enqueue 함수</a>를 호출한다. 큐 트랜잭션이 만들어지면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L105">queue 자료 구조</a>에 쌓이게 되고, 큐 트랜잭션은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L323">큐 인덱스</a>를 갖게 된다. enqueue 함수는 다음과 같다.</p>\n<pre>function enqueue(<br>    address target,<br>    uint256 gasLimit,<br>    bytes memory data<br>)</pre>\n<ul>\n<li>target: 트랜잭션을 보낼 레이어 2 컨트랙트 주소다.</li>\n<li>gasLimit: 레이어 2에서 큐 트랜잭션이 사용하게 될 gasLimit이다. <a href="https://community.optimism.io/docs/users/fees-in-optimistic-ethereum.html#%F0%9F%92%B5-1-transacting-on-l2">실제로 옵티미즘은 gasLimit만큼 가스를 모두 소모한다.</a>\n</li>\n<li>data: 메시지 콜을 하기 위한 데이터다. e.g. abi.encodeWithSignature(“send(address)”, receiver)</li>\n</ul>\n<p>enqueue 함수는 중간에 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L293-L298">일정 가스를 소모하는 행위</a>를 한다(실제로 gasLimit / 32만큼 가스를 소모한다.). 이렇게 하는 이유는 큐 트랜잭션은 레이어 2에서 gasPrice가 0이기 때문에 <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">도스 공격</a>을 막기 위함이다. 즉, 일정 가스를 소모하게 만들어서 레이어 1에서 레이어 2에 부담이 될 수 있는 큐 트랜잭션을 무자비하게 만드는 것을 막는다.</p>\n<p>마지막으로 enqueue 함수가 성공적으로 실행되면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L324-L331">TransactionEnqueued 이벤트가 발생</a>한다.</p>\n<pre>event TransactionEnqueued(<br>    address l1TxOrigin,<br>    address target,<br>    uint256 gasLimit,<br>    bytes data,<br>    uint256 queueIndex,<br>    uint256 timestamp<br>);</pre>\n<ul>\n<li>l1TxOrigin: enqueue 함수를 호출하는 트랜잭션을 보낸 어카운트 주소다.</li>\n<li>target: enqueue 함수의 target 인자값과 같다.</li>\n<li>gasLimit: enqueue 함수의 gasLimit 인자값과 같다.</li>\n<li>data: enqueue 함수의 data 인자값과 같다.</li>\n<li>queueIndex: 큐 트랜잭션의 인덱스 값이다.</li>\n<li>timestamp: enqueue 함수가 실행되는 시점의 타임스탬프 값이다.</li>\n</ul>\n<p>TransactionEnqueued 이벤트의 인자값들은 큐 트랜잭션을 레이어 2에서 실행하기 위해 필요한 모든 정보를 담고 있다.</p>\n<h4>dtl (data transport layer)</h4>\n<p><strong>시퀀서가 큐 트랜잭션을 레이어 2에서 실행하기 위해서는 반드시 </strong><a href="https://github.com/ethereum-optimism/optimism/tree/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/data-transport-layer"><strong>data transport layer</strong></a><strong>라는 프로그램을 돌려야 한다.</strong> dtl에는 두가지 서비스가 동작한다.</p>\n<ol>\n<li>\n<a href="https://github.com/ethereum-optimism/optimism/tree/develop/specs/l2geth"><strong>Transaction Ingestor</strong></a>: CanonicalTransactionChain 컨트랙트에서 발생한 TransactionEnqueued (리스닝) <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/data-transport-layer/src/services/l1-ingestion/handlers/transaction-enqueued.ts#L15-L26">이벤트 데이터를 파싱</a>하고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/data-transport-layer/src/services/l1-ingestion/handlers/transaction-enqueued.ts#L27-L29">파싱된 데이터를 데이터베이스에 저장</a>한다.</li>\n<li>\n<a href="https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-indexer.md"><strong>Transaction Indexer</strong></a>: 데이터베이스에 저장된 데이터에 접근할 수 있도록 API 서버를 제공한다. 결국 이 데이터베이스는 이벤트 데이터 정보를 저장하게 된다.</li>\n</ol>\n<p>저장된 이벤트 데이터 정보는 API 서버로부터 다음과 같이 가져올 수 있다.</p>\n<p><strong>요청:</strong></p>\n<pre>GET /enqueue/index/{index: number}</pre>\n<p><strong>응답:</strong></p>\n<pre>{<br>  "index": number,<br>  "target": string,<br>  "data": string,<br>  "gasLimit": number,<br>  "origin": string,<br>  "blockNumber": number,<br>  "timestamp": number<br>}</pre>\n<p>dtl의 API 서버가 제공하는 다른 API는 <a href="https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-indexer.md#l1-transaction-indexer-api">여기</a>서 확인할 수 있다.</p>\n<h4><strong>큐 트랜잭션 실행</strong></h4>\n<p>옵티미즘 클라이언트는 큐 트랜잭션을 실행하기 위해 dtl의 API 서버로부터 이벤트 데이터 정보를 가지고 와야 한다. 이를 위해 옵티미즘 클라이언트는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/eth/backend.go#L212">sync 서비스를 돌려</a> dtl과 동기화한다. 시퀀서는 dtl과 동기화하기 위해 <a href="https://github.com/ethereum-optimism/optimism/tree/develop/l2geth#running-a-sequencer">옵티미즘 클라이언트를 실행</a>할 때 --rollup.clienthttp 플래그 값을 반드시 넣어야 한다. 이 값은 바로 dtl의 API 서버 주소가 된다.</p>\n<pre>$ USING_OVM=true ./build/bin/geth \\<br><strong>--rollup.addrclienthttp</strong><br>    ...</pre>\n<p>시퀀서가 옵티미즘 클라이언트를 실행하면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/sync_service.go#L367">sequence 함수</a>가 호출된다. sequence 함수는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/client.go#L252-L271">dtl의 API 서버로부터 이벤트 데이터 정보를 가지고 온다</a>. 그런 다음 시퀀서는 가져온 이벤트 데이터 정보를 가지고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/client.go#L233">큐 트랜잭션을 만든다</a>. 큐 트랜잭션은 다음의 두가지 특징을 가진다.</p>\n<ol>\n<li>\n<a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/client.go#L202">큐 인덱스 값을 트랜잭션의 </a><a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/client.go#L202">nonce로 사용</a>한다.</li>\n<li>gasPrice는 항상 0이다. 그렇기 때문에 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L293-L298">enqueue 함수에서 일정량의 가스를 미리 소모</a>한다.</li>\n</ol>\n<p>그리고 위에서 언급했듯이, 옵티미즘 트랜잭션은 모두 메타 정보를 가진다. <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/client.go#L196-L246">큐 트랜잭션의 메타 정보</a>는 다음과 같다.</p>\n<ul>\n<li>L1BlockNumber: enqueue 함수가 호출된 시점의 블록 넘버 값이다. 즉, 이벤트 데이터 정보의 블록 넘버 값이다.</li>\n<li>L1Timestamp: enqueue 함수가 호출된 시점의 타임스탬프 값이다. 즉, 이벤트 데이터 정보의 타임스탬프 값이다.</li>\n<li>\n<a href="https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-types.md">SignatureHashType</a>: 트랜잭션 데이터를 인코딩했기 때문에 SighashEIP155 = 0 값을 가진다.</li>\n<li>QueueOrigin: 큐 트랜잭션이기 때문에 QueueOriginL1ToL2 값을 가진다.</li>\n<li>Index: <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/data-transport-layer/src/services/l1-ingestion/handlers/transaction-enqueued.ts#L24">큐 트랜잭션은 이 값을 가지지 않는다</a>. <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/miner/worker.go#L890-L894">하지만 실제로 실행될 때 부모 블록의 블록 넘버를 넣는다</a>.</li>\n<li>QueueIndex: 큐 트랜잭션의 인덱스 값이다.</li>\n<li>RawTransaction: 메시지 콜을 하기 위한 데이터 값이다.</li>\n</ul>\n<p>이제 시퀀서는 이러한 큐 트랜잭션을 실행한다. 큐 트랜잭션도 시퀀서 트랜잭션과 마찬가지로 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L61">AsOvmMessage 함수를 호출</a>해서 OVM 메시지로 변환한다. 하지만 큐 트랜잭션은 시퀀서 트랜잭션처럼 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L72-L79">메시지의 to 필드값을 SequencerEntrypoint 컨트랙트 주소로, data 필드값을 트랜잭션 메타 정보의 RawTransaction으로 변경하지 않는다</a>.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*F8QcTU9CdPU--iCqONl7cg.png"></figure><p>다만, 이 메시지가 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L25">ExecutionManager 컨트랙트의 run 함수에서 시작하도록 메시지를 수정</a>한다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jx8YDSDbzVsImIf_eVV-1g.png"></figure><p>이렇게 수정된 메시지는 시퀀서 트랜잭션과 마찬가지로 현재 상태를 기반으로 실행되어 새로운 상태를 만든다. 시퀀서 트랜잭션과 큐 트랜잭션의 차이점은 시퀀서 트랜잭션은 항상 SequencerEntrypoint 컨트랙트를 거치지만, 큐 트랜잭션은 target 주소에 바로 메시지 콜을 보낸다는 것이다.</p>\n<blockquote>실제로 큐 트랜잭션은 시퀀서가 특정 기간 내에 레이어 2에 반드시 반영해야 한다. 이를 위해 CanonicalTransactionChain 컨트랙트에는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L338">appendQueueBatch 함수</a>가 존재하지만, 현재는 사용할 수 없게 되어 있다. 이는 추후에 개발될 것으로 보이며, 개발이 완료되면 해당 내용을 이 글에 추가할 예정이다.</blockquote>\n<h3>Conclusion</h3>\n<p>이번 글에서는 옵티미즘에서 취급하는 두 종류의 트랜잭션인 시퀀서 트랜잭션과 큐 트랜잭션에 대해 알아보았다. 옵티미즘은 트랜잭션을 실행한 후에 트랜잭션과 상태값을 레이어 1에 제출해야 한다. 이를 위해서는 <a href="https://github.com/ethereum-optimism/optimism/tree/develop/packages/batch-submitter">batch submitter</a>라고 하는 프로그램이 필요한데, 다음 글에서는 batch submitter가 트랜잭션과 상태값을 레이어 1에 어떻게 제출하는지에 대해 알아보고자 한다.</p>\n<h3>Reference</h3>\n<ul>\n<li><a href="https://github.com/ethereum-optimism/optimism">https://github.com/ethereum-optimism/optimism</a></li>\n<li><a href="https://github.com/gakonst/optimism-tx-format">https://github.com/gakonst/optimism-tx-format</a></li>\n<li><a href="https://ethereum.stackexchange.com/questions/7358/what-is-the-difference-between-transaction-and-message">https://ethereum.stackexchange.com/questions/7358/what-is-the-difference-between-transaction-and-message</a></li>\n</ul>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b5de4f1b82e1" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/optimism-transaction-b5de4f1b82e1">Optimism Transaction[KR]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                content:
                  '\n<h3>Optimism Transaction (sequencer transaction and queue transaction)[KR]</h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*4whdERNDAqepsQI9.jpg"><figcaption><a href="https://optimism.io/">https://optimism.io/</a></figcaption></figure><p>옵티미즘은 <a href="https://medium.com/onther-tech/almost-everything-you-need-to-know-about-optimistic-rollup-aa4eea74c2ad">옵티미스틱 롤업</a> 구현체다. 옵티미스틱 롤업은 레이어 2 솔루션으로 이더리움을 레이어 1 체인으로 사용한다. 이 글은 옵티미즘의 기본 개념을 이해하고 있는 독자를 대상으로, 옵티미즘 트랜잭션이 어떻게 처리되는지 살펴본다.</p>\n<blockquote>옵티미즘은 <a href="https://optimismpbc.medium.com/optimistically-cautious-767a898f90c8">7월에 출시될 예정</a>이며 토카막 네트워크 역시 옵티미스틱 롤업을 기반으로 한 레이어 2 서비스를 준비하고 있다. 옵티미스틱 롤업과 옵티미즘에 대한 글은 <a href="https://medium.com/onther-tech/almost-everything-you-need-to-know-about-optimistic-rollup-aa4eea74c2ad">여기1</a>, <a href="https://medium.com/onther-tech/how-does-optimisms-rollup-really-work-249797c91336">여기2</a>서 확인할 수 있다. (옵티미즘 코드는 모두 <a href="https://github.com/ethereum-optimism/optimism/tree/cc209be13ccefc9d0c376413c81cf39be04d8f05">cc209be</a> 커밋을 기준으로 한다.)</blockquote>\n<h3>이더리움 트랜잭션</h3>\n<p><strong>이더리움은 트랜잭션 기반의 상태 머신이다.</strong> 컴퓨터 과학에서 <a href="https://en.wikipedia.org/wiki/Finite-state_machine">상태 머신</a>이란 인풋을 읽고 현재 상태를 기반으로 새로운 상태로 변환하는 머신을 말한다. 이더리움 상태 머신은 제네시스 상태로 시작한다. 트랜잭션이 실행되면 최종 상태로 변환하는데, 이 최종 상태가 바로 이더리움의 현재 상태다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*n4FytzIRfkrW6cHP.png"><figcaption><a href="https://preethikasireddy.medium.com/how-does-ethereum-work-anyway-22d1df506369">https://preethikasireddy.medium.com/how-does-ethereum-work-anyway-22d1df506369</a></figcaption></figure><p>트랜잭션은 메시지 콜을 하거나 새로운 컨트랙트를 배포하기 위해 EOA(Externally owned account)가 서명한 데이터를 말한다. 트랜잭션은 이더리움 네트워크에서 처리되어 블록에 기록으로 남게 된다. 메시지 콜은 다른 어카운트에 메시지를 보내는 것을 말하는데, 여기서 메시지는 어카운트 간의 전송되는 데이터를 말한다.</p>\n<p>이더리움 클라이언트는 메시지 콜을 하는 트랜잭션을 받으면 이를 <a href="https://github.com/ethereum/go-ethereum/blob/3e795881ea6d68c32da5da3c95f0d458a64e35c3/core/types/transaction.go#L527">메시지로 변환</a>한다. 이 메시지는 <a href="https://github.com/ethereum/go-ethereum/blob/3e795881ea6d68c32da5da3c95f0d458a64e35c3/core/state_transition.go#L177">현재 상태를 기반으로 실행</a>되어 새로운 상태를 만든다.</p>\n<h3>옵티미즘 트랜잭션</h3>\n<p>유저는 옵티미즘에서 3가지 종류의 트랜잭션을 만들 수 있다.</p>\n<ol>\n<li>레이어 2 트랜잭션</li>\n<li>레이어 1 ⇒ 레이어 2 트랜잭션</li>\n<li>레이어 2 ⇒ 레이어 1 트랜잭션</li>\n</ol>\n<blockquote>이 글에서는 레이어 2 트랜잭션과 레이어 1 ⇒ 레이어 2 트랜잭션만을 다룬다. 레이어 2 ⇒ 레이어 1 트랜잭션은 이후에 작성될 Message Relayer를 설명하는 글에서 자세히 다룰 예정이다.</blockquote>\n<p>유저는 메시지 콜 또는 새로운 컨트랙트를 배포하기 위해 이더리움의 트랜잭션 포맷과 같은 레이어 2 트랜잭션을 시퀀서(현재 옵티미즘은 단일 시퀀서만을 지원한다.)에게 제출한다. 이렇게 시퀀서에게 직접 제출하는 레이어 2 트랜잭션을 <strong>시퀀서 트랜잭션(sequencer transaction)</strong>이라고 부른다.</p>\n<p>레이어 1 ⇒ 레이어 2 트랜잭션은 <strong>큐 트랜잭션(queue transaction)</strong>이라고 부른다. 큐 트랜잭션은 레이어 1에서 만들어져서 레이어 2에서 실행된다. 시퀀서 트랜잭션과 큐 트랜잭션이 옵티미즘에서 어떻게 만들어지고 실행되는지 하나씩 살펴보자.</p>\n<h4>시퀀서 트랜잭션</h4>\n<p>시퀀서 트랜잭션은 이더리움과 동일한 방식으로 만들어져서 시퀀서에게 전송된다. 시퀀서는 트랜잭션을 전달받으면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/internal/ethapi/api.go#L1775">메타 정보를 새로 만드는데</a>, 메타 정보는 실행 환경에 필요한 컨텍스트 정보라고 할 수 있다. 시퀀서는 메타 정보를 만들고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/internal/ethapi/api.go#L1776">이를 트랜잭션에 추가</a>한다.</p>\n<pre>type TransactionMeta struct {<br>   L1BlockNumber     *big.Int<br>   L1Timestamp       uint64<br>   SignatureHashType SignatureHashType<br>   QueueOrigin       *big.Int<br>   Index             *uint64<br>   QueueIndex        *uint64<br><strong>   </strong>RawTransaction    []byte<strong><br></strong>}</pre>\n<ul>\n<li>L1BlockNumber: 레이어 1 컨텍스트의 블록 넘버 값이다. 시퀀서 트랜잭션은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/sync_service.go#L741">레이어 2 컨텍스트의 블록 넘버 값</a>을 사용한다.</li>\n<li>L1Timestamp: 레이어 1 컨텍스트의 타임스탬프 값이다. 시퀀서 트랜잭션은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/sync_service.go#L740">레이어 2 컨텍스트의 타임스탬프 값</a>을 사용한다.</li>\n<li>\n<a href="https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-types.md">SignatureHashType</a>: 트랜잭션의 인코딩 포맷에 따라 SighashEIP155 = 0, SighashEthSign = 1 그리고 CreateEOA = 2 값중 하나를 가진다.</li>\n<li>QueueOrigin: QueueOriginSequencer = 0 과 QueueOriginL1ToL2 = 1 값으로 옵티미즘 트랜잭션 타입을 구분한다. QueueOriginSequencer 는 시퀀서 트랜잭션 타입이고, QueueOriginL1ToL2 는 큐 트랜잭션 타입이다.</li>\n<li>Index: 레이어 2 체인의 블록 넘버다(옵티미즘의 블록은 트랜잭션 하나만 담는다). 큐 트랜잭션은 이 값을 가지지 않는다.</li>\n<li>QueueIndex: queue에 쌓인 큐 트랜잭션의 인덱스 값을 가진다. 시퀀서 트랜잭션은 이 값을 가지지 않는다.</li>\n<li>RawTransaction: <a href="https://github.com/ethereum-optimism/optimism/blob/develop/l2geth/ethclient/ethclient.go#L513">트랜잭션 데이터를 RLP 인코딩한 값</a>이 들어간다.</li>\n</ul>\n<p>유저가 시퀀서에게 트랜잭션을 보내면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/ethclient/ethclient.go#L512">SendTransaction 함수</a>가 호출된다. SendTransaction 함수는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/ethclient/ethclient.go#L513">트랜잭션 데이터를 RLP 인코딩</a>하고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/ethclient/ethclient.go#L517">SendRawTransaction 함수를 호출</a>한다. <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/internal/ethapi/api.go#L1761">SendRawTransaction 함수</a>는 위와 같이 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/internal/ethapi/api.go#L1775-L1776">메타 정보를 생성</a>하면서 RawTransaction 필드값에 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/ethclient/ethclient.go#L513">트랜잭션 데이터를 RLP 인코딩한 값</a>을 넣는다.</p>\n<p>옵티미즘의 트랜잭션을 실행하기 위해서는 이더리움과 마찬가지로 트랜잭션을 메시지로 변환해야 한다. 옵티미즘은 이를 위해 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_processor.go#L93">AsOvmMessage 함수를 호출</a>한다. 옵티미즘의 메시지는 다음과 같이 구성되어 있다.</p>\n<pre>type Message interface {<br>   From() common.Address<br>   To() *common.Address<br>   GasPrice() *big.Int<br>   Gas() uint64<br>   Value() *big.Int<br>   Nonce() uint64<br>   CheckNonce() bool<br>   Data() []byte<br>   L1MessageSender() *common.Address<br>   L1BlockNumber() *big.Int<br>   QueueOrigin() *big.Int<br>   SignatureHashType() types.SignatureHashType<br>}</pre>\n<p>AsOvmMessage 함수는 메시지의 데이터를 다음과 같이 수정한다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MPSdpszxyicrZTizxt-znA.png"></figure><ol>\n<li>메시지의 to 필드의 값을 OVM_SequencerEntrypoint 컨트랙트 주소로 변경한다.</li>\n<li>메시지의 data 필드의 값을 트랜잭션 메타 정보의 RawTransaction 값으로 변경한다.</li>\n</ol>\n<p>옵티미즘은 이렇게 수정된 OVM 메시지를 실행하기 전에 OVM 메시지를 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition.go#L213">한번 더 수정</a>한다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VvAzrPykccsdMmLO9wiYjw.png"></figure><ol>\n<li>메시지의 to 필드의 값을 OVM_ExecutionManager 컨트랙트 주소로 변경한다.</li>\n<li>메시지의 data 필드의 값을 OVM_ExecutionManager 컨트랙트의 run 함수를 호출하는 바이트코드로 변경한다. run 함수의 인자값은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L26-L34">수정된 OVM 메시지를 기반으로 OVM 트랜잭션를 만들어 이를 인코딩한 값</a>과 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L39">OVM_StateManager 컨트랙트의 주소</a>가 된다.</li>\n</ol>\n<p>OVM 트랜잭션은 아래와 같이 구성되어 있다. 시퀀서 트랜잭션의 entrypoint 필드값은 항상 SequencerEntrypoint 컨트랙트의 주소가 된다.</p>\n<pre>struct Transaction {<br>    uint256 timestamp;<br>    uint256 blockNumber;<br>    QueueOrigin l1QueueOrigin;<br>    address l1TxOrigin;<br>    address entrypoint;<br>    uint256 gasLimit;<br>    bytes data;<br>}</pre>\n<p>최종적으로, 옵티미즘은 위와 같이 수정된 OVM 메시지를 현재 옵티미즘 상태를 기반으로 실행하여 새로운 상태를 만들어 낸다. 이제 이렇게 수정된 메시지를 시퀀서가 어떻게 실행하는지 살펴보자.</p>\n<h4>시퀀서 트랜잭션 실행</h4>\n<p>수정된 OVM 메시지는 결국 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L159">ExecutionManager 컨트랙트의 run 함수</a>를 호출하게 된다. run 함수의 인자값은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L26-L34">인코딩된 트랜잭션 데이터</a>와 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L39">StateManager 컨트랙트의 주소</a>다.</p>\n<p>OVM에서 트랜잭션의 실행은 모두 ExecutionManager 컨트랙트의 run 함수로부터 시작한다. 그 이유는 OVM의 샌드박스된 환경에서 트랜잭션이 실행되어야 하기 때문이다(이에 대한 자세한 내용은 이전에 작성한 <a href="https://medium.com/onther-tech/how-does-optimisms-rollup-really-work-249797c91336?source=your_stories_page-------------------------------------">옵티미즘 글</a>에서 확인할 수 있다.). run 함수는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L207-L212">ovmCALL 함수</a>를 호출하고 최종적으로 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L947">_handleExternalMessage 함수</a>를 호출한다. _handleExternalMessage 함수는 (success, returndata) = _contract.call{gas: _gasLimit}(_data) 함수를 호출하는데, 여기서 <strong>_contract는 SequencerEntrypoint 컨트랙트 주소고, </strong><strong>_data는 유저가 전송한 트랜잭션을 RLP 인코딩한 데이터다.</strong> 결국 이 코드는 SequencerEntrypoint 컨트랙트에 메시지 콜을 하게 된다.</p>\n<pre>function run(<br>    Lib_OVMCodec.Transaction memory _transaction,<br>    address _ovmStateManager<br>)</pre>\n<p><a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol">OVM_SequencerEntrypoint 컨트랙트</a>에는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L35">fallback 함수</a>만 존재한다. <strong>따라서 ExecutionManager 컨트랙트의 run 함수는 결국 SequencerEntrypoint 컨트랙트의 fallback 함수를 호출하게 된다.</strong></p>\n<p>fallback 함수는 우선 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L41-L45">인코딩된 트랜잭션 데이터를 디코딩</a>한다. 디코딩된 트랜잭션 데이터는 아래와 같다.</p>\n<pre>struct EIP155Tx {<br>    uint256 nonce;<br>    uint256 gasPrice;<br>    uint256 gasLimit;<br>    address to;<br>    uint256 value;<br>    bytes data;<br>    uint8 v;<br>    bytes32 r;<br>    bytes32 s;<br>    uint256 chainId;<br>    uint8 recoveryParam;<br>    bool isCreate;       <br>}</pre>\n<p>이후 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/libraries/codec/Lib_EIP155Tx.sol#L187">디코딩된 트랜잭션의 서명값(v, r, s)을 이용해서 트랜잭션을 보낸 어카운트의 주소를 구한다</a>. 어카운트 주소를 구하면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L50-L53">해당 주소로 배포된 EOA 컨트랙트가 존재하는지 확인</a>(확인하기 위해서 어카운트의 codesize를 확인한다.)한다. 만약 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L55-L63">EOA 컨트랙트가 존재하지 않으면 EOA 컨트랙트를 새로 배포</a>한다. 마지막으로 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L65-L71">EOA 컨트랙트의 </a><a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L65-L71">execute(bytes) 함수를 호출</a>하는 메시지 콜을 하게 된다.</p>\n<p>여기에 EOA 컨트랙트라는 낯선 용어가 나타난다. 이를 이해하기 위해서는 옵티미즘이 어카운트와 상태를 어떻게 처리하는지 알아야 한다.</p>\n<p>우선 옵티미즘의 모든 어카운트는 컨트랙트 어카운트다. 즉, 옵티미즘에는 EOA가 존재하지 않는다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MGiIZDQO-bEe4wMeK27G7A.png"></figure><p>이를 실현하기 위해 옵티미즘은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol">OVM_ECDSAContractAccount 컨트랙트</a>를 만들었다. 따라서 옵티미즘의 EOA는 모두 ECDSAContractAccount 컨트랙트이고, 이를 EOA 컨트랙트라고 부른다. <strong>이 컨트랙트에는 execute 함수가 존재하는데, 이 함수는 이더리움의 EOA와 동일한 방식으로 동작한다.</strong> 이 함수가 호출되면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L76-L79">트랜잭션의 서명값을 통해 어카운트 주소</a>를 확인하고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L81-L85">nonce 값도 확인</a>한다. 그후 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L94-L101">수수료를 지불</a>한 뒤 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L124">nonce를 1 증가</a>시키고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L143">유저가 생성한 트랜잭션을 호출</a>한다.</p>\n<p>그리고 옵티미즘의 모든 어카운트의 상태는 StateManager 컨트랙트에 의해 관리된다. 예를 들어, EOA 컨트랙트가 존재하는지 확인하고, <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1256">EOA 컨트랙트를 새로 배포</a>하고, <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1204">어카운트의 nonce를 확인</a>하고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1187">nonce를 1 증가</a>시키는 것 모두 StateManager 컨트랙트가 관여한다.</p>\n<p>최종적으로, ExecutionManager 컨트랙트의 run 함수를 시발점으로 유저가 생성한 트랜잭션이 OVM의 샌드박스된 환경에서 실행되고, 변경된 어카운트와 스토리지는 모두 StateManager 컨트랙트에서 처리된다.</p>\n<h4>큐 트랜잭션</h4>\n<p>큐 트랜잭션은 레이어 1에서 만들어진 레이어 2 트랜잭션이다. 큐 트랜잭션을 만드는 이유는 시퀀서가 특정 유저를 검열(레이어 2에서 검열을 받는 유저는 레이어 1에서 트랜잭션을 만들어 검열을 회피할 수 있다.)하거나 레이어 1에서 레이어 2로 자산을 옮기기 위해서다.</p>\n<p>큐 트랜잭션을 만들기 위해서는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L257">CanonicalTransactionChain 컨트랙트의 </a><a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L257">enqueue 함수</a>를 호출한다. 큐 트랜잭션이 만들어지면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L105">queue 자료 구조</a>에 쌓이게 되고, 큐 트랜잭션은 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L323">큐 인덱스</a>를 갖게 된다. enqueue 함수는 다음과 같다.</p>\n<pre>function enqueue(<br>    address target,<br>    uint256 gasLimit,<br>    bytes memory data<br>)</pre>\n<ul>\n<li>target: 트랜잭션을 보낼 레이어 2 컨트랙트 주소다.</li>\n<li>gasLimit: 레이어 2에서 큐 트랜잭션이 사용하게 될 gasLimit이다. <a href="https://community.optimism.io/docs/users/fees-in-optimistic-ethereum.html#%F0%9F%92%B5-1-transacting-on-l2">실제로 옵티미즘은 gasLimit만큼 가스를 모두 소모한다.</a>\n</li>\n<li>data: 메시지 콜을 하기 위한 데이터다. e.g. abi.encodeWithSignature(“send(address)”, receiver)</li>\n</ul>\n<p>enqueue 함수는 중간에 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L293-L298">일정 가스를 소모하는 행위</a>를 한다(실제로 gasLimit / 32만큼 가스를 소모한다.). 이렇게 하는 이유는 큐 트랜잭션은 레이어 2에서 gasPrice가 0이기 때문에 <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">도스 공격</a>을 막기 위함이다. 즉, 일정 가스를 소모하게 만들어서 레이어 1에서 레이어 2에 부담이 될 수 있는 큐 트랜잭션을 무자비하게 만드는 것을 막는다.</p>\n<p>마지막으로 enqueue 함수가 성공적으로 실행되면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L324-L331">TransactionEnqueued 이벤트가 발생</a>한다.</p>\n<pre>event TransactionEnqueued(<br>    address l1TxOrigin,<br>    address target,<br>    uint256 gasLimit,<br>    bytes data,<br>    uint256 queueIndex,<br>    uint256 timestamp<br>);</pre>\n<ul>\n<li>l1TxOrigin: enqueue 함수를 호출하는 트랜잭션을 보낸 어카운트 주소다.</li>\n<li>target: enqueue 함수의 target 인자값과 같다.</li>\n<li>gasLimit: enqueue 함수의 gasLimit 인자값과 같다.</li>\n<li>data: enqueue 함수의 data 인자값과 같다.</li>\n<li>queueIndex: 큐 트랜잭션의 인덱스 값이다.</li>\n<li>timestamp: enqueue 함수가 실행되는 시점의 타임스탬프 값이다.</li>\n</ul>\n<p>TransactionEnqueued 이벤트의 인자값들은 큐 트랜잭션을 레이어 2에서 실행하기 위해 필요한 모든 정보를 담고 있다.</p>\n<h4>dtl (data transport layer)</h4>\n<p><strong>시퀀서가 큐 트랜잭션을 레이어 2에서 실행하기 위해서는 반드시 </strong><a href="https://github.com/ethereum-optimism/optimism/tree/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/data-transport-layer"><strong>data transport layer</strong></a><strong>라는 프로그램을 돌려야 한다.</strong> dtl에는 두가지 서비스가 동작한다.</p>\n<ol>\n<li>\n<a href="https://github.com/ethereum-optimism/optimism/tree/develop/specs/l2geth"><strong>Transaction Ingestor</strong></a>: CanonicalTransactionChain 컨트랙트에서 발생한 TransactionEnqueued (리스닝) <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/data-transport-layer/src/services/l1-ingestion/handlers/transaction-enqueued.ts#L15-L26">이벤트 데이터를 파싱</a>하고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/data-transport-layer/src/services/l1-ingestion/handlers/transaction-enqueued.ts#L27-L29">파싱된 데이터를 데이터베이스에 저장</a>한다.</li>\n<li>\n<a href="https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-indexer.md"><strong>Transaction Indexer</strong></a>: 데이터베이스에 저장된 데이터에 접근할 수 있도록 API 서버를 제공한다. 결국 이 데이터베이스는 이벤트 데이터 정보를 저장하게 된다.</li>\n</ol>\n<p>저장된 이벤트 데이터 정보는 API 서버로부터 다음과 같이 가져올 수 있다.</p>\n<p><strong>요청:</strong></p>\n<pre>GET /enqueue/index/{index: number}</pre>\n<p><strong>응답:</strong></p>\n<pre>{<br>  "index": number,<br>  "target": string,<br>  "data": string,<br>  "gasLimit": number,<br>  "origin": string,<br>  "blockNumber": number,<br>  "timestamp": number<br>}</pre>\n<p>dtl의 API 서버가 제공하는 다른 API는 <a href="https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-indexer.md#l1-transaction-indexer-api">여기</a>서 확인할 수 있다.</p>\n<h4><strong>큐 트랜잭션 실행</strong></h4>\n<p>옵티미즘 클라이언트는 큐 트랜잭션을 실행하기 위해 dtl의 API 서버로부터 이벤트 데이터 정보를 가지고 와야 한다. 이를 위해 옵티미즘 클라이언트는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/eth/backend.go#L212">sync 서비스를 돌려</a> dtl과 동기화한다. 시퀀서는 dtl과 동기화하기 위해 <a href="https://github.com/ethereum-optimism/optimism/tree/develop/l2geth#running-a-sequencer">옵티미즘 클라이언트를 실행</a>할 때 --rollup.clienthttp 플래그 값을 반드시 넣어야 한다. 이 값은 바로 dtl의 API 서버 주소가 된다.</p>\n<pre>$ USING_OVM=true ./build/bin/geth \\<br><strong>--rollup.addrclienthttp</strong><br>    ...</pre>\n<p>시퀀서가 옵티미즘 클라이언트를 실행하면 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/sync_service.go#L367">sequence 함수</a>가 호출된다. sequence 함수는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/client.go#L252-L271">dtl의 API 서버로부터 이벤트 데이터 정보를 가지고 온다</a>. 그런 다음 시퀀서는 가져온 이벤트 데이터 정보를 가지고 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/client.go#L233">큐 트랜잭션을 만든다</a>. 큐 트랜잭션은 다음의 두가지 특징을 가진다.</p>\n<ol>\n<li>\n<a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/client.go#L202">큐 인덱스 값을 트랜잭션의 </a><a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/client.go#L202">nonce로 사용</a>한다.</li>\n<li>gasPrice는 항상 0이다. 그렇기 때문에 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L293-L298">enqueue 함수에서 일정량의 가스를 미리 소모</a>한다.</li>\n</ol>\n<p>그리고 위에서 언급했듯이, 옵티미즘 트랜잭션은 모두 메타 정보를 가진다. <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/rollup/client.go#L196-L246">큐 트랜잭션의 메타 정보</a>는 다음과 같다.</p>\n<ul>\n<li>L1BlockNumber: enqueue 함수가 호출된 시점의 블록 넘버 값이다. 즉, 이벤트 데이터 정보의 블록 넘버 값이다.</li>\n<li>L1Timestamp: enqueue 함수가 호출된 시점의 타임스탬프 값이다. 즉, 이벤트 데이터 정보의 타임스탬프 값이다.</li>\n<li>\n<a href="https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-types.md">SignatureHashType</a>: 트랜잭션 데이터를 인코딩했기 때문에 SighashEIP155 = 0 값을 가진다.</li>\n<li>QueueOrigin: 큐 트랜잭션이기 때문에 QueueOriginL1ToL2 값을 가진다.</li>\n<li>Index: <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/data-transport-layer/src/services/l1-ingestion/handlers/transaction-enqueued.ts#L24">큐 트랜잭션은 이 값을 가지지 않는다</a>. <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/miner/worker.go#L890-L894">하지만 실제로 실행될 때 부모 블록의 블록 넘버를 넣는다</a>.</li>\n<li>QueueIndex: 큐 트랜잭션의 인덱스 값이다.</li>\n<li>RawTransaction: 메시지 콜을 하기 위한 데이터 값이다.</li>\n</ul>\n<p>이제 시퀀서는 이러한 큐 트랜잭션을 실행한다. 큐 트랜잭션도 시퀀서 트랜잭션과 마찬가지로 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L61">AsOvmMessage 함수를 호출</a>해서 OVM 메시지로 변환한다. 하지만 큐 트랜잭션은 시퀀서 트랜잭션처럼 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L72-L79">메시지의 to 필드값을 SequencerEntrypoint 컨트랙트 주소로, data 필드값을 트랜잭션 메타 정보의 RawTransaction으로 변경하지 않는다</a>.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*F8QcTU9CdPU--iCqONl7cg.png"></figure><p>다만, 이 메시지가 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/l2geth/core/state_transition_ovm.go#L25">ExecutionManager 컨트랙트의 run 함수에서 시작하도록 메시지를 수정</a>한다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jx8YDSDbzVsImIf_eVV-1g.png"></figure><p>이렇게 수정된 메시지는 시퀀서 트랜잭션과 마찬가지로 현재 상태를 기반으로 실행되어 새로운 상태를 만든다. 시퀀서 트랜잭션과 큐 트랜잭션의 차이점은 시퀀서 트랜잭션은 항상 SequencerEntrypoint 컨트랙트를 거치지만, 큐 트랜잭션은 target 주소에 바로 메시지 콜을 보낸다는 것이다.</p>\n<blockquote>실제로 큐 트랜잭션은 시퀀서가 특정 기간 내에 레이어 2에 반드시 반영해야 한다. 이를 위해 CanonicalTransactionChain 컨트랙트에는 <a href="https://github.com/ethereum-optimism/optimism/blob/cc209be13ccefc9d0c376413c81cf39be04d8f05/packages/contracts/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L338">appendQueueBatch 함수</a>가 존재하지만, 현재는 사용할 수 없게 되어 있다. 이는 추후에 개발될 것으로 보이며, 개발이 완료되면 해당 내용을 이 글에 추가할 예정이다.</blockquote>\n<h3>Conclusion</h3>\n<p>이번 글에서는 옵티미즘에서 취급하는 두 종류의 트랜잭션인 시퀀서 트랜잭션과 큐 트랜잭션에 대해 알아보았다. 옵티미즘은 트랜잭션을 실행한 후에 트랜잭션과 상태값을 레이어 1에 제출해야 한다. 이를 위해서는 <a href="https://github.com/ethereum-optimism/optimism/tree/develop/packages/batch-submitter">batch submitter</a>라고 하는 프로그램이 필요한데, 다음 글에서는 batch submitter가 트랜잭션과 상태값을 레이어 1에 어떻게 제출하는지에 대해 알아보고자 한다.</p>\n<h3>Reference</h3>\n<ul>\n<li><a href="https://github.com/ethereum-optimism/optimism">https://github.com/ethereum-optimism/optimism</a></li>\n<li><a href="https://github.com/gakonst/optimism-tx-format">https://github.com/gakonst/optimism-tx-format</a></li>\n<li><a href="https://ethereum.stackexchange.com/questions/7358/what-is-the-difference-between-transaction-and-message">https://ethereum.stackexchange.com/questions/7358/what-is-the-difference-between-transaction-and-message</a></li>\n</ul>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b5de4f1b82e1" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/optimism-transaction-b5de4f1b82e1">Optimism Transaction[KR]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                enclosure: {},
                categories: ["research"],
              },
              {
                title:
                  "Porting Solidity Contracts to Optimism: A Guide Using Uniswap V2[KR]",
                pubDate: "2021-05-25 03:33:34",
                link:
                  "https://medium.com/onther-tech/porting-solidity-contracts-to-optimism-a-guide-using-uniswap-v2-29b85be668d1?source=rss----eb8117f0bafd---4",
                guid: "https://medium.com/p/29b85be668d1",
                author: "Jason Hwang",
                thumbnail:
                  "https://cdn-images-1.medium.com/max/1024/0*mk-sZNccXo-8ejfn.png",
                description:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*mk-sZNccXo-8ejfn.png"></figure><h3>Intro</h3>\n<p>이번 포스팅에서는 기존 솔리디티 프로젝트를 Optimism으로 옮겨서 실행하는 과정에 대해 설명할 예정이며, Uniswap V2를 예제로 사용할 것 입니다. 포스팅은 기존 솔리디티 프로젝트를 Optimism으로 옮기기 위해 필요한 과정과 실제로 Optimism에 컨트랙트를 배포하는 과정으로 구성되어 있습니다.</p>\n<h3>Porting Process</h3>\n<p>기존 솔리디티 프로젝트들을 OVM에서 동작하도록 만들기 위해 필요한 수정사항은 크게 세 가지가 있습니다.</p>\n<ol>\n<li>\n<strong>Tooling updates:</strong> OVM은 현재 <a href="https://getwaffle.io/">Waffle V3</a> 를 통해 동작하고 있습니다. 구 버전의 Waffle을 사용하고 있다면 이를 V3로 업그레이드 해줘야하고, 다른 프레임워크를 사용하고 있다면 마이그레이션 작업이 필요합니다.</li>\n<li>\n<strong>Test suite updates:</strong> 도구에 대한 업데이트 외에도, 일부 테스트 코드는 EVM과 OVM의 차이를 감안하여 수정해야 하고, 로컬 OVM 노드에서 실행을 지원해야 합니다.</li>\n<li>\n<strong>Contract and compiler modification:</strong> EVM과 OVM의 차이로 인해 솔리디티 컨트랙트나 컴파일러 설정을 변경해줘야 하는 경우도 있습니다. Uniswap V2는 수정할 필요가 없지만, 이번 포스팅에서는 컨트랙트 코드 수정이 필요한 몇 가지 사례를 살펴보도록 하겠습니다.</li>\n</ol>\n<h3>Getting Started</h3>\n<p>먼저 <a href="https://github.com/Uniswap/uniswap-v2-core">Uniswap V2 Core</a> 를 클론해야 합니다. 클론한 다음 yarn 을 이용해 패키지를 설치하고 yarn test 를 이용해 모든 테스트가 통과하는지 우선 확인 해야 합니다.</p>\n<h4>Package Upgrades</h4>\n<p>EVM과 OVM 양 쪽에서 테스트가 모두 될 수 있게 하려면 우선 package.json 을 아래와 같이수정해야 합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/605/1*SoDOlodznG68_IbP3cU29g.png"></figure><p>그리고 Uniswap V2에서 사용하는 Waffle을 V2에서 V3로 업데이트 해줘야 합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/601/1*fZwZLO3iRNMI-8U8XMQwpA.png"></figure><p>그 다음 yarn 을 통해 패키지를 업데이트 해줍니다. yarn test:evm 명령어를 이용해 테스트를 수행해보면 Waffle 버전 업그레이드로 인한 변경점 때문에 에러가 많이 발생할 것입니다.</p>\n<h4>EVM Test Suite Updates</h4>\n<p>Waffle 버전 업그레이드로 인한 변경 사항으로 인한 에러를 해결하기 위해 변경해야할 사항에 대한 안내를 하자고 합니다. 주요 수정사항으로는 ethers/utils 패키지가 @ethersproject 로 변경된 것 입니다.</p>\n<p>먼저 test/UniswapV2ERC20.spec.ts 를 수정 해보겠습니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/824/1*P_NiAnLrCEMqh9y6G_LI5w.png"></figure><p>test/shared/utilities.ts 는 다음과 같이 수정해야 합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1014/1*qSG8xSIcsoZTk8Pw9phvxQ.png"></figure><p>test/UniswapV2Factory.spec.ts 은 다음과 같이 수정해야 합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/746/1*6ZMC3oIWOevMvYW23m3Aog.png"></figure><p>test/shared/fixtures.ts 는 다음과 같이 수정합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/881/1*0cZNNEGTOxw-wjYMf9TjfA.png"></figure><p>마지막으로 test/UniswapV2Pair.spec.ts 를 다음과 같이 수정해야 합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1002/1*XhqWP8_5Le5WXtJWMUC5GA.png"></figure><p>그 다음 yarn test:evm 명령어를 이용해 테스트를 수행하면 문제없이 동작할 것 입니다.</p>\n<h3>Optimism Setup</h3>\n<p>Optimism에서 동작하는 툴들을 설치하기 위해서는 Node v10이 필요합니다. 노드 버전 관리를 위해 <a href="https://docs.volta.sh/guide/getting-started">Volta</a>와 같은 도구를 사용하는 것을 권장합니다. Volta를 사용하고 있다면 volta pin node@10 &amp;&amp; volta pin yarn 명령어를 실행하면 자동적으로 필요한 Node 버전에 맞게package.json 파일을 업데이트 합니다.</p>\n<p>필요한 Optimism 패키지는 두개가 있습니다. 다음 명령어를 이용해 설치해 주도록 하겠습니다.</p>\n<pre>$ yarn add --dev @eth-optimism/solc@0.5.16-alpha.7 @eth-optimism/ovm-toolchain</pre>\n<h4>Compiling for the OVM</h4>\n<p>그 다음은 컨트랙트를 OVM에 배포할 수 있는 형태로 컴파일 해야합니다. 그러기 위해서는 .waffe.json 파일을 수정해야 합니다. .waffle.json 파일은 EVM 전용으로 작성되어 있기 때문에 .waffle-ovm.json 을 아래와 같이 작성하면 됩니다.</p>\n<pre>{<br>  "compilerVersion": "./node_modules/@eth-optimism/solc",<br>  "outputType": "all",<br>  "compilerOptions": {<br>    "outputSelection": {<br>      "*": {<br>        "*": [<br>          "evm.bytecode.object",<br>          "evm.deployedBytecode.object",<br>          "abi",<br>          "evm.bytecode.sourceMap",<br>          "evm.deployedBytecode.sourceMap",<br>          "metadata"<br>        ],<br>        "": ["ast"]<br>      }<br>    },<br>    "evmVersion": "istanbul",<br>    "optimizer": {<br>      "enabled": true,<br>      "runs": 999999<br>    }<br>  }<br>}</pre>\n<p>마지막으로 package.json 의 스크립트를 수정해야 합니다. EVM과 OVM의 구분을 명확하게 하기위해 :evm 과 :ovm 을 붙여 구분해 줍니다.</p>\n<pre>"scripts": {<br>  "lint": "yarn prettier ./test/*.ts --check",<br>  "lint:fix": "yarn prettier ./test/*.ts --write",<br>  "clean": "rimraf ./build/",<br>  "precompile:evm": "yarn clean",<br>  "precompile:ovm": "yarn clean",<br>  "compile:evm": "waffle .waffle.json",<br>  "compile:ovm": "waffle .waffle-ovm.json",<br>  "pretest:evm": "yarn compile:evm",<br>  "pretest:ovm": "yarn compile:ovm",<br>  "test:evm": "mocha",<br>  "test:ovm": "export MODE=OVM &amp;&amp; mocha",<br>  "prepublishOnly": "yarn test:evm &amp;&amp; yarn test:ovm"<br>},</pre>\n<h3>Testing on the OVM</h3>\n<p>마지막으로, OVM에서 컨트랙트를 테스트하기 위해서는 provider, 체인 ID 그리고 가스 사용에 대한 내용을 수정해줘야 합니다. Waffle에서 테스트에 제공하는 new MockProvider() 는 EVM 전용이지만, OVM에서 테스트하기 위해서는 OVM 인스턴스가 필요합니다. 또한, OVM의 체인 ID는 420 이기 때문에 이를 위한 코드가 필요합니다. test/shared/config.ts 파일을 만들고 아래와 같이 코드를 작성하면 됩니다.</p>\n<h4>Provider change</h4>\n<pre>import { MockProvider } from \'ethereum-waffle\' <br>import { waffleV3 } from \'@eth-optimism/ovm-toolchain\' <br><br>const isOVM = process.env.MODE === \'OVM\'<br><br>const options: any = {<br>  ganacheOptions: {<br>    hardfork: \'istanbul\',<br>    mnemonic: \'horn horn horn horn horn horn horn horn horn horn horn horn\',<br>    gasLimit: 9999999<br>  }<br>}<br>const provider = isOVM ? new waffleV3.MockProvider(options) : new MockProvider(options)<br><br>const chainId = isOVM ? 420 : 1<br><br>export { provider, chainId, isOVM }</pre>\n<p>그 다음 test/UniswapV2ERC20.spec.ts 와 test/UniswapV2Pair.spec.ts 를 아래와 같이 수정해줍니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/801/1*OmtemuUIYz_W553ux8LjYg.png"></figure><h4>Chain ID change</h4>\n<p>그리고 test/shared/utilities.ts 와 test/UniswapV2ERC20.spec.ts의 체인 ID를 수정합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/982/1*21yRR1iBh9b8A4fUbeYLPA.png"></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/988/1*8nRPWRjhde8eLg48tXy1jA.png"></figure><h4>Gas usage change</h4>\n<p>OVM과 EVM은 일부 옵코드의 가스 소모량의 차이가 있기 때문에 이에 대한 수정을 하지 않을 경우 실패하는 테스트가 있을 것입니다. 이를 수정해 주도록 하겠습니다.</p>\n<p>UniswapV2Factory.spec.ts 를 다음과 같이 수정해 줍니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/729/1*1AVkw-V3M17jsN26Vnu0bg.png"></figure><p>그리고 UniswapV2Pair.spec.ts 를 다음과 같이 수정합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/664/1*3xM0y-3e9UKm_bESnLMYaw.png"></figure><p>그 다음 yarn test:ovm 과 yarn test:evm 명령어를 이용해 테스트를 수행하면 아무런 문제없이 테스트가 통과될 것입니다.</p>\n<p>지금까지 수행한 변경사항과 기존 Uniswap V2 코드의 차이는 <a href="https://github.com/ScopeLift/ovm-uniswap-v2-core/compare/master...ScopeLift:optimism-integration">여기</a>에서 확인하실 수 있습니다.</p>\n<h3>Deploy Contract to Optimism</h3>\n<p>코드에 대한 수정이 완료되었다면 이제 실제로 옵티미스틱 롤업에 Uniswap V2를 배포해 보도록 하겠습니다. 배포 대상은 UniswapV2Factory와 UniswapV2Pair 입니다. 해당 과정은 아래 세 포스팅을 따라 옵티미스틱 롤업을 사용해 봤다는 것을 전제로 합니다.</p>\n<blockquote>\n<a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f"><em>옵티미스틱 롤업 사용하기</em></a><em><br></em><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3"><em>옵티미스틱 롤업에서 ERC20 사용하기</em></a><em><br></em><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d"><em>옵티미스틱 롤업에서 ERC721 사용하기</em></a>\n</blockquote>\n<p>그리고 옵티미스틱 롤업이 실행이 되고 있지 않다면 실행해줘야 합니다.</p>\n<pre>$ cd optimism/ops<br>$ docker-compose up -d</pre>\n<h4>Compile</h4>\n<p>위에서 했던 작업 내용을 바탕으로 컨트랙트를 OVM 에 배포할 수 있게 컴파일 하도록 하겠습니다.</p>\n<pre> $ yarn compile:ovm</pre>\n<h4>Deployment script</h4>\n<p>컨트랙트 배포를 위해 아래와 같이 스크립트를 작성해줍니다.</p>\n<a href="https://medium.com/media/386c0dd6fb08bf2a9834d7cd3117be37/href">https://medium.com/media/386c0dd6fb08bf2a9834d7cd3117be37/href</a><p>그 다음 해당 스크립트를 실행시킵니다.</p>\n<pre>$ node ./deploy_script.js</pre>\n<h4>Result</h4>\n<p>배포가 정상적으로 되었다면 아래와 같은 결과를 확인할 수 있습니다.</p>\n<pre>Deploying L2 UniswapV2Factory...</pre>\n<pre>L2UniswapV2Factory Contract address: 0x70e0bA845a1A0F2DA3359C97E0285013525FFC49</pre>\n<pre>Deploying L2 UniswapV2Pair...</pre>\n<pre>L2UniswapV2Pair Contract address: 0x4826533B4897376654Bb4d4AD88B7faFD0C98528</pre>\n<h3>Conclusion</h3>\n<p>이번 포스팅을 통해 기존 EVM에서 동작하던 컨트랙트를 OVM에서 동작하도록 변경하고, 테스트를 수행한 다음 실제로 옵티미스틱 롤업에 배포해 봤습니다. 테스트와 컨트랙트 배포가 정상적으로 이루어 진것으로 보아 실제로 옵티미스틱 롤업에서 UniswapV2가 문제없이 동작할 것으로 판단됩니다.</p>\n<p>아직 옵티미스틱 롤업에서 Waffle V3 밖에 지원하지 않기 때문에, 트러플과 같은 다른 테스트 도구를 이용한다면 이를 Waffle V3로 마이그레이션 해줘야하는 불편함이 있습니다. 하지만, 이를 제외한다면 기존에 작성된 컨트랙트를 옵티미스틱 롤업으로 옮겨오는 것은 큰 불편함 없이 가능할것으로 보입니다.</p>\n<h3>Reference</h3>\n<p><a href="https://github.com/ScopeLift/ovm-uniswap-v2-core/blob/master/README.md">https://github.com/ScopeLift/ovm-uniswap-v2-core/blob/master/README.md</a></p>\n<p><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3</a></p>\n<p><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=29b85be668d1" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/porting-solidity-contracts-to-optimism-a-guide-using-uniswap-v2-29b85be668d1">Porting Solidity Contracts to Optimism: A Guide Using Uniswap V2[KR]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                content:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*mk-sZNccXo-8ejfn.png"></figure><h3>Intro</h3>\n<p>이번 포스팅에서는 기존 솔리디티 프로젝트를 Optimism으로 옮겨서 실행하는 과정에 대해 설명할 예정이며, Uniswap V2를 예제로 사용할 것 입니다. 포스팅은 기존 솔리디티 프로젝트를 Optimism으로 옮기기 위해 필요한 과정과 실제로 Optimism에 컨트랙트를 배포하는 과정으로 구성되어 있습니다.</p>\n<h3>Porting Process</h3>\n<p>기존 솔리디티 프로젝트들을 OVM에서 동작하도록 만들기 위해 필요한 수정사항은 크게 세 가지가 있습니다.</p>\n<ol>\n<li>\n<strong>Tooling updates:</strong> OVM은 현재 <a href="https://getwaffle.io/">Waffle V3</a> 를 통해 동작하고 있습니다. 구 버전의 Waffle을 사용하고 있다면 이를 V3로 업그레이드 해줘야하고, 다른 프레임워크를 사용하고 있다면 마이그레이션 작업이 필요합니다.</li>\n<li>\n<strong>Test suite updates:</strong> 도구에 대한 업데이트 외에도, 일부 테스트 코드는 EVM과 OVM의 차이를 감안하여 수정해야 하고, 로컬 OVM 노드에서 실행을 지원해야 합니다.</li>\n<li>\n<strong>Contract and compiler modification:</strong> EVM과 OVM의 차이로 인해 솔리디티 컨트랙트나 컴파일러 설정을 변경해줘야 하는 경우도 있습니다. Uniswap V2는 수정할 필요가 없지만, 이번 포스팅에서는 컨트랙트 코드 수정이 필요한 몇 가지 사례를 살펴보도록 하겠습니다.</li>\n</ol>\n<h3>Getting Started</h3>\n<p>먼저 <a href="https://github.com/Uniswap/uniswap-v2-core">Uniswap V2 Core</a> 를 클론해야 합니다. 클론한 다음 yarn 을 이용해 패키지를 설치하고 yarn test 를 이용해 모든 테스트가 통과하는지 우선 확인 해야 합니다.</p>\n<h4>Package Upgrades</h4>\n<p>EVM과 OVM 양 쪽에서 테스트가 모두 될 수 있게 하려면 우선 package.json 을 아래와 같이수정해야 합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/605/1*SoDOlodznG68_IbP3cU29g.png"></figure><p>그리고 Uniswap V2에서 사용하는 Waffle을 V2에서 V3로 업데이트 해줘야 합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/601/1*fZwZLO3iRNMI-8U8XMQwpA.png"></figure><p>그 다음 yarn 을 통해 패키지를 업데이트 해줍니다. yarn test:evm 명령어를 이용해 테스트를 수행해보면 Waffle 버전 업그레이드로 인한 변경점 때문에 에러가 많이 발생할 것입니다.</p>\n<h4>EVM Test Suite Updates</h4>\n<p>Waffle 버전 업그레이드로 인한 변경 사항으로 인한 에러를 해결하기 위해 변경해야할 사항에 대한 안내를 하자고 합니다. 주요 수정사항으로는 ethers/utils 패키지가 @ethersproject 로 변경된 것 입니다.</p>\n<p>먼저 test/UniswapV2ERC20.spec.ts 를 수정 해보겠습니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/824/1*P_NiAnLrCEMqh9y6G_LI5w.png"></figure><p>test/shared/utilities.ts 는 다음과 같이 수정해야 합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1014/1*qSG8xSIcsoZTk8Pw9phvxQ.png"></figure><p>test/UniswapV2Factory.spec.ts 은 다음과 같이 수정해야 합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/746/1*6ZMC3oIWOevMvYW23m3Aog.png"></figure><p>test/shared/fixtures.ts 는 다음과 같이 수정합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/881/1*0cZNNEGTOxw-wjYMf9TjfA.png"></figure><p>마지막으로 test/UniswapV2Pair.spec.ts 를 다음과 같이 수정해야 합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1002/1*XhqWP8_5Le5WXtJWMUC5GA.png"></figure><p>그 다음 yarn test:evm 명령어를 이용해 테스트를 수행하면 문제없이 동작할 것 입니다.</p>\n<h3>Optimism Setup</h3>\n<p>Optimism에서 동작하는 툴들을 설치하기 위해서는 Node v10이 필요합니다. 노드 버전 관리를 위해 <a href="https://docs.volta.sh/guide/getting-started">Volta</a>와 같은 도구를 사용하는 것을 권장합니다. Volta를 사용하고 있다면 volta pin node@10 &amp;&amp; volta pin yarn 명령어를 실행하면 자동적으로 필요한 Node 버전에 맞게package.json 파일을 업데이트 합니다.</p>\n<p>필요한 Optimism 패키지는 두개가 있습니다. 다음 명령어를 이용해 설치해 주도록 하겠습니다.</p>\n<pre>$ yarn add --dev @eth-optimism/solc@0.5.16-alpha.7 @eth-optimism/ovm-toolchain</pre>\n<h4>Compiling for the OVM</h4>\n<p>그 다음은 컨트랙트를 OVM에 배포할 수 있는 형태로 컴파일 해야합니다. 그러기 위해서는 .waffe.json 파일을 수정해야 합니다. .waffle.json 파일은 EVM 전용으로 작성되어 있기 때문에 .waffle-ovm.json 을 아래와 같이 작성하면 됩니다.</p>\n<pre>{<br>  "compilerVersion": "./node_modules/@eth-optimism/solc",<br>  "outputType": "all",<br>  "compilerOptions": {<br>    "outputSelection": {<br>      "*": {<br>        "*": [<br>          "evm.bytecode.object",<br>          "evm.deployedBytecode.object",<br>          "abi",<br>          "evm.bytecode.sourceMap",<br>          "evm.deployedBytecode.sourceMap",<br>          "metadata"<br>        ],<br>        "": ["ast"]<br>      }<br>    },<br>    "evmVersion": "istanbul",<br>    "optimizer": {<br>      "enabled": true,<br>      "runs": 999999<br>    }<br>  }<br>}</pre>\n<p>마지막으로 package.json 의 스크립트를 수정해야 합니다. EVM과 OVM의 구분을 명확하게 하기위해 :evm 과 :ovm 을 붙여 구분해 줍니다.</p>\n<pre>"scripts": {<br>  "lint": "yarn prettier ./test/*.ts --check",<br>  "lint:fix": "yarn prettier ./test/*.ts --write",<br>  "clean": "rimraf ./build/",<br>  "precompile:evm": "yarn clean",<br>  "precompile:ovm": "yarn clean",<br>  "compile:evm": "waffle .waffle.json",<br>  "compile:ovm": "waffle .waffle-ovm.json",<br>  "pretest:evm": "yarn compile:evm",<br>  "pretest:ovm": "yarn compile:ovm",<br>  "test:evm": "mocha",<br>  "test:ovm": "export MODE=OVM &amp;&amp; mocha",<br>  "prepublishOnly": "yarn test:evm &amp;&amp; yarn test:ovm"<br>},</pre>\n<h3>Testing on the OVM</h3>\n<p>마지막으로, OVM에서 컨트랙트를 테스트하기 위해서는 provider, 체인 ID 그리고 가스 사용에 대한 내용을 수정해줘야 합니다. Waffle에서 테스트에 제공하는 new MockProvider() 는 EVM 전용이지만, OVM에서 테스트하기 위해서는 OVM 인스턴스가 필요합니다. 또한, OVM의 체인 ID는 420 이기 때문에 이를 위한 코드가 필요합니다. test/shared/config.ts 파일을 만들고 아래와 같이 코드를 작성하면 됩니다.</p>\n<h4>Provider change</h4>\n<pre>import { MockProvider } from \'ethereum-waffle\' <br>import { waffleV3 } from \'@eth-optimism/ovm-toolchain\' <br><br>const isOVM = process.env.MODE === \'OVM\'<br><br>const options: any = {<br>  ganacheOptions: {<br>    hardfork: \'istanbul\',<br>    mnemonic: \'horn horn horn horn horn horn horn horn horn horn horn horn\',<br>    gasLimit: 9999999<br>  }<br>}<br>const provider = isOVM ? new waffleV3.MockProvider(options) : new MockProvider(options)<br><br>const chainId = isOVM ? 420 : 1<br><br>export { provider, chainId, isOVM }</pre>\n<p>그 다음 test/UniswapV2ERC20.spec.ts 와 test/UniswapV2Pair.spec.ts 를 아래와 같이 수정해줍니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/801/1*OmtemuUIYz_W553ux8LjYg.png"></figure><h4>Chain ID change</h4>\n<p>그리고 test/shared/utilities.ts 와 test/UniswapV2ERC20.spec.ts의 체인 ID를 수정합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/982/1*21yRR1iBh9b8A4fUbeYLPA.png"></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/988/1*8nRPWRjhde8eLg48tXy1jA.png"></figure><h4>Gas usage change</h4>\n<p>OVM과 EVM은 일부 옵코드의 가스 소모량의 차이가 있기 때문에 이에 대한 수정을 하지 않을 경우 실패하는 테스트가 있을 것입니다. 이를 수정해 주도록 하겠습니다.</p>\n<p>UniswapV2Factory.spec.ts 를 다음과 같이 수정해 줍니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/729/1*1AVkw-V3M17jsN26Vnu0bg.png"></figure><p>그리고 UniswapV2Pair.spec.ts 를 다음과 같이 수정합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/664/1*3xM0y-3e9UKm_bESnLMYaw.png"></figure><p>그 다음 yarn test:ovm 과 yarn test:evm 명령어를 이용해 테스트를 수행하면 아무런 문제없이 테스트가 통과될 것입니다.</p>\n<p>지금까지 수행한 변경사항과 기존 Uniswap V2 코드의 차이는 <a href="https://github.com/ScopeLift/ovm-uniswap-v2-core/compare/master...ScopeLift:optimism-integration">여기</a>에서 확인하실 수 있습니다.</p>\n<h3>Deploy Contract to Optimism</h3>\n<p>코드에 대한 수정이 완료되었다면 이제 실제로 옵티미스틱 롤업에 Uniswap V2를 배포해 보도록 하겠습니다. 배포 대상은 UniswapV2Factory와 UniswapV2Pair 입니다. 해당 과정은 아래 세 포스팅을 따라 옵티미스틱 롤업을 사용해 봤다는 것을 전제로 합니다.</p>\n<blockquote>\n<a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f"><em>옵티미스틱 롤업 사용하기</em></a><em><br></em><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3"><em>옵티미스틱 롤업에서 ERC20 사용하기</em></a><em><br></em><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d"><em>옵티미스틱 롤업에서 ERC721 사용하기</em></a>\n</blockquote>\n<p>그리고 옵티미스틱 롤업이 실행이 되고 있지 않다면 실행해줘야 합니다.</p>\n<pre>$ cd optimism/ops<br>$ docker-compose up -d</pre>\n<h4>Compile</h4>\n<p>위에서 했던 작업 내용을 바탕으로 컨트랙트를 OVM 에 배포할 수 있게 컴파일 하도록 하겠습니다.</p>\n<pre> $ yarn compile:ovm</pre>\n<h4>Deployment script</h4>\n<p>컨트랙트 배포를 위해 아래와 같이 스크립트를 작성해줍니다.</p>\n<a href="https://medium.com/media/386c0dd6fb08bf2a9834d7cd3117be37/href">https://medium.com/media/386c0dd6fb08bf2a9834d7cd3117be37/href</a><p>그 다음 해당 스크립트를 실행시킵니다.</p>\n<pre>$ node ./deploy_script.js</pre>\n<h4>Result</h4>\n<p>배포가 정상적으로 되었다면 아래와 같은 결과를 확인할 수 있습니다.</p>\n<pre>Deploying L2 UniswapV2Factory...</pre>\n<pre>L2UniswapV2Factory Contract address: 0x70e0bA845a1A0F2DA3359C97E0285013525FFC49</pre>\n<pre>Deploying L2 UniswapV2Pair...</pre>\n<pre>L2UniswapV2Pair Contract address: 0x4826533B4897376654Bb4d4AD88B7faFD0C98528</pre>\n<h3>Conclusion</h3>\n<p>이번 포스팅을 통해 기존 EVM에서 동작하던 컨트랙트를 OVM에서 동작하도록 변경하고, 테스트를 수행한 다음 실제로 옵티미스틱 롤업에 배포해 봤습니다. 테스트와 컨트랙트 배포가 정상적으로 이루어 진것으로 보아 실제로 옵티미스틱 롤업에서 UniswapV2가 문제없이 동작할 것으로 판단됩니다.</p>\n<p>아직 옵티미스틱 롤업에서 Waffle V3 밖에 지원하지 않기 때문에, 트러플과 같은 다른 테스트 도구를 이용한다면 이를 Waffle V3로 마이그레이션 해줘야하는 불편함이 있습니다. 하지만, 이를 제외한다면 기존에 작성된 컨트랙트를 옵티미스틱 롤업으로 옮겨오는 것은 큰 불편함 없이 가능할것으로 보입니다.</p>\n<h3>Reference</h3>\n<p><a href="https://github.com/ScopeLift/ovm-uniswap-v2-core/blob/master/README.md">https://github.com/ScopeLift/ovm-uniswap-v2-core/blob/master/README.md</a></p>\n<p><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3</a></p>\n<p><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=29b85be668d1" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/porting-solidity-contracts-to-optimism-a-guide-using-uniswap-v2-29b85be668d1">Porting Solidity Contracts to Optimism: A Guide Using Uniswap V2[KR]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                enclosure: {},
                categories: ["research"],
              },
              {
                title:
                  "Optimistic Rollup is Not Secure Enough Than You Think[EN]",
                pubDate: "2021-05-20 05:35:06",
                link:
                  "https://medium.com/onther-tech/optimistic-rollup-is-not-secure-enough-than-you-think-cb23e6e6f11c?source=rss----eb8117f0bafd---4",
                guid: "https://medium.com/p/cb23e6e6f11c",
                author: "박정원(Aiden Park)",
                thumbnail:
                  "https://cdn-images-1.medium.com/max/1024/0*JQF4tUx0vufkmNfF",
                description:
                  '\n<h3><strong>Optimistic Rollup is Not Secure Enough Than You Think — Game Theoretic Approach for More Verifiable Rollup[EN]</strong></h3>\n<h3><strong>Intro</strong></h3>\n<p><em>Special thanks to Vitalik Buterin, Ed Felten for their insight, and Kevin, Lakmi for feedback and reviews.</em></p>\n<p><a href="https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/optimistic_rollups/">Optimistic rollup</a> (hereinafter referred to as rollup) is a layer 2 solution that burst on the Ethereum community which was struggling to solve the problem of <a href="https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/plasma/">Plasma</a>. The biggest advantage of rollup is that unlike plasma, <a href="https://medium.com/starkware/validity-proofs-vs-fraud-proofs-4ef8b4d3d87a">Fraud Proof</a> ensures security for all users without monitoring rollup, if they have at least one honest verifier. This was a major factor in gaining the full support of the Ethereum community, despite the downside that rollup sacrifices scalability significantly compared to Plasma.</p>\n<p>Rollup is a very attractive Layer 2 that can operate safely with literally only one Honest Verifier. But since we, living in the blockchain world, are very suspicious people, the question arises as to whether we can be sure that the rollup truly functions safely. In fact, these questions are not very new. With the concept of Verifier’s Dilemma, for quite some time, many researchers have been discussing whether verification can be performed accurately for various fields that require verification. Similar discussions have been made about the rollup, and opinions on this matter consist largely of two divisions. One argues that <a href="https://research.paradigm.xyz/rollups">we don’t have to consider the verifier’s Dilemma ‘at all’</a> in rollup, while the other argues that <a href="https://vitalik.ca/general/2021/01/05/rollup.html">we must take into account the verifier’s Dilemma in rollup</a> for safe long-term operations.</p>\n<p>Which opinion is correct? From the point of view of the user, not the designer, can we really safely use rollup? What should we do if it’s definitely not safe? This article addresses all these questions, and provides a concrete method on which direction to go in the long run to ensure the security of rollup.</p>\n<p><em>All of the discussions covered in this article can be applied to any scalability solution that uses Fraud Proof, as well as any Optimistic rollup.</em></p>\n<h3>Verifier’s Dilemma</h3>\n<p>There are other concepts that must be addressed before solving the issue of rollup security, main of which is the verifier’s dilemma mentioned above. In general, the verifier’s dilemma is a series of problems that occur when one participant performs some operation in the blockchain and another participant verifies the work to maintain the safety of the network or protocol, but the utility of verification is unclear.</p>\n<p>The concept of verifier’s dilemma which was first discussed in <a href="https://eprint.iacr.org/2015/702.pdf">this article</a>, can be easily explained as follows. In blockchains such as Bitcoin and Ethereum, when the miner who mines the next block propagates the block to other nodes in the network, all other nodes verify the validity of the block. This is the original intention of the PoW consensus, and in terms of the safety of the network, it is desirable that all other nodes that have synchronized the block must verify it. However, since the computing power of individual nodes is finite, it might be more profitable to allocate it for the task of mining the next block instead of verifying complex transactions. Of course, you will have to take the risk that a block whose ancestor is an invalid block cannot be accepted by the network. Therefore, individual nodes are constantly in an impasse whether it is more advantageous to perform verification or to focus only on mining without verification.</p>\n<p>This verifier’s dilemma can be applied in a similar way for rollups. In rollup, after the sequencer executes the transactions in Layer 2, it only submits a root of the states ​​and corresponding transaction data to Layer 1.</p>\n<p><em>The sequencer or operator is responsible for determining the order of the users’ transactions in the rollup, and submitting them to Layer 1. In this article, we will use the term sequencer.</em></p>\n<p>The rollup prevents the sequencer from submitting incorrect state values at this time with <a href="https://medium.com/starkware/validity-proofs-vs-fraud-proofs-4ef8b4d3d87a">Fraud Proof</a>, and Dispute Time Delay (DTD). All users inside and outside of the rollup can be verifiers, and they can prevent invalid states from being finalized with fraud proof in DTD.</p>\n<p>If fraud is proven by the verifier, the deposit of the sequencer will be rewarded entirely or partially to the verifier. However, one problem arises here. What if the sequencer always submits the correct values? No matter how much verification work the verifier performs, he wouldn’t be able to prove any fraud and soon would lose the incentive for verification. However, one might say it was the original intention, for the security of rollup that the sequencer always submits only correct values to Layer 1, but let’s see why this is a problem.</p>\n<ol>\n<li>The verifier always verifies the state root submitted by the sequencer.</li>\n<li>If the sequencer submits an incorrect value, the deposit will be slashed by the fraud proof, so it will continue to submit only the correct state roots.</li>\n<li><strong>The verifier cannot be rewarded for verification work because the sequencer continues to submit only the correct values. Therefore, he would stop further verification.</strong></li>\n<li>Since the verifier has stopped verification, the sequencer has a strong incentive to attack the rollup and take over the assets of the users.</li>\n</ol>\n<p>In short, since the economic incentive for verification is strongly dependent on the sequencer’s attack behavior, the less the sequencer attacks, (i.e. the safer the rollup is,) the less the incentive for verification is. This is paradoxical, because the safer the rollup is, the more dangerous it is; and the more dangerous it is, the safer it is. According to this logic, at a glance, the verifier’s dilemma appears to be a factor that could seriously jeopardize the security of the rollup. Is the verifier’s dilemma really a threat to the rollup? Let’s dig deeper in the next section.</p>\n<h3>Super-Simple Model</h3>\n<p>To understand and solve a complex concept or problem, the best way is to always simplify the problem. Therefore, before discussing the verifier’s dilemma of the rollup in earnest, we will first look at the Super-Simple Model, which is a very simplified version of it.</p>\n<p><em>The Super-Simple Model is based on Ed Felten’s article </em><a href="https://medium.com/offchainlabs/the-cheater-checking-problem-why-the-verifiers-dilemma-is-harder-than-you-think-9c7156505ca1"><em>The Cheater Checking Problem: Why the Verifier’s Dilemma is Harder Than You Think</em></a><em>.</em></p>\n<p><em>Assumption: For all models covered in this article, it is assumed that the rationality of all participants or players is </em><a href="https://en.wikipedia.org/wiki/Common_knowledge_(logic)"><em>common knowledge</em></a><em>. This means that the following two infinite propositions are true.</em></p>\n<p><em>‘I know that you are rational.</em></p>\n<p><em>You know that I know that you are rational.</em></p>\n<p><em>I know that you know that I know that you are rational. … ’</em></p>\n<p><em>‘You know that I am rational.</em></p>\n<p><em>I know you know that I’m rational.</em></p>\n<p><em>You know that I know that you know that I’m rational. … ..’</em></p>\n<p>First, let’s consider a very simple system. There are two players in this system; one as the Asserter (A), who simply claims true or false, and the Verifier (V) who can verify A’s assertion with paying the cost of verification, or can choose to do nothing assuming that A would have asserted true. If A’s claim is false and V succeeds in verifying it, A’s deposit will be rewarded to V.</p>\n<p>Conversely, if V does not accuse A despite a false assertion, V’s deposit will be rewarded to A. In other words, the purpose of this system is to make the assertion to be always true via verification even if A makes a false assertion.</p>\n<p>There are two threats we need to consider in order to achieve this goal.</p>\n<ol>\n<li>Bribery attacks</li>\n<li>Verifier’s laziness</li>\n</ol>\n<p>A bribery attack means that A bribes V in advance not to verify a false claim. It can be resolved relatively easily by increasing the value of the collateral of A and V, or by increasing the number of stakeholders.</p>\n<p>The verifier’s laziness literally means that V decides not to verify A’s claim. If V does not verify the claims, A can continue to claim falsehood as much as possible. Unlike a bribery attack, the verifier’s laziness is difficult to solve by simply increasing the value of the collateral or the number of stakeholders. Let’s dive deep into the reasons below.</p>\n<p>In order to prevent the verifier’s laziness, first it is necessary to understand how the verifier chooses the verification or non-verification strategy. The expected payoff of each strategy under the following conditions is as follows:</p>\n<ul>\n<li>R = A’s Deposit, if A claims false and V succeeds in verification, is rewarded to V.</li>\n<li>L = V’s deposit, if A claims false and V fails to verify it, it is awarded to A.</li>\n<li>X = Probability of attack by A</li>\n<li>C = Verification cost</li>\n</ul>\n<ol>\n<li>Expected payoff of verification: R*X-C</li>\n<li>Expected Payoff of non-verification: -L*X</li>\n</ol>\n<p>We can observe that if V’s verification payoff is greater than the non-verification payoff <strong>(R*X- C &gt; -L*X)</strong>, V will always verify A’s assertion.</p>\n<p>In other words, if <strong>X &gt; C/(R+L)</strong>, we can prevent the verifier’s laziness. However, if <strong>X &lt; C/(R+L)</strong>, V will not verify A’s claim (If the two terms are the same, the expected payoff becomes indifferent. i.e. V may or may not verify A’s claim).</p>\n<p>It seems like what needs to be done is to <strong>make X bigger than C/(R+L)</strong>. Then V will always verify A’s claims and this simple system will always remain secure!</p>\n<p>However, the problem remains that X means A’s attack probability, and the <strong>value of X is determined by A</strong>. If A properly adjusts the frequency and timing of attacks so that X is sufficiently low, V will choose not to verify because the verification utility is lower than the non-verification utility. This entails that the security of this simple system could be compromised.</p>\n<p>One could argue that “the system can be more secure if you increase R+L to the maximum, and lower the effective X value enough.” In other words, increase the capital requirement of A and V so that they must deposit more on this system. However, this is clearly limited in the following two aspects.</p>\n<ol>\n<li>Regardless of how high the R and L values are, A can calculate the effective attack probability as soon as the value(R, L) is determined in advance. This allows A to still reduce V’s incentives for verification.</li>\n<li>Raising the capital will limit the participation since it increases the barrier to entry to participate in the system.This will soon have a very negative impact on the introduction and expansion of the system.</li>\n</ol>\n<p>Another idea is that increasing the number of verifiers can solve this dilemma. <strong>Simply increasing the number of verifiers is very helpful in preventing bribery attacks; however, it has rather negative effects on solving the verifier’s laziness.</strong></p>\n<p>The reason it assists in preventing bribery attacks is that the asserter (A) must pay each verifier (V) a reward greater than R in order to bribe the verifier. If the number of verifiers is N, and the total profit obtained by claiming falsehood is M, then all verifiers can be bribed only if M/N &gt; R. Therefore, the larger the N, the more difficult it is for the asserter to carry out a bribery attack.</p>\n<p><em>Theoretically, we can ensure that rollup is secure if there is only one verifier in it, but on the contrary, since it can be vulnerable to bribery attack if there are only a few active verifiers, it is very important to have as many active verifiers as possible.</em></p>\n<p>Conversely, increasing the number of verifiers is not very helpful in preventing the verifier’s laziness because when the number of verifiers increases, the expected payoff of non-verification remains the same, while <strong>the expected payoff of verification strategy decreases in proportion to the number of verifiers.</strong> For example, if there are two verifiers and they all succeed to verify, the reward R will be divided by any ratio (K), which will be a lower amount than the reward R when there is only one verifier (R/K).</p>\n<p>According to this simple model, the verifier’s dilemma is a fairly complex problem, and solving it seems quite difficult. However, this model doesn’t exactly imitate the rollup. Could this be solved in rollup? Let’s take a closer look at this in the next chapter.</p>\n<h3>Super-Simple Model in Optimistic Rollup</h3>\n<p>Based on the simple model discussed above, let’s construct a Super-Simple Model in the rollup and see which problems arise in the rollup regarding the verifier’s dilemma. In fact, there won’t be many changes from the previous model. The asserter becomes a sequencer (S), and the verifier (V) remains the same. In this case, it is assumed that the verifier is the stakeholder of the rollup. In other words, a verifier is someone who has certain economic/non-economic assets in the rollup, or who periodically obtains certain economic/non-economic returns through the rollup.</p>\n<p>At this time, the expected payoff for verification and non-verification of V under the following conditions are as follows.</p>\n<ul>\n<li>R = S’s deposit; V is rewarded with R when V succeeds in verification.</li>\n<li>L = V’s assets deposited in the rollup; S is rewarded with L if V fails to verify.</li>\n<li>X = Probability of attack by S</li>\n<li>C = Verification cost</li>\n<li>F = The revenue that V earns per verification unit (e.g. when V receives a constant revenue for each transaction T in the rollup, this is called F)</li>\n</ul>\n<p><em>However, R,L &gt; F &gt; C &gt; 0.</em></p>\n<p>Also, for convenience, it is assumed that F is not accumulated in L. These assumptions will apply equally to all models that will be covered later.</p>\n<ol>\n<li>Expected payoff of verification: R*X + F -C</li>\n<li>Expected payoff of non-verification: -L*X + (1-X)F</li>\n</ol>\n<p><em>Note that even without verification, the verifier can still earn F if the sequencer does not attack.</em></p>\n<p>In this case, just like in the previous Super-Simple Model, if the verification payoff is greater than the non-verification payoff, the verifier will always have an incentive to verify. If the sequencer’s attack probability is as follows, the verifier will always choose the verification strategy.</p>\n<ul><li><strong>X &gt; C/(R+L+F)</strong></li></ul>\n<p>What’s different from the previous model is that only F is added to the denominator. This may have the effect of slightly reducing the sequencer’s attack probability, but the fundamental problem remains the same.</p>\n<p>In other words, it is visible that the <strong>verifier’s strategic choice still depends on the sequencer’s attack probability</strong>, and this does not change much even when considering the new variable, the constant return (F) the verifier gets per verification unit. This is because if the sequencer attacks very intermittently or does not attack, the verifier can continue to earn full returns without paying the cost of verification.</p>\n<p>How can we solve this problem? It has already been debated that R and L, i.e. how to increase capital requirements, have clear limits. One option we can think of is that the rollup can maintain the security of the system if only one verifier performs the verification correctly. If that is the case, if we change the number of verifiers from simple models to extended models, we could expect that at least one of them will verify. If so, can we ensure security of the rollup?</p>\n<h3>Multiple Verifiers</h3>\n<p>Before we start increasing the number of verifiers (N), let’s begin with a very simplified model with only two verifiers (V1 and V2) and a sequencer (S). In this case, the expected payoff of verification and non-verification of each verifier can be notated as follows under the conditions below.</p>\n<ul>\n<li>R = S’s deposit; V is rewarded with R when V succeeds in verification.</li>\n<li>L = Assets of V(N) deposited in the rollup; S is rewarded with L when V fails verification. (It is assumed that the two verifiers have the same L.)</li>\n<li>X = Probability of attack by S</li>\n<li>Y = The probability that the opponent verifier will verify (e.g., in terms of V1, if V1 is sure that V2 will always verify, then Y = 1.)</li>\n<li>C = Verification cost</li>\n<li>F = Revenue V(N) receives per verification unit (assuming that the F of both verifiers is the same.)</li>\n</ul>\n<p><em>However, R, L &gt; F &gt; C &gt; 0</em></p>\n<ol>\n<li>Expected payoff of verification: R*X + F-C</li>\n<li>Expected payoff of non-verification: -L*X(1-Y) + F*(1-X(1-Y))</li>\n</ol>\n<p>The expressions for verification and non-verification have become quite complex, but if you grasp what the newly added part (1-Y) means, you can understand it more intuitively. The most significant feature of the rollup is that even if you don’t verify the rollup on your own, your assets could be kept safe if someone else verifies it. In other words, if Y is 1 or close to 1, it means that the other verifier will verify S, which indicates that even if you do not verify it yourself and the sequencer always attacks (X = 1), all of your assets, and additional economic interests can be preserved.</p>\n<p>If so, it is questioned whether either or both of the verifiers will verify. To explore this more intuitively, let’s use a very simple game theoretic approach.</p>\n<p>The expected payoff of the two verifiers’ choice of verification and non-verification strategies can be expressed in the payoff matrix as follows.</p>\n<p>It is assumed that the reward R obtained when both verifiers succeed in verification is divided by the same ratio.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JQF4tUx0vufkmNfF"></figure><p>The Nash equilibrium in this game will depend on the value of each variable. For example, if the attack probability of a sequencer is high, and the expected verification reward is even higher, the equilibrium is for both verifiers to verify (V, V). If the attack probability is very low and the expected loss of non-verification is not significant, the equilibrium is for both verifiers not to verify (NV, NV). In addition, when the attack probability is neither very high nor very low, the equilibrium is for only one verifier to verify (V, NV) (NV, V). This can be expressed as follows.</p>\n<ol>\n<li>(V, V): X &gt; 2C/R</li>\n<li>(V, NV) (NV, V): 2C/R &gt; X &gt; C/(R+L+F)</li>\n<li>(NV, NV): X &lt; C/(R+L+F)</li>\n</ol>\n<p>Let’s look at each case through a simple example. In this example, it is assumed that the values of the variables other than X are as follows.</p>\n<ul>\n<li>R = 100</li>\n<li>L = 100</li>\n<li>F = 5</li>\n<li>C = 1</li>\n</ul>\n<p>In this case, assume that the attack probability X is greater than 2C/R = 0.02, which means X = 0.05.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*NjAlS77vPIX5-kCO"></figure><p>In this case, since the verification strategy for both verifiers is a dominant strategy, the equilibrium is (V, V). This is a very desirable situation, but since it is assumed that the sequencer’s attack probability is very high, in reality, this situation won’t occur easily.</p>\n<p>Next, suppose that X is less than 2C/R = 0.02 and greater than C/(R+L+F) = 0.0049, which means X = 0.005.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*OP7ADdGO3Mj-0Blt"></figure><p>Interestingly, when both verifiers choose the same strategy, they can’t maximize their payoff. i.e. choosing different strategies is the equilibrium.</p>\n<p>For example, if verifier 2 chooses the verification strategy, verifier 1 will choose the non-verification strategy and if verifier 1 chooses the verification strategy, verifier 2 will choose the non-verification strategy. With similar logic, if verifier 2 chooses the non-verification strategy, it is most reasonable for verifier 1 to choose the verification strategy and if verifier 1 chooses the non-verification strategy, then verifier 2 chooses the verification strategy.</p>\n<p>In other words, there are two equilibria in this game, (NV, V) and (V, NV). So, which equilibrium is chosen in this game? This is determined by factors such as pre-commitment, and credibility. For example:</p>\n<p>Let’s say that verifier 2 has chosen the non-verification strategy. Verifier 2 openly affirms to verifier 1, “I do not have equipment with the requirements necessary for verification, so I will not verify at all in the future.” However, verifier 1 currently has all the required equipment for verification. The most rational option that verifier 1 can choose in this case would be the verification strategy which will offer a relatively higher expected reward for a small verification cost, rather than a non-verification strategy for no cost at all. we can see that at some point where X is neither high enough nor low enough, only one of the two verifiers will choose the verification strategy.</p>\n<p>Finally, suppose that the X is less than C/(R+L+F) = 0.0049, which means X = 0.0001.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*z1YNMA-uHx0V4Qhp"></figure><p>In this game, the equilibrium is (NV, NV) because the non-verification strategy is the dominant strategy for both verifiers. As we continue to emphasize, the sequencer can acquire<strong><em> </em></strong>information about each variable in advance, so that the effective attack probability can be easily calculated. Therefore, the sequencer will attack with the probability that not even one verifier will choose a verification strategy. In other words, if the sequencer attacks, it will attack with a lower probability than C/(R+L+F).</p>\n<p>In summary, even in a model in which the number of verifiers is increased to two, each verifier chooses the verification or non-verification strategy according to the attack probability of the sequencer, and as the attack probability decreases, the number of verifiers who choose the verification strategy decreases. This does not change considerably even if the number of verifiers is increased to N. As the number of verifiers increases, the amount of expected verification rewards will decrease, and even if the probability of attack is not very low, the number of verifiers who continue to choose the verification strategy will decrease because only one verifier who chooses the verification strategy can protect all other users’ assets and interests. In addition, when the probability of attack is very low, even one verifier will not choose the verification strategy.</p>\n<p>This is a very shocking result. <strong>Regardless of the number of verifiers, the more safely the rollup operates over the long term, the more active verifiers will continue to decrease and converge to zero.</strong></p>\n<h3>Is There No Verifier’s Dilemma in Optimistic Rollup?</h3>\n<p>Despite the fact that the rollup has several issues with security due to the verifier’s dilemma as discussed above, <strong>there is an argument that the verifier’s dilemma in the rollup is just a trivial issue, and there is no need to implement an additional mechanism to deal with it. To begin with, some parts of this argument are valid, and some are not.</strong> In general, the rationale behind the argument; it is not necessary to take into account the verifier’s dilemma in the rollup, can be summarized into four main reasons.</p>\n<ol>\n<li>Token Holder</li>\n<li>Dapp Builder — We can substitute it with all participants who earn a certain amount of revenue (e.g Yield farming) per L2 transaction.</li>\n<li>Altruist</li>\n<li>Fast Withdrawal</li>\n</ol>\n<p>Let’s examine each reason in the above mentioned in order and see if they can actually help to solve the verifier’s dilemma.</p>\n<h3>Token Holder</h3>\n<p>The first reason it’s not necessary to take into account the verifier’s dilemma in the rollup is that users with many tokens (or assets) in Layer 2 will have a high incentive to perform verification.</p>\n<p>However, users with many tokens are basically just verifiers with a relatively high L in the simple model discussed above. Therefore, this has no other meaning than slightly lowering the sequencer’s attack probability.</p>\n<p>One thing to note here again is that simply increasing L, which is the amount of assets deposited by the verifier in the rollup, or increasing the sequencer’s deposit R, is not very helpful in solving the verifier’s dilemma.</p>\n<h3>DApp Builder</h3>\n<p>Another reason is that, if a DApp is operated in a rollup, the rollup must be operated safely to ensure continuous profits for the DApp operator, so the incentive for verification of stakeholder of that DApp will be high. However, this is also discussed previously. Despite the fact that the revenue (F) per verification unit is high, it can be safely earned regardless of verification, if the sequencer does not attack. i.e. the verification strategy is also chosen according to the attack probability of the sequencer. In other words, even though the builder of the DApp makes huge profits by operating a large DApp, this does not lead to a guarantee that the builder will always verify the rollup.</p>\n<h3>Altruist</h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/589/0*guU9Qaxs4Wo5X5Yv"><figcaption>source: <a href="https://twitter.com/gakonst/status/1353695113860370436">twitter</a></figcaption></figure><p>The next reasoning is <a href="https://en.wikipedia.org/wiki/Altruism">altruism</a>. Not everyone in this world is always selfish and makes choices that maximize only their own interests. If so, numerous actions such as philanthropic donations and charities won’t exist (of course, this can also be explained as having a greater non-economic utility than the economic cost of donating or serving).</p>\n<p>In short, the point of the argument is that even though verification is an economic loss, someone who is altruistic in this ecosystem would verify the rollup anyway. For example, there are people who do not earn any mining rewards on the Bitcoin or Ethereum network, but store all the block data, and propagate it to other nodes. They do not get any economic benefits from this behavior, but they do it altruistically for no economic gain.</p>\n<p><em>However, this also can lead to an issue. The fact that the </em><a href="https://www.google.com/amp/s/decrypt.co/24779/ethereum-archive-nodes-now-take-up-4-terabytes-of-space%3Famp%3D1"><em>number of Ethereum archive nodes is too small</em></a><em> is a problem that has been frequently raised. As Ethereum blocks increase, state data continues to grow at a rapid pace, and in the long run it is unsustainable to simply expect altruistic participants to maintain archive nodes without any incentives.</em></p>\n<p>While this seems to make sense at first glance, it should be noted that we are searching for an approach to resolve or mitigate the verifier’s dilemma. In other words, altruistic verifiers are very helpful from the point of view of the entire network when the rollup is actually operated, but when designing any mechanism or tool to ensure the security of the network, they can neither be the rationale nor the basis of that mechanism.</p>\n<p>Let’s assume you are the architect of Ethereum. How would you respond if someone asks you the question; what can we do when the incentive to record and store block data is not clear? If the answer is that there are altruistic people in the world and these people will somehow store all the data, it would not be a convincing answer.</p>\n<p>Vitalik Buterin also argued in <a href="https://vitalik.ca/general/2021/01/05/rollup.html">his article</a> that we need more explicit reasoning to design verification incentives for rollup as mentioned below:</p>\n<p><em>Auditing incentives — how to maximize the chance that at least one honest node actually will be fully verifying an optimistic rollup so they can publish a fraud proof if something goes wrong? For small-scale rollups (up to a few hundred TPS) this is not a significant issue and one can simply rely on altruism, </em><strong><em>but for larger-scale rollups more explicit reasoning about this is needed.</em></strong></p>\n<h3>Fast Withdrawal</h3>\n<p>The last claim is fast withdrawal. To understand why fast withdrawal is presented as the basis for the claim, that it is not necessary to consider the verifier’s dilemma, we first need to figure out what fast withdrawal is.</p>\n<p>Fast withdrawal is an alternative way to withdraw tokens from L2 to L1 so that users can avoid the long withdrawal time due to the DTD (Dispute Time Delay) in rollup. Fast withdrawal simply works like this when users want to withdraw some amount of tokens from layer 2 to layer 1, an intermediary buys these tokens in layer 2 and sends them to the user in layer 1 except for the fast withdrawal fee.</p>\n<p>Let’s take a closer look at fast withdrawal with an example.</p>\n<ol>\n<li>Alice wants to withdraw 10 ETH from L2 to L1 paying a fee of 0.1ETH.</li>\n<li>Alice transfers 10 ETH to the fast withdrawal market contract.</li>\n<li>Ivan confirms and verifies the withdrawal request and sends 9.9 ETH from L1 to Alice.</li>\n<li>After the DTD required for the withdrawal, Ivan will acquire 10ETH in the market contract of L2.</li>\n</ol>\n<p>The important point here is that in the process of fast withdrawal, Ivan verifies whether Alice’s withdrawal is a valid request or not. This means that Ivan actually verifies the states of rollup are correctly configured. A problematic point in the verifier’s dilemma was that the verifier’s verification rewards depended on the probability of attack by the sequencer. <strong>However, in the case of fast withdrawal, Ivan seems to have an incentive to verify regardless of the sequencer’s attack behavior!</strong></p>\n<p>Based on this, let’s define the expected payoff of Ivan according to the Super-Simple Model.</p>\n<p>First, let’s assume that there are already a number of general verifiers(N) other than Ivan in the rollup. Assuming that fee of fast withdrawal is F, Ivan’s expected payoff for verification is as follows.</p>\n<ol>\n<li>Expected payoff of verification: R*X + F-C</li>\n<li>Expected payoff of non-verification: -L*X + (1-X)F</li>\n</ol>\n<p>What’s interesting here is that unlike for the other verifiers in the rollup, the fact whether or not the remaining verifiers have verified, does not affect Ivan’s expected payoffs.The reason for this is the special nature of fast withdrawal; Ivan has to transfer his tokens in L1 as soon as possible after receiving the fast withdrawal request from Alice. <strong>However, if Alice’s withdrawal request was found to be invalid by another verifier during the DTD, Ivan will not be able to get his tokens back.</strong> This is because tokens in L1 have already been transferred to Alice. In other words, in order for Ivan to safely process a fast withdrawal, he must verify by himself rather than relying on other verifiers.</p>\n<p>This is an interesting fact; if there are only two verifiers in the rollup and one is a fast withdrawal intermediary like Ivan, and the other is a general verifier (e.g token holder, DApp operator, etc.), then Ivan is more likely to choose a verification strategy than other verifiers. Let’s take a closer look at this through the following payoff matrix.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Z-3BxltGTz-YjkXs"></figure><p>As mentioned earlier, even if the opponent verifier chooses the verification strategy, when the sequencer attacks via a fast withdrawal, it is impossible for Ivan to effectively defend the sequencer’s attack and protect his assets. Therefore, the expected payoffs of Ivan are equally -L*X+(1-F)X. This implies that if only one of the two participants, Ivan or the opponent verifier, must choose a verification strategy (similar to the situation where the attack probability of the sequencer is neither very high nor low in a model with two general verifiers), Ivan has a higher incentive to choose a verification strategy than the opponent verifier.</p>\n<p>More specifically, when 2C/R &gt; X &gt; C/(R/2+L+F), the equilibrium becomes (V, NV). <em>Under the same conditions in the model of only two verifiers, the </em>equilibrium <em>was (V, NV) (NV, V).</em> Specifically, in a situation where the probability of attack is neither high nor low, Ivan will always choose the verification strategy, and the opponent verifier will always choose the non-verification strategy. Let’s look at this through a specific example.</p>\n<p>Under the conditions below, the payoff matrix of Ivan and the verifier is composed as follows.</p>\n<ul>\n<li>R = 100</li>\n<li>L = 100</li>\n<li>F = 5</li>\n<li>C = 1</li>\n<li>X = 0.007</li>\n</ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*wzzJJ2LaCvvnUDXh"></figure><p>Had Ivan been a general verifier, in this case the equilibrium would have been (V, NV) (NV, V). However, since Ivan is the intermediary of fast withdrawal, the verification strategy is the dominant strategy. Therefore, the other verifier will always choose the non-verification strategy and (V, NV) will become the equilibrium.</p>\n<p>In summary, <strong>it can be seen that under the same conditions, intermediaries of fast withdrawals have a higher incentive to verify than general verifiers.</strong> If someone does verify, it is very likely that it is an intermediary of fast withdrawal. However, this does not prove that Ivan will always choose the verification strategy.</p>\n<p>Again, it is true that Ivan’s incentive to choose a verification strategy is relatively large, but in practice, the probability of the sequencer’s attack is taken into consideration when making this strategic choice. Therefore, what we need to focus on now is to find out exactly under what criteria a fast withdrawal intermediary will make such a strategic choice, and what factors are needed to make sure this intermediary chooses a verification strategy. Let’s look at this in detail in the next chapter.</p>\n<h3>Fast Withdrawal and Auditing Incentives</h3>\n<p>In this chapter, we will take a closer look at how Ivan chooses between a verification and non-verification strategy for rollup, which variables will affect that decision, and furthermore, what additional mechanisms are needed to ensure that Ivan will always verify the rollup.</p>\n<h3>Attack-Verify Game</h3>\n<p>Let’s compose a simple Attack-Verify Game between Ivan and the sequencer as follows to find out how Ivan chooses the verification or non-verification strategy.</p>\n<p>The only players in this simple game are Ivan and the sequencer. The sequencer will request a fast withdrawal to Ivan, and at this time, the sequencer can choose whether to request a fast withdrawal for valid or invalid tokens. This is called an attack and non-attack strategy.</p>\n<p>Ivan can choose either to verify and transfer the tokens to the sequencer in L1, or transfer it without verification. This is called a verification and non-verification strategy.</p>\n<p>In this game, Ivan and the sequencer have different expected payoffs depending on each other’s strategic choices, which can be specifically represented by the following payoff matrix.</p>\n<ul>\n<li>R: Deposit of the sequencer / Reward given to Ivan upon successful verification</li>\n<li>L: Amount of fast withdrawal / Amount lost by Ivan upon successful attack by the sequencer</li>\n<li>F: Fast withdrawal fee</li>\n<li>C: Verification cost</li>\n</ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*faeqqFttFWohry-q"></figure><p><em>The sequencer’s payoff in non-attack is 0 because the utility obtained from the fast withdrawal is considered to be the same as the paid fee F. Even if this is changed to a different number, the expected payoff of the sequencer (V,NA), (NV,NA) will be the same. It is also difficult to expect a significant difference compared to the expected payoff of (V,A) and (NV,A).</em></p>\n<p>Assuming R,L &gt; F &gt; C, there is no pure strategy Nash equilibrium in this game. Let’s look at this in detail through an example.</p>\n<ul>\n<li>R = 100</li>\n<li>L = 100</li>\n<li>F = 5</li>\n<li>C = 1</li>\n</ul>\n<p>Substituting these values into the payoff matrix table above will give the following result.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-2vKMMoFFx_Ce0uD"></figure><p>There are no dominant and dominated strategies for both Ivan and the sequencer in this game. Also, there is no pure strategy Nash Equilibrium. This is because each player’s strategic choices vary depending on each other’s strategic choices. If the sequencer does not attack, it is advantageous for Ivan not to verify, if Ivan does not verify, it is advantageous for the sequencer to attack and vice versa. This means that, depending on the situation, Ivan and the sequencer will use both strategies, rather than just one strategy.</p>\n<h3>Mixed Strategy Nash Equilibrium</h3>\n<p>So, how do Ivan and the sequencer choose between these two strategies? First we need to understand what mixed strategy Nash equilibrium means.</p>\n<p><em>When using a mixed strategy, given the two strategies, the optimal approach for each player is to choose the strategy that makes the expected payoff of the opponent indifferent between two strategies. In other words, it is to find the point where the expected payoff becomes indifferent no matter what strategy the other party chooses.</em></p>\n<p>If the <strong>probability of Ivan choosing the verification strategy is P,</strong> and <strong>the probability of the sequencer choosing the attack strategy is Q</strong>, then each probability (P, Q) according to the mixed strategy Nash equilibrium are as follows.</p>\n<ul>\n<li>R*P<em> </em>+ L(1-P) = 0*P + 0*(1-P)</li>\n<li><strong>P = L/(R+L)</strong></li>\n<li>(R+F-C)Q + (F-C)(1-Q) = -L*Q + F(1-Q)</li>\n<li><strong>Q = C/(R+L+F)</strong></li>\n</ul>\n<p>By assigning the variable values used in the previous example, the mixed strategy Nash equilibrium can be calculated as below.</p>\n<ul>\n<li>P = 1/2</li>\n<li>Q = 1/205</li>\n</ul>\n<p>To put it another way, once every two turns, Ivan chooses either the verification strategy or the non-verification strategy. In the case of the sequencer, the non-attack strategy is chosen 204 times out of 205 times, and the attack strategy is chosen once. But our goal is to make Ivan choose the verification strategy 100% of the turns, instead of only once every two turns. We also want to reduce the attack probability from 1/205 and converge it to 0. What steps must we take to achieve both goals?</p>\n<p><strong>The most effective way is to increase L.</strong> Increasing L leads to an increase in the probability that Ivan chooses the verification strategy, while reducing the probability that the sequencer chooses the attack strategy. However, increasing R also can lead to a reduction in the attack probability, but simultaneously it decreases the probability of Ivan/verifier choosing the verification strategy. In short, if you are trying to solve the verifier’s dilemma by increasing the capital requirements in rollup, increasing L is the most effective way to achieve it. However, unfortunately there are obvious limitations when it comes to increasing capital requirements. Thus, we need a different approach to solving this.</p>\n<h3>Maximin Strategy</h3>\n<p>Through the mixed strategy Nash equilibrium we found out that Ivan and the sequencer make strategic decisions with a certain probability. However, in reality, will Ivan and the sequencer follow the exact equilibrium when choosing their respective strategies? When both players choose a strategy that maximizes their profits, the additional expected profits become relatively low, while the losses incurred by making the wrong strategic choice in the process become truly catastrophic.</p>\n<p>For example, if Ivan chooses the non-verification strategy, he gets only +1 extra reward if the sequencer doesn’t attack, while he suffers a huge loss of -100 if the sequencer chooses the attack strategy. The sequencer also gains nothing from a non-attack, but the expected loss in the event of a failure of an attack is relatively very high.</p>\n<p><strong>In such an event, players generally tend to pursue security rather than maximizing profits.The strategy that maximizes strategic security is the maximin strategy.</strong></p>\n<p><em>This does not apply only to the game of Ivan and the sequencer. For instance, users who trade and hold cryptocurrency have a variety of strategic choices on how to hold tokens depending on their tendency to deal with risks. When holding and trading cryptocurrencies, generally the most convenient way is to hold them on a centralized exchange(CEX). However, this method carries the risk of losing all of the coins when the exchange is hacked or attacked. Therefore, users who prefer high risks tend to hold and trade cryptocurrency on a centralized exchange, while users who want to avoid high risks use services such as Metamask or hardware wallets instead of a CEX. Additionally, users with extremely high risk aversion tendencies may worry about the cryptocurrency itself, so they operate a full node or an archive node simultaneously. All of these users have the same expected payoff when holding coins on the exchange, but the strategic choice depends on the degree of risk aversion. i.e. it depends on strategic security, not stability.</em></p>\n<p>The maximin strategy is a strategy that yields ‘best of the worst’ outcome for each player. To rephrase, irrespective of the decisions other players make, players maximize the minimum payoff amount.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*PGPWp0VCaL4S_v49"></figure><p>Suppose that in the above example payoff matrix, Ivan and the sequencer follow the maximin strategy, not the Nash equilibrium.</p>\n<p>Ivan’s maximin strategy will be V, the sequencer’s maximin strategy will be NA and the maximin payoff vector of the two players will be (4,0). When following the maximin strategy, Ivan and the sequencer will always choose the verification strategy and the non-attack strategy respectively.</p>\n<p><strong>Thus, we can come to the conclusion that whenever a fast withdrawal is processed, the rollup will be verified if Ivan and the sequencer, or Ivan alone, place the strategic security as top priority.</strong></p>\n<p>However, it is unreasonable to assume that all players prioritize security over stability. This is because each individual player’s disposition will be different from each other. <strong>Therefore, the approach through the maximin strategy may mitigate the verifier’s dilemma somewhat more than before, but it cannot be ensured that it has been completely solved.</strong></p>\n<h3>Fast Withdrawal With Attention Challenge</h3>\n<p>Earlier, we saw that the verifier’s dilemma can be resolved under the assumption that each player gives strategic security a higher priority. However, since this still requires assumptions about the player’s disposition, it has also been discussed that the verifier’s dilemma has not been solved completely, but only somewhat mitigated.</p>\n<p>What additional system would be needed to solve the verifier’s dilemma without having to make assumptions? The reason Ivan does not necessarily choose the verification strategy in the case of fast withdrawal is very simple. This is because the verification strategy is not a dominant strategy.</p>\n<p>Hence how do we make the verification strategy a dominant strategy? This question has a very simple answer: make Ivan’s payoff for the non-verify and non-attack vector (NV, NA) less than or equal to that of the verify and non-attack vector (V, NA). We can achieve this by adopting an Attention Challenge for fast withdrawal.</p>\n<p><em>Attention Challenge is a concept proposed in Ed Felten’s article, </em><a href="https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e"><em>Cheater Checking: How attention challenges solve the verifier’s dilemma</em></a><em>, and is a system that checks whether a specific verifier has verified correctly, at random and periodically. Please refer to the article written by Ed Felten or the Related Research section at the end of this post for details on how the attention challenge works.</em></p>\n<p>Introducing the attention challenge into rollup will work as follows. Note that this is a very simplified explanation.</p>\n<ol>\n<li>The sequencer processes the transactions in the rollup and submits a hash of the state root and a random value so that the verifiers cannot know the exact value.</li>\n<li>Verifiers are selected at random as respondents to the attention challenge without knowing the state root.</li>\n<li>The verifiers who were selected in step 2, have to respond with the state root after processing the transactions the same way as the sequencer.</li>\n<li>If they do not respond within the specified time, or submits an incorrect response, their deposit will be slashed.</li>\n</ol>\n<p>With the attention challenge, the payoff matrix can be changed as follows:</p>\n<ul>\n<li>C = Verification cost + Attention challenge response cost</li>\n<li>A = Ivan’s deposit for attention challenge. If Ivan fails to respond correctly to the challenge, the entire deposit will be slashed.</li>\n<li>P = Probability of Ivan being selected as a respondent for attention challenge</li>\n</ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*8FjQYr3fTwDARmQf"></figure><p>We can easily see that if P*A &gt; C, the verification strategy will be the dominant strategy for Ivan. In other words, if the loss from attention challenge is greater than the verification cost, Ivan will definitely choose the verification strategy. Let’s check this through a specific example.</p>\n<p>Suppose that each variable is as follows.</p>\n<ul>\n<li>R = 100</li>\n<li>L = 100</li>\n<li>F = 5</li>\n<li>C = 2</li>\n<li>A = 50</li>\n<li>P = 0.1</li>\n</ul>\n<p>Then the payoff matrix will be as follows.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Wx41QehVvzo9Yvad"></figure><p>In all cases, The expected payoff of the verification strategy for Ivan is higher than the non-verification strategy. Now the verification strategy is the dominant strategy. The sequencer will always choose the non-attack strategy because Ivan will always choose the verification strategy. Therefore, <strong>the (V, NA) strategy vector is the pure strategy Nash equilibrium, which means that the rollup can always be verified!</strong></p>\n<p><em>By introducing the attention challenge to general verifiers, we can make the verification strategy to be the dominant strategy for all verifiers. However, the nature of the attention challenge requires interacting with L1, so expanding the target and the probability of the attention challenge can be a huge burden at the system level. Details on this will be covered in the </em><strong><em>Trade-Off of Attention Challenge </em></strong><em>section.</em></p>\n<h3>Cross-Rollup Transaction</h3>\n<p>As discussed above, the intermediaries of fast withdrawal will always choose to verify the rollup, if they prefer strategic security, or if we adopt the attention challenge. The interesting fact is that there is another participant in the rollup with the exact same payoff structure as the intermediary of the fast withdrawal. This is the cross-rollup transaction intermediary (hereinafter referred to as the rollup intermediary).</p>\n<p><em>The cross-rollup transaction in this article is based on the concepts covered in the following two articles.</em></p>\n<ul>\n<li><a href="https://ethresear.ch/t/cross-rollup-dex-with-smart-contracts-only-on-the-destination-side/8778"><em>Cross-rollup DEX with smart contracts only on the destination side</em></a></li>\n<li><a href="https://ethresear.ch/t/hop-send-tokens-across-rollups/8581"><em>Hop: Send Tokens Across Rollups</em></a></li>\n</ul>\n<p>Rollup intermediaries can provide fast token transfer services between two rollups in a way similar to the intermediaries of the fast withdrawal. For example, if we have two rollups A, and B, and Alice wants to transfer tokens from A to B through rollup intermediary Ivan, this can be done the following way:</p>\n<ol>\n<li>Alice wants to transfer 10 ETH from rollup A to B paying Ivan a fee of 0.1 ETH</li>\n<li>Alice transfers 10 ETH to a cross-rollup market contract.</li>\n<li>Ivan verifies the cross-rollup transaction request and sends 9.9 ETH to Alice in B.</li>\n<li>After the DTD, Ivan gets 10 ETH deposited in the market contract in A.</li>\n</ol>\n<p>What you can see from this is that only the destinations of the withdrawal and the transfer are changed, from L1 to rollup B, and other aspects have not changed at all. This means that rollup intermediary Ivan also has the same expected payoff for both verification and non-verification as fast withdrawal intermediary Ivan.</p>\n<p>Therefore, the cross-rollup intermediary Ivan’s, and the sequencer’s payoff matrix can be expressed as follows, and it is identical to that of the fast withdrawal broker intermediary, and the sequencer.</p>\n<ul>\n<li>R: Deposit of the sequencer S / Reward given to Ivan upon successful verification</li>\n<li>L: Amount of cross-rollup transfer / Loss of Ivan when the sequencer attacks successfully</li>\n<li>F: Cross rollup transfer fee</li>\n<li>C: Verification cost</li>\n</ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*w3QFbs2HKux5VCDF"></figure><p>Since the two matrices are identical, we can assume that the cross-rollup intermediary Ivan also always chooses the verification strategy based on the maximin strategy, or when adopting the attention challenge.</p>\n<p>This is a very encouraging result as it means that the number of verifiers with relatively high incentives can expand from the fast withdrawal intermediaries to the cross-rollup intermediaries.</p>\n<h3>Trade-Off of Attention Challenge</h3>\n<p>We can force the intermediaries of the fast withdrawal and cross-rollup transfer consistently choose verification strategy by adopting the attention challenge. The attention challenge itself is a mechanism applicable not only to these intermediaries, but also to all other users of the rollup. If we apply the attention challenge in an extended way, it could be a very good strategy to maximize the security of the rollup, as the verification will be the dominant strategy for all verifiers.</p>\n<p>However, it has a couple of blind spots.</p>\n<p>First, since responding to the attention challenge involves <strong>on-chain transactions</strong>, the increased number of targets of the attention challenge results in an increased number of required on-chain transactions. Second, if all users of the rollup have to respond to the attention challenge, the user experience of the rollup can be seriously undermined.</p>\n<p>Let’s discuss the first issue in detail. Expanding the target of the attention challenge inevitably means that the number of respondents to the attention challenge increases. Undoubtedly, as the number of verifiers (N) increases, the probability of being selected as the target of the attention challenge (P) can be decreased, so that the number of responses to the attention challenge can be appropriately adjusted. If then, there will be no problem. However, if P is excessively reduced, the expected loss (-P*A), which can occur if the attention challenge is not properly responded, will also be lowered. This will soon lead to a situation where the attention challenge would not be able to force the verification strategy to always be the dominant strategy. It is still possible to offset this by raising A in this case as well, but it is difficult to regard it as a desirable solution because it implies raising capital requirements. In short, increasing the number of target verifiers means that a larger number of on-chain transactions would be made due to the attention challenge.</p>\n<p>The second issue is that expanding the number of targets of the attention challenge can undermine the rollup’s user experience. The advantage of rollup is that it can operate safely without all users being verifiers, i.e. with at least one honest verifier. Obviously, the more active verifiers the more secure rollup is, but this doesn’t mean that all users should be active verifiers. <strong>To put it in the extreme, making everyone verify the rollup is just as bad as making no one verify the rollup. </strong>This has already been discussed sufficiently when discussing the limitations of Plasma in the Ethereum community, so further explanation will be omitted.</p>\n<p>In other words, we shouldn’t apply the attention challenge to every user. <strong>Most desirable method is to wisely apply the attention challenge to the appropriate targets, tailored to the level of security each rollup wants to achieve.</strong> If fast withdrawals and cross-rollup transactions are actively made, the attention challenge may not need to be applied(assuming that the proportion of intermediaries who choose strategic safety is sufficient). However, there could only be a few fast withdrawals and cross-rollup transactions in the early stage of a rollup, and the number of active verifiers might be too low. In such cases, the attention challenge can be of great help in keeping the rollup secure.</p>\n<h3>Additional Reward to Attention Challenge</h3>\n<p>The attention challenge is a very effective way to maximize security, but it imposes verification as a punishment, a sort of negative feedback to the verifier. The verifier chooses the verification strategy because of the attention challenge, but not only there is no additional reward for this verification, further costs are also incurred during the process. Thus, all verifiers will consider the application of the attention challenge from a negative perspective.</p>\n<p>However, if additional rewards could be paid to verifiers who are targeted for the attention challenge, individual verifiers would be able to mitigate the economic costs incurred by the attention challenge, or even earn more profits from it. For example, suppose there are tokens issued for building an ecosystem of a rollup, some of these tokens could be given as rewards to verifiers participating in the attention challenge. If the amount of rewards is higher than the cost of responding to the attention challenge, verifiers will consider the challenge as a blessing instead of a burden.</p>\n<p><em>We can collect additional fees from the users to pay the verifier as rewards. However, we will have to carefully adjust the amount of the additional fee so that it wouldn’t be a burden to the users.</em></p>\n<h3>Repeated Game</h3>\n<p>The verification games of Ivan and the sequencer so far were all one-shot games. However, many economic activities in the real world are repeated with interactions between the same parties. Likewise, the verification game in the world of rollup is not a one-shot game. Ivan and the sequencer will repeatedly play this game over and over several times. They will make strategic choices for the current stage of the repetitive game, depending on the history of the outcome of their actions before. In this respect, it is necessary to analyze the verification game of Ivan and the sequencer from the point of view of the repetitive game, not simply the one-shot game.</p>\n<p>First, it is well known that in an infinitely repeated game, the equilibrium can be different from one-shot game, or it can even have more than a single equilibrium. This is because it is difficult to deviate from a cooperative strategy, unlike one-shot games, or finitely repeated games. Players in infinitely repeated games usually choose the cooperative strategy in order not to break relationships with other players because the future loss that would occur from revenge attacks from the opponent could be higher than the profit received by deceiving the opponent in the present.</p>\n<p>However, in finitely repeated games, it is challenging to make players choose the cooperative strategy no matter how often the number of repeated games increases. Players in the finitely repeated games with a unique Nash equilibrium choose the same equilibrium of the one-shot game at each stage regardless of how many games are repeated.</p>\n<p>What we should pay attention here is how to categorize this game of Ivan and the sequencer. Before discussing whether the number of repeated games will be infinite or finite, let’s focus on the following question first.</p>\n<p>If the sequencer on one rollup did not execute transactions correctly, what would happen to the sequencer and Ivan (or the other verifiers)?</p>\n<p>First, let’s assume that the attack of the sequencer is verified within the DTD. In this case, the sequencer will lose all or a portion of its deposit and any right they might possess to manage that rollup. Ivan will receive a portion of the sequencer’s deposit as a reward. What will happen to the verification game after that? It ends!</p>\n<p>For our next scenario, let’s assume that the attack was “found” after the DTD. Ivan, who has already sent tokens to the sequencer through the fast withdrawal, checks the tokens that the sequencer gave him in L2 after the DTD, but will soon come to know that they are invalid tokens. At this point, what happens to the sequencer and Ivan? Ivan has already lost his tokens from the fast withdrawal which has not been verified within the DTD, so he will not be able to receive any compensation. What about the sequencer? Although it may differ according to the predetermined rules of each rollup, at least the role of the sequencer will be suspended afterwards, even if the deposit cannot be slashed, and the invalid states cannot be changed to valid ones. In other words, even in this case, the subsequent verification game ends.</p>\n<p><em>If you, as a store owner, discovered after a long time that the clerk had embezzled, would you let the clerk continue to run the store afterwards? If you weren’t an angel, definitely you would fire the clerk even if a long time has passed since, and you cannot be held financially responsible for theft.</em></p>\n<p>From the two scenarios above, we can observe that the moment the sequencer attacks, the repeated games end regardless of whether it is verified or not. Through this, we can see that it is more reasonable to assume that the game will be repeated finitely, although the number of repetitions cannot be accurately known in advance.</p>\n<p><strong>Therefore, it is more rational to define the game of Ivan and the sequencer as a finitely repeated game rather than an infinitely repeated game, and thus it can be seen that the equilibrium in a one-shot game will be repeated at every stage.</strong></p>\n<h3>Related Research</h3>\n<p>As discussed before, the verifier’s dilemma is not a new issue, and it has already been discussed in various areas. Many researchers have already tried to find a solution to it.</p>\n<p>In this chapter, we will examine various solutions proposed to solve the verifier’s dilemma on many different platforms.</p>\n<h3>Forced Error &amp; Jackpot — Truebit</h3>\n<p>In order to understand how the forced error and jackpot concept work, we must grasp a solid concept of what <a href="https://truebit.io/">Truebit</a> is. Truebit is a type of scalability solution that uses off-chain computations. In Truebit, large computation tasks that need an Ethereum block gas limit even higher than current block gas limit, can be executed correctly off chain.</p>\n<p>The participants of the Truebit protocol are largely classified into three types, and the roles and responsibilities that each participant are as follows.</p>\n<p>1. Task Giver</p>\n<ul>\n<li>Requests the solver to execute a complex transaction.</li>\n<li>For requesting a task, the task giver must pay a fee to the solver.</li>\n</ul>\n<p>2. Solver</p>\n<ul>\n<li>Executes a requested task (transaction) off-chain.</li>\n<li>Deposit a certain amount of tokens for acting as a/the solver.</li>\n<li>If it is proved that the execution was invalid, the deposit is slashed.</li>\n</ul>\n<p>3. Verifier</p>\n<ul>\n<li>Verifies that the task has been executed correctly.</li>\n<li>If the task was not executed correctly, the verifier deposits a certain amount of tokens and requests to play a verification game to prove it.</li>\n<li>If the verifier wins the verification game, the solver’s deposit is given as a prize to the verifier.</li>\n</ul>\n<p>What you can see here is that the role of the verifier is crucial for the Truebit protocol to perform safely. This is because, if the verifier does not properly verify that the task has been executed correctly, we cannot ensure that the solver will always execute tasks correctly, and submit only valid results on-chain. Therefore, what we should focus on is whether the verifier in Truebit is always willing to verify or not.</p>\n<p>Those who can read between the lines would assume that the payoff of the verifier in the Truebit protocol would have a similar structure to that of the super-simple game discussed above: this assumption is accurate.</p>\n<p>If the probability of the solver submitting an invalid result is X, then the expected payoff of the verifier in Truebit can be expressed as:</p>\n<ol>\n<li>Expected payoff of verification: R*X-C</li>\n<li>Expected payoff of non-verification: <em>0 (The verifier has no explicit penalty even if he does not verify the solver.)</em>\n</li>\n</ol>\n<p>It is now very obvious that in such a model, it is difficult to grant the incentives for verification. Certainly, the architects of the Truebit protocol were also aware of this. To solve this problem, they introduced Forced Error and Jackpot method.</p>\n<p>The biggest cause of the verifier’s dilemma in Truebit is that the verifier’s reward also depends on the attack probability of the solver. It is the forced error that solves this. The forced error refers to an error that is deliberately, and randomly generated by the system regardless of whether or not the solver attacked. i.e. even if the solver does not attack, a forced error occurs randomly, so the verifier can verify and get rewarded.</p>\n<p>Since the deposit of the solver cannot be used to give rewards for the forced errors, it is necessary to make a new reward pool called the jackpot. Per each request, task givers pay a separate tax in addition to the fee paid to the solver, and this tax is gathered in the jackpot reward pool.</p>\n<p>In short, to collect funds for the jackpot, an additional fee is received from the user, and the reward is distributed to the verifier who successfully verified the forced error that is generated randomly.</p>\n<p>Jackpot rewards are given to any verifier who verifies the forced error within a set period of time. However, because of the sybil attack, which exploits jackpot rewards by creating a large number of duplicate verifier accounts, Truebit has designed a technique to reduce the distribution of rewards exponentially in proportion to the number of accounts that have verified the forced error. The exact jackpot reward distribution is calculated as follows.</p>\n<ul><li>J/2^(k-1) (k = Number of verifier accounts who verified forced error)</li></ul>\n<p>If the probability of a forced error is P, when P*J/2^(k-1) &gt; C, all verifiers always have an incentive to verify. Since the values of P and J are system variables that can be determined by the protocol, unlike the X, Truebit can easily make verifiers verify the solvers at any time.</p>\n<p>The jackpot model has the above advantages, but on the contrary, the following issues also exist.</p>\n<ol>\n<li><strong>Unpredictable rewards</strong></li>\n<li><strong>Charges additional fees to users</strong></li>\n</ol>\n<p>The first issue is that the events of forced errors can only be predicted probabilistically. If you are lucky, you might be rewarded with only one verification, or you might not even be able to receive any reward after hundreds of verifications. The expected reward is predictable, but since the jackpot is like a lottery, there is an inadequate aspect to attract the constant participation of verifiers. For more information on this, please check the <a href="https://www.deconlab.io/simulation-of-truebit-protocol-part-1/">article written by Decon</a>.</p>\n<p>Secondly, in order for the jackpot model to operate as intended, it is essential to collect funds for the jackpot reward pool above all else. If the reward pool isn’t large enough, it won’t be possible to provide proper incentives to verifiers. However, since the whole jackpot reward is borne by the task giver, it means that in order to increase the size of the reward, the task giver must inevitably pay an additional fee.</p>\n<h3>Application to Rollup</h3>\n<p>The forced error and jackpot model has several issues, but it is still valuable in that it can increase the incentive for verification by setting the expected reward for verification higher than the verification cost.</p>\n<p>However, it is not easy to use this to solve the verifier’s dilemma in the rollup because it is not easy to collect additional fees, and the rollup is not suitable for generating the forced error.</p>\n<p>First, collecting additional fees from users could be burdensome to them, and will undermine the UX. As an alternative to this, native tokens issued at the ecosystem level of the rollup can be used for the fund. However, not all rollups can issue these tokens, and since jackpot rewards are completely dependent on the value of the tokens issued in the ecosystem, there may be additional risks in terms of security.</p>\n<p>Secondly, the rollup has a very tricky structure to generate forced errors. In Truebit, the solver has to submit both correct and incorrect solutions to L1. If the forced error needs to be generated, the incorrect solution is designated by the solver, and on the other-hand, if there is no need for a forced error, the correct solution is designated. In Truebit, since the tasks requested by givers are independent and unique tasks, it is not a problem to generate forced errors this way.</p>\n<p>In the case of rollup, if we generate forced error, subsequent transactions must be executed based on the incorrect states. Otherwise, anyone can easily detect that a forced error has occurred. In addition, since the subsequent transactions are executed based on invalid states, all consequent state values will also become invalid.</p>\n<h3>Multiple Solvers — Truebit</h3>\n<p><a href="https://arxiv.org/pdf/1806.11476.pdf">Multiple solvers</a> is a newly proposed method to solve several shortcomings of the jackpot model, and to completely solve the verifier’s dilemma in Truebit. There are three types of participants in the jackpot model; task giver, solver, and verifier, but in the multiple solvers model, there are only the task giver and the solver. It has multiple solvers to prevent any attacks by a small number of malicious solvers.</p>\n<p>In the multiple solvers model, when a task giver asks for a task, a number of solvers randomly selected from the solver pool are assigned to the task. Each solver submits a solution, and a proof of independent execution for the task. Proof of independent execution is the process of proving that each solver has solved the task on its own. <em>How the proof of independent execution generated is described </em><a href="https://arxiv.org/pdf/1806.11476.pdf"><em>here</em></a><em>. </em>This allows each solver to prove that they have not replicated the solutions of other solvers.</p>\n<p>If all solvers assigned to a task do not submit the correct solution, or the proof of independent execution, they can be challenged by another solver, or an external verifier (anyone can still verify even if they are not solvers assigned to the task) and their deposit can be slashed.</p>\n<p>However, if each solver executes the task correctly, they can receive a fee as a reward, and if this fee is higher than the verification cost, it can be said that solvers always have an incentive to execute the task correctly. In other words, the architects of Truebit found that the verification and the process of solving are not inherently different, and resolved the verifier’s dilemma by giving explicit rewards for them.</p>\n<p>However, having multiple solvers results in one fatal drawback: <strong>it is too expensive</strong>. A higher level of security can be guaranteed as the number of solvers assigned to each task increases but it also means that the fees paid to the solvers will inevitably increase.</p>\n<p>Therefore, Truebit allows task givers to pay fees according to the desired level of security. If you require a higher level of security, you can pay a higher fee to get more solvers for the task. Otherwise you can pay a minimal fee to get a few solvers for the task.</p>\n<h3>Application to Rollup</h3>\n<p>The core idea of the multiple solvers is not to separate the solver and the verifier, but to integrate them into one, and to directly reward the action of solving (verifying) the task. To apply a similar method in the rollup, we have to appoint multiple sequencers instead of one, execute transactions independently, and submit the corresponding state root ​​to the layer 1.</p>\n<p>The important point is that in order to keep the rollup as secure as possible, it is necessary to reward the multiple sequencers appropriately. This reward can be accumulated largely by collecting additional fees from users, or by issuing native tokens of the ecosystem to the reward pool. However, for a higher level of security, more fees and token rewards are required, so it is necessary to specifically establish an appropriate level of security and costs.</p>\n<p>Additionally, in the multiple solvers model, transactions on layer 1 for submitting state roots, ​​and the proof of independent execution could be increased linearly as the number of sequencers grows. Note that this may conflict with the main purpose of the rollup, which is to maximize the scalability of layer 1.</p>\n<h3>Attention Challenge — Arbitrum</h3>\n<p><a href="https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e">Attention Challenge</a> is an approach to resolve the verifier’s dilemma by punishing verifiers who do not properly perform verification work. The key to the attention challenge is not to encourage verification by giving additional rewards to the verifier, but to make the task of verification inevitable and inflict significant losses on the verifier if the verification is not performed.</p>\n<p>Let’s refer to the Super-simple model we covered earlier to see in detail how the attention challenge works. In this simple model, there are two participants, the asserter and the verifier. The task of the asserter is to compute a certain function f(x), and submit x, and only the encrypted value of f(x). The verifier’s duty is to check x and submit the correct f(x). If the verifier submits incorrect values ​​or does not respond in time, deposit of the verifier will be slashed.</p>\n<p>For responding to the attention challenge, verifiers must submit transactions on-chain, and this would be a heavy burden on both the layer 1 and the verifier. So, the attention challenge is not consistently applied to each verifier, but only probabilistically. However, it is designed in a way that the verifiers can only check whether they are the target of the attention challenge only after performing the verification work by themselves. Therefore, verifiers always have to do verification to check if they are selected as respondents to the attention challenge.</p>\n<p><em>For technical details on how f(x) is encrypted, and how each verifier checks whether they are selected as respondent to the attention challenge, please check this </em><a href="https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e"><em>article</em></a><em>.</em></p>\n<p>When applying the attention challenge to the super-simple model, the expected verification and non-verification payoff of the verifier are changed as follows.</p>\n<ol>\n<li>Expected payoff for verification: R*X-C</li>\n<li>Expected payoff for non-verification: -L*X -P<em>*</em>A</li>\n</ol>\n<p><em>P is the probability of being designated as the target of the attention challenge, and A is the amount of tokens slashed when an incorrect response is submitted.</em></p>\n<p>If P*A &gt; C, the best strategy for the verifier is to always verify regardless of X. Since values of P and A can be controlled by the system, it can easily force the verifiers to always verify.</p>\n<p>Attention challenges are very attractive, in that they do not incur additional costs for the user, and can make the verifier always perform the verification. However, there is one blind spot in the attention challenge: if the verifier verifies, but the assertor does not perform any attacks, then in all cases, there is only loss for the verifier.</p>\n<p>For example, under the conditions below, the expected payoff of the verifier can be expressed as follows.</p>\n<ul>\n<li>R = 100</li>\n<li>L = 10</li>\n<li>X = 0</li>\n<li>C = 1</li>\n<li>P*A = 5</li>\n</ul>\n<ol>\n<li>Expected payoff for verification = -1</li>\n<li>Expected payoff for non-verification = -5</li>\n</ol>\n<p>In this case, the verifier will perform the verification because the expected payoff to verify (-1) is greater than the expected payoff not to verify (-5). However, there is one <strong>trap</strong>. Whatever choice is made, the verifier faces <strong>pure loss</strong>! In other words, the verifier is in a situation where he suffers a small loss in order to avoid a larger loss. We cannot systematically enforce the verifier to be in such a situation without an alternative. If the verifier wishes, he should have the freedom to abandon the verifier’s role, withdraw the deposit, and leave the system.</p>\n<p>If you were this verifier, what would have been your choice? Would you like to remain in this system and continue verification, awaiting unclear returns, or just give up and leave because there is no reward and only costs for you anyway? It is certain that everyone will choose the latter.</p>\n<p>What we can observe from this example is that attention challenge can lead the verifier to always choose a verification strategy in the short run, but it does not convince the verifier to continue to remain in the system in the long run.</p>\n<p>So, is the attention challenge of no use? Not quite. The attention challenge is very effective in solving the verifier’s dilemma. However, it is effective only when the verifiers can earn a certain amount of profits related to, or not related to the verification work.</p>\n<p>For example, if the verifier earns a constant return F for each verification unit, when F-C &gt; -P*A, it is difficult for the verifier to find a reason not to continue the verification. We know one model in which these conditions can be applied. It is the optimistic rollup!</p>\n<h3>Application to Rollup</h3>\n<p>In the rollup, the role of the verifier is not clearly distinguished, but any user can be the verifier at their will. Some of these users earn a certain profit for each transaction, which is called the verification unit. For example, a user doing yield farming on a rollup, or a developer running a DEX can earn a certain amount of revenue each time a transaction is executed. In these cases, applying the attention challenge can make these users reliably verify the rollup. Details on this matter have already been dealt with previously, so additional explanations will be omitted.</p>\n<h3>Why do I care so much about Verifier’s Dilemma?</h3>\n<p>This article continues to argue that in order to ensure security for all users of the rollup, it is necessary to consider the verifier’s dilemma, and to come up with appropriate solutions. Several reasons for this have been presented above, but there may still be disagreements from the community. This is only a theoretical aspect, and indeed, when rollups are actively adopted and used, the verifier’s dilemma may not be a big problem. There are altruistic people in the world who help others even if they don’t receive monetary incentives. There are also people who choose to give up a little bit of their profit for others rather than maximizing their profit. A similar situation could happen in the rollup too.</p>\n<p><strong>What I would like to suggest in this article is not the fact that the rollup has to be at risk if it doesn’t take the verifier’s dilemma into account. However, if it is not considered in advance, even if it rarely happens, in the event of an unexpected crisis, the security of the rollup “could be at huge risk”.</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ij2Yvb-Au_dsjK8N"><figcaption>(Source: Shutterstock)</figcaption></figure><p>Let’s take our focus away from the rollup for a moment. For example, say we are designing a car for citizens living in a modern city. Since this car will probably only run on well-maintained urban roads, we don’t have to struggle to make it work well in extreme environments. It doesn’t have to be a four-wheel drive, and there’s no need to add expensive shock-absorbing suspensions, as it most certainly won’t fall from high drops. It won’t have to run through the desert, or heavy snow and rains, so we don’t have to consider sand dust, pay much attention to heavy snow and heavy rain conditions. The roads will always be well maintained, so even an ordinary car can run well.</p>\n<p>On the other hand, if we want to design a car that can always run well without any problems in any kind of extreme environment, the story is completely different. If there are not enough safety mechanisms, the lives of the driver and passengers can be seriously threatened in such environments. For this reason, even if the design becomes complex and additional costs are incurred, designing the car to be as safe as possible is a top priority. A car designed in this way, of course, can also be driven in an urban environment perfectly but the various costs and equipment involved in this car may feel a bit unnecessary and excessive for the customers/users. However, this car will do its best when faced with extreme conditions. When there is a sudden heavy snowfall, and all the other cars can’t move, this car will smoothly drive forward without any problems.</p>\n<p>Coming back to the topic of rollup and blockchain, which of these two cars do you think is close to rollup? I trust anyone who believes in blockchain will agree that rollup, along with all blockchain technologies, are closer to the latter in nature. Blockchain technology seeks to <a href="https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274">overcome all extreme environments that the system may face (fault tolerance, attack resistance, collusion resistance) through decentralization </a>as rare as they might be. Rollup is a technology that implements the ability to cope with extreme situations similar to those of Layer 1, and simultaneously increases the insufficient scalability of Layer 1 significantly. Therefore, we need to work hard to ensure that the rollup can cope well with all extreme environments.</p>\n<h3>Conclusion</h3>\n<p>Optimistic rollup is a layer 2 solution that is expected to be able to drastically solve the current scalability issue of Ethereum in the short, medium and even long term. Many types of layer 2 solutions have been proposed to date, and in particular, zk-rollup, powered by validity proof, is in the spotlight since it can provide instant finality, unlike optimistic rollup. However, there are obvious limitations at this point in processing all complex transactions in Ethereum with zk-rollup, so for the time being, the main realistic alternative for Ethereum will be the optimistic rollup.</p>\n<p>In the near future, the optimistic rollup will be widely used and adopted massively. As the number and the size of rollups increase, the security issue will become more and more important. As we continue to emphasize, rollup is a very attractive Layer 2 solution in that the system can be kept secure with just one honest verifier.</p>\n<p>However, as we discussed throughout this article, in rollup, verifiers have a higher incentive to not verify if the attack probability is fairly low. In other words, as the need for the rollup to operate safely increases with time, the number of active verifiers will decrease rapidly. Intermediaries of fast withdrawal and cross-rollup transfer are no exception. In short, the rollup will, paradoxically, become more vulnerable as it gets safer. But we know one solution; the proper application of the attention challenge. We can ensure the security of the rollup via the attention challenge.</p>\n<p>Certainly, this article does not insist that the attention challenge must be applied to all rollups. There will be a different target level of security for each rollup, and there will be assumptions about the disposition of the participants. If it is not necessary to guarantee high security, or if the proportion of altruist and extremely risk-averse participants is considered to be high enough, it is not necessary to apply the attention challenge. The important concept here is using only the necessary and appropriate tools for each purpose. I hope this article will guide you even a little when designing the security of each rollup.</p>\n<h3>Glossary</h3>\n<ul>\n<li>Sequencer: Determines the order of transactions in the optimistic rollup, and submits state roots ​​and transaction data to layer 1 after executing those transactions on layer 2. Also called as Operator.</li>\n<li>Verification: In optimistic rollup, refers to verifying that the state root submitted by the sequencer is valid or not.</li>\n<li>Verifier: An entity who performs the verification. In the optimistic rollup, any participant can be a verifier.</li>\n<li>DTD (Dispute Time Delay): Refers to the period of time required for a state root or an execution result to be finalized in the fraud proof system.</li>\n<li>Fraud Proof: Refers to a set of systems which assumes that the result of execution is correct first, and then provides a way to verify that the result value is correct within a certain period of time (DTD).</li>\n<li>Validity Proof: Refers to a system which proves that the result of execution is correctly configured. No DTD is required for validity proof.</li>\n<li>Attack: Usually means taking an economic advantage by submitting an incorrect state root, or execution result to layer 1. In optimistic rollup, the sequencer can take over assets from users by inducing finalizations of incorrect state roots.</li>\n<li>Challenge: Refers to a set of steps to change an incorrect state root or execution result to a correct one via fraud proof. In the optimistic rollup, anyone can apply for a challenge to prove that the state root submitted by the sequencer is invalid.</li>\n</ul>\n<h3>References</h3>\n<ul>\n<li><a href="https://eprint.iacr.org/2015/702.pdf">https://eprint.iacr.org/2015/702.pdf</a></li>\n<li><a href="https://medium.datadriveninvestor.com/cryptonomics-understanding-the-vertifiers-dilemma-in-crypto-assets-30c65259865b">https://medium.datadriveninvestor.com/cryptonomics-understanding-the-vertifiers-dilemma-in-crypto-assets-30c65259865b</a></li>\n<li><a href="https://medium.com/offchainlabs/the-cheater-checking-problem-why-the-verifiers-dilemma-is-harder-than-you-think-9c7156505ca1">https://medium.com/offchainlabs/the-cheater-checking-problem-why-the-verifiers-dilemma-is-harder-than-you-think-9c7156505ca1</a></li>\n<li><a href="https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e">https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e</a></li>\n<li><a href="https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e">https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e</a></li>\n<li><a href="https://offchainlabs.com/Arbitrum_Rollup_Whitepaper.pdf">https://offchainlabs.com/Arbitrum_Rollup_Whitepaper.pdf</a></li>\n<li><a href="https://www.deconlab.io/simulation-of-truebit-protocol-part-1/">https://www.deconlab.io/simulation-of-truebit-protocol-part-1/</a></li>\n<li><a href="https://medium.com/decon-lab/simulation-of-truebit-protocol-part-1-9a126280172f">https://medium.com/decon-lab/simulation-of-truebit-protocol-part-1-9a126280172f</a></li>\n<li><a href="https://www.deconlab.io/simulation-of-truebit-protocol-part-2/">https://www.deconlab.io/simulation-of-truebit-protocol-part-2/</a></li>\n<li><a href="https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf">https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf</a></li>\n<li><a href="https://github.com/TruebitProtocol/wiki">https://github.com/TruebitProtocol/wiki</a></li>\n<li><a href="https://people.cs.uchicago.edu/~teutsch/papers/stableCPU.pdf">https://people.cs.uchicago.edu/~teutsch/papers/stableCPU.pdf</a></li>\n<li><a href="https://medium.com/truebit/truebit-the-marketplace-for-verifiable-computation-f51d1726798f">https://medium.com/truebit/truebit-the-marketplace-for-verifiable-computation-f51d1726798f</a></li>\n<li><a href="https://arxiv.org/pdf/1806.11476.pdf">https://arxiv.org/pdf/1806.11476.pdf</a></li>\n<li><a href="https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf">https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf</a></li>\n<li><a href="https://research.paradigm.xyz/rollups">https://research.paradigm.xyz/rollups</a></li>\n<li><a href="https://vitalik.ca/general/2021/01/05/rollup.html">https://vitalik.ca/general/2021/01/05/rollup.html</a></li>\n<li><a href="https://www.youtube.com/watch?v=wcCHlqgGSH4">https://www.youtube.com/watch?v=wcCHlqgGSH4</a></li>\n<li><a href="https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788">https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788</a></li>\n<li><a href="https://medium.com/offchainlabs/meva-what-is-it-good-for-de8a96c0e67c">https://medium.com/offchainlabs/meva-what-is-it-good-for-de8a96c0e67c</a></li>\n</ul>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=cb23e6e6f11c" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/optimistic-rollup-is-not-secure-enough-than-you-think-cb23e6e6f11c">Optimistic Rollup is Not Secure Enough Than You Think[EN]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                content:
                  '\n<h3><strong>Optimistic Rollup is Not Secure Enough Than You Think — Game Theoretic Approach for More Verifiable Rollup[EN]</strong></h3>\n<h3><strong>Intro</strong></h3>\n<p><em>Special thanks to Vitalik Buterin, Ed Felten for their insight, and Kevin, Lakmi for feedback and reviews.</em></p>\n<p><a href="https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/optimistic_rollups/">Optimistic rollup</a> (hereinafter referred to as rollup) is a layer 2 solution that burst on the Ethereum community which was struggling to solve the problem of <a href="https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/plasma/">Plasma</a>. The biggest advantage of rollup is that unlike plasma, <a href="https://medium.com/starkware/validity-proofs-vs-fraud-proofs-4ef8b4d3d87a">Fraud Proof</a> ensures security for all users without monitoring rollup, if they have at least one honest verifier. This was a major factor in gaining the full support of the Ethereum community, despite the downside that rollup sacrifices scalability significantly compared to Plasma.</p>\n<p>Rollup is a very attractive Layer 2 that can operate safely with literally only one Honest Verifier. But since we, living in the blockchain world, are very suspicious people, the question arises as to whether we can be sure that the rollup truly functions safely. In fact, these questions are not very new. With the concept of Verifier’s Dilemma, for quite some time, many researchers have been discussing whether verification can be performed accurately for various fields that require verification. Similar discussions have been made about the rollup, and opinions on this matter consist largely of two divisions. One argues that <a href="https://research.paradigm.xyz/rollups">we don’t have to consider the verifier’s Dilemma ‘at all’</a> in rollup, while the other argues that <a href="https://vitalik.ca/general/2021/01/05/rollup.html">we must take into account the verifier’s Dilemma in rollup</a> for safe long-term operations.</p>\n<p>Which opinion is correct? From the point of view of the user, not the designer, can we really safely use rollup? What should we do if it’s definitely not safe? This article addresses all these questions, and provides a concrete method on which direction to go in the long run to ensure the security of rollup.</p>\n<p><em>All of the discussions covered in this article can be applied to any scalability solution that uses Fraud Proof, as well as any Optimistic rollup.</em></p>\n<h3>Verifier’s Dilemma</h3>\n<p>There are other concepts that must be addressed before solving the issue of rollup security, main of which is the verifier’s dilemma mentioned above. In general, the verifier’s dilemma is a series of problems that occur when one participant performs some operation in the blockchain and another participant verifies the work to maintain the safety of the network or protocol, but the utility of verification is unclear.</p>\n<p>The concept of verifier’s dilemma which was first discussed in <a href="https://eprint.iacr.org/2015/702.pdf">this article</a>, can be easily explained as follows. In blockchains such as Bitcoin and Ethereum, when the miner who mines the next block propagates the block to other nodes in the network, all other nodes verify the validity of the block. This is the original intention of the PoW consensus, and in terms of the safety of the network, it is desirable that all other nodes that have synchronized the block must verify it. However, since the computing power of individual nodes is finite, it might be more profitable to allocate it for the task of mining the next block instead of verifying complex transactions. Of course, you will have to take the risk that a block whose ancestor is an invalid block cannot be accepted by the network. Therefore, individual nodes are constantly in an impasse whether it is more advantageous to perform verification or to focus only on mining without verification.</p>\n<p>This verifier’s dilemma can be applied in a similar way for rollups. In rollup, after the sequencer executes the transactions in Layer 2, it only submits a root of the states ​​and corresponding transaction data to Layer 1.</p>\n<p><em>The sequencer or operator is responsible for determining the order of the users’ transactions in the rollup, and submitting them to Layer 1. In this article, we will use the term sequencer.</em></p>\n<p>The rollup prevents the sequencer from submitting incorrect state values at this time with <a href="https://medium.com/starkware/validity-proofs-vs-fraud-proofs-4ef8b4d3d87a">Fraud Proof</a>, and Dispute Time Delay (DTD). All users inside and outside of the rollup can be verifiers, and they can prevent invalid states from being finalized with fraud proof in DTD.</p>\n<p>If fraud is proven by the verifier, the deposit of the sequencer will be rewarded entirely or partially to the verifier. However, one problem arises here. What if the sequencer always submits the correct values? No matter how much verification work the verifier performs, he wouldn’t be able to prove any fraud and soon would lose the incentive for verification. However, one might say it was the original intention, for the security of rollup that the sequencer always submits only correct values to Layer 1, but let’s see why this is a problem.</p>\n<ol>\n<li>The verifier always verifies the state root submitted by the sequencer.</li>\n<li>If the sequencer submits an incorrect value, the deposit will be slashed by the fraud proof, so it will continue to submit only the correct state roots.</li>\n<li><strong>The verifier cannot be rewarded for verification work because the sequencer continues to submit only the correct values. Therefore, he would stop further verification.</strong></li>\n<li>Since the verifier has stopped verification, the sequencer has a strong incentive to attack the rollup and take over the assets of the users.</li>\n</ol>\n<p>In short, since the economic incentive for verification is strongly dependent on the sequencer’s attack behavior, the less the sequencer attacks, (i.e. the safer the rollup is,) the less the incentive for verification is. This is paradoxical, because the safer the rollup is, the more dangerous it is; and the more dangerous it is, the safer it is. According to this logic, at a glance, the verifier’s dilemma appears to be a factor that could seriously jeopardize the security of the rollup. Is the verifier’s dilemma really a threat to the rollup? Let’s dig deeper in the next section.</p>\n<h3>Super-Simple Model</h3>\n<p>To understand and solve a complex concept or problem, the best way is to always simplify the problem. Therefore, before discussing the verifier’s dilemma of the rollup in earnest, we will first look at the Super-Simple Model, which is a very simplified version of it.</p>\n<p><em>The Super-Simple Model is based on Ed Felten’s article </em><a href="https://medium.com/offchainlabs/the-cheater-checking-problem-why-the-verifiers-dilemma-is-harder-than-you-think-9c7156505ca1"><em>The Cheater Checking Problem: Why the Verifier’s Dilemma is Harder Than You Think</em></a><em>.</em></p>\n<p><em>Assumption: For all models covered in this article, it is assumed that the rationality of all participants or players is </em><a href="https://en.wikipedia.org/wiki/Common_knowledge_(logic)"><em>common knowledge</em></a><em>. This means that the following two infinite propositions are true.</em></p>\n<p><em>‘I know that you are rational.</em></p>\n<p><em>You know that I know that you are rational.</em></p>\n<p><em>I know that you know that I know that you are rational. … ’</em></p>\n<p><em>‘You know that I am rational.</em></p>\n<p><em>I know you know that I’m rational.</em></p>\n<p><em>You know that I know that you know that I’m rational. … ..’</em></p>\n<p>First, let’s consider a very simple system. There are two players in this system; one as the Asserter (A), who simply claims true or false, and the Verifier (V) who can verify A’s assertion with paying the cost of verification, or can choose to do nothing assuming that A would have asserted true. If A’s claim is false and V succeeds in verifying it, A’s deposit will be rewarded to V.</p>\n<p>Conversely, if V does not accuse A despite a false assertion, V’s deposit will be rewarded to A. In other words, the purpose of this system is to make the assertion to be always true via verification even if A makes a false assertion.</p>\n<p>There are two threats we need to consider in order to achieve this goal.</p>\n<ol>\n<li>Bribery attacks</li>\n<li>Verifier’s laziness</li>\n</ol>\n<p>A bribery attack means that A bribes V in advance not to verify a false claim. It can be resolved relatively easily by increasing the value of the collateral of A and V, or by increasing the number of stakeholders.</p>\n<p>The verifier’s laziness literally means that V decides not to verify A’s claim. If V does not verify the claims, A can continue to claim falsehood as much as possible. Unlike a bribery attack, the verifier’s laziness is difficult to solve by simply increasing the value of the collateral or the number of stakeholders. Let’s dive deep into the reasons below.</p>\n<p>In order to prevent the verifier’s laziness, first it is necessary to understand how the verifier chooses the verification or non-verification strategy. The expected payoff of each strategy under the following conditions is as follows:</p>\n<ul>\n<li>R = A’s Deposit, if A claims false and V succeeds in verification, is rewarded to V.</li>\n<li>L = V’s deposit, if A claims false and V fails to verify it, it is awarded to A.</li>\n<li>X = Probability of attack by A</li>\n<li>C = Verification cost</li>\n</ul>\n<ol>\n<li>Expected payoff of verification: R*X-C</li>\n<li>Expected Payoff of non-verification: -L*X</li>\n</ol>\n<p>We can observe that if V’s verification payoff is greater than the non-verification payoff <strong>(R*X- C &gt; -L*X)</strong>, V will always verify A’s assertion.</p>\n<p>In other words, if <strong>X &gt; C/(R+L)</strong>, we can prevent the verifier’s laziness. However, if <strong>X &lt; C/(R+L)</strong>, V will not verify A’s claim (If the two terms are the same, the expected payoff becomes indifferent. i.e. V may or may not verify A’s claim).</p>\n<p>It seems like what needs to be done is to <strong>make X bigger than C/(R+L)</strong>. Then V will always verify A’s claims and this simple system will always remain secure!</p>\n<p>However, the problem remains that X means A’s attack probability, and the <strong>value of X is determined by A</strong>. If A properly adjusts the frequency and timing of attacks so that X is sufficiently low, V will choose not to verify because the verification utility is lower than the non-verification utility. This entails that the security of this simple system could be compromised.</p>\n<p>One could argue that “the system can be more secure if you increase R+L to the maximum, and lower the effective X value enough.” In other words, increase the capital requirement of A and V so that they must deposit more on this system. However, this is clearly limited in the following two aspects.</p>\n<ol>\n<li>Regardless of how high the R and L values are, A can calculate the effective attack probability as soon as the value(R, L) is determined in advance. This allows A to still reduce V’s incentives for verification.</li>\n<li>Raising the capital will limit the participation since it increases the barrier to entry to participate in the system.This will soon have a very negative impact on the introduction and expansion of the system.</li>\n</ol>\n<p>Another idea is that increasing the number of verifiers can solve this dilemma. <strong>Simply increasing the number of verifiers is very helpful in preventing bribery attacks; however, it has rather negative effects on solving the verifier’s laziness.</strong></p>\n<p>The reason it assists in preventing bribery attacks is that the asserter (A) must pay each verifier (V) a reward greater than R in order to bribe the verifier. If the number of verifiers is N, and the total profit obtained by claiming falsehood is M, then all verifiers can be bribed only if M/N &gt; R. Therefore, the larger the N, the more difficult it is for the asserter to carry out a bribery attack.</p>\n<p><em>Theoretically, we can ensure that rollup is secure if there is only one verifier in it, but on the contrary, since it can be vulnerable to bribery attack if there are only a few active verifiers, it is very important to have as many active verifiers as possible.</em></p>\n<p>Conversely, increasing the number of verifiers is not very helpful in preventing the verifier’s laziness because when the number of verifiers increases, the expected payoff of non-verification remains the same, while <strong>the expected payoff of verification strategy decreases in proportion to the number of verifiers.</strong> For example, if there are two verifiers and they all succeed to verify, the reward R will be divided by any ratio (K), which will be a lower amount than the reward R when there is only one verifier (R/K).</p>\n<p>According to this simple model, the verifier’s dilemma is a fairly complex problem, and solving it seems quite difficult. However, this model doesn’t exactly imitate the rollup. Could this be solved in rollup? Let’s take a closer look at this in the next chapter.</p>\n<h3>Super-Simple Model in Optimistic Rollup</h3>\n<p>Based on the simple model discussed above, let’s construct a Super-Simple Model in the rollup and see which problems arise in the rollup regarding the verifier’s dilemma. In fact, there won’t be many changes from the previous model. The asserter becomes a sequencer (S), and the verifier (V) remains the same. In this case, it is assumed that the verifier is the stakeholder of the rollup. In other words, a verifier is someone who has certain economic/non-economic assets in the rollup, or who periodically obtains certain economic/non-economic returns through the rollup.</p>\n<p>At this time, the expected payoff for verification and non-verification of V under the following conditions are as follows.</p>\n<ul>\n<li>R = S’s deposit; V is rewarded with R when V succeeds in verification.</li>\n<li>L = V’s assets deposited in the rollup; S is rewarded with L if V fails to verify.</li>\n<li>X = Probability of attack by S</li>\n<li>C = Verification cost</li>\n<li>F = The revenue that V earns per verification unit (e.g. when V receives a constant revenue for each transaction T in the rollup, this is called F)</li>\n</ul>\n<p><em>However, R,L &gt; F &gt; C &gt; 0.</em></p>\n<p>Also, for convenience, it is assumed that F is not accumulated in L. These assumptions will apply equally to all models that will be covered later.</p>\n<ol>\n<li>Expected payoff of verification: R*X + F -C</li>\n<li>Expected payoff of non-verification: -L*X + (1-X)F</li>\n</ol>\n<p><em>Note that even without verification, the verifier can still earn F if the sequencer does not attack.</em></p>\n<p>In this case, just like in the previous Super-Simple Model, if the verification payoff is greater than the non-verification payoff, the verifier will always have an incentive to verify. If the sequencer’s attack probability is as follows, the verifier will always choose the verification strategy.</p>\n<ul><li><strong>X &gt; C/(R+L+F)</strong></li></ul>\n<p>What’s different from the previous model is that only F is added to the denominator. This may have the effect of slightly reducing the sequencer’s attack probability, but the fundamental problem remains the same.</p>\n<p>In other words, it is visible that the <strong>verifier’s strategic choice still depends on the sequencer’s attack probability</strong>, and this does not change much even when considering the new variable, the constant return (F) the verifier gets per verification unit. This is because if the sequencer attacks very intermittently or does not attack, the verifier can continue to earn full returns without paying the cost of verification.</p>\n<p>How can we solve this problem? It has already been debated that R and L, i.e. how to increase capital requirements, have clear limits. One option we can think of is that the rollup can maintain the security of the system if only one verifier performs the verification correctly. If that is the case, if we change the number of verifiers from simple models to extended models, we could expect that at least one of them will verify. If so, can we ensure security of the rollup?</p>\n<h3>Multiple Verifiers</h3>\n<p>Before we start increasing the number of verifiers (N), let’s begin with a very simplified model with only two verifiers (V1 and V2) and a sequencer (S). In this case, the expected payoff of verification and non-verification of each verifier can be notated as follows under the conditions below.</p>\n<ul>\n<li>R = S’s deposit; V is rewarded with R when V succeeds in verification.</li>\n<li>L = Assets of V(N) deposited in the rollup; S is rewarded with L when V fails verification. (It is assumed that the two verifiers have the same L.)</li>\n<li>X = Probability of attack by S</li>\n<li>Y = The probability that the opponent verifier will verify (e.g., in terms of V1, if V1 is sure that V2 will always verify, then Y = 1.)</li>\n<li>C = Verification cost</li>\n<li>F = Revenue V(N) receives per verification unit (assuming that the F of both verifiers is the same.)</li>\n</ul>\n<p><em>However, R, L &gt; F &gt; C &gt; 0</em></p>\n<ol>\n<li>Expected payoff of verification: R*X + F-C</li>\n<li>Expected payoff of non-verification: -L*X(1-Y) + F*(1-X(1-Y))</li>\n</ol>\n<p>The expressions for verification and non-verification have become quite complex, but if you grasp what the newly added part (1-Y) means, you can understand it more intuitively. The most significant feature of the rollup is that even if you don’t verify the rollup on your own, your assets could be kept safe if someone else verifies it. In other words, if Y is 1 or close to 1, it means that the other verifier will verify S, which indicates that even if you do not verify it yourself and the sequencer always attacks (X = 1), all of your assets, and additional economic interests can be preserved.</p>\n<p>If so, it is questioned whether either or both of the verifiers will verify. To explore this more intuitively, let’s use a very simple game theoretic approach.</p>\n<p>The expected payoff of the two verifiers’ choice of verification and non-verification strategies can be expressed in the payoff matrix as follows.</p>\n<p>It is assumed that the reward R obtained when both verifiers succeed in verification is divided by the same ratio.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JQF4tUx0vufkmNfF"></figure><p>The Nash equilibrium in this game will depend on the value of each variable. For example, if the attack probability of a sequencer is high, and the expected verification reward is even higher, the equilibrium is for both verifiers to verify (V, V). If the attack probability is very low and the expected loss of non-verification is not significant, the equilibrium is for both verifiers not to verify (NV, NV). In addition, when the attack probability is neither very high nor very low, the equilibrium is for only one verifier to verify (V, NV) (NV, V). This can be expressed as follows.</p>\n<ol>\n<li>(V, V): X &gt; 2C/R</li>\n<li>(V, NV) (NV, V): 2C/R &gt; X &gt; C/(R+L+F)</li>\n<li>(NV, NV): X &lt; C/(R+L+F)</li>\n</ol>\n<p>Let’s look at each case through a simple example. In this example, it is assumed that the values of the variables other than X are as follows.</p>\n<ul>\n<li>R = 100</li>\n<li>L = 100</li>\n<li>F = 5</li>\n<li>C = 1</li>\n</ul>\n<p>In this case, assume that the attack probability X is greater than 2C/R = 0.02, which means X = 0.05.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*NjAlS77vPIX5-kCO"></figure><p>In this case, since the verification strategy for both verifiers is a dominant strategy, the equilibrium is (V, V). This is a very desirable situation, but since it is assumed that the sequencer’s attack probability is very high, in reality, this situation won’t occur easily.</p>\n<p>Next, suppose that X is less than 2C/R = 0.02 and greater than C/(R+L+F) = 0.0049, which means X = 0.005.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*OP7ADdGO3Mj-0Blt"></figure><p>Interestingly, when both verifiers choose the same strategy, they can’t maximize their payoff. i.e. choosing different strategies is the equilibrium.</p>\n<p>For example, if verifier 2 chooses the verification strategy, verifier 1 will choose the non-verification strategy and if verifier 1 chooses the verification strategy, verifier 2 will choose the non-verification strategy. With similar logic, if verifier 2 chooses the non-verification strategy, it is most reasonable for verifier 1 to choose the verification strategy and if verifier 1 chooses the non-verification strategy, then verifier 2 chooses the verification strategy.</p>\n<p>In other words, there are two equilibria in this game, (NV, V) and (V, NV). So, which equilibrium is chosen in this game? This is determined by factors such as pre-commitment, and credibility. For example:</p>\n<p>Let’s say that verifier 2 has chosen the non-verification strategy. Verifier 2 openly affirms to verifier 1, “I do not have equipment with the requirements necessary for verification, so I will not verify at all in the future.” However, verifier 1 currently has all the required equipment for verification. The most rational option that verifier 1 can choose in this case would be the verification strategy which will offer a relatively higher expected reward for a small verification cost, rather than a non-verification strategy for no cost at all. we can see that at some point where X is neither high enough nor low enough, only one of the two verifiers will choose the verification strategy.</p>\n<p>Finally, suppose that the X is less than C/(R+L+F) = 0.0049, which means X = 0.0001.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*z1YNMA-uHx0V4Qhp"></figure><p>In this game, the equilibrium is (NV, NV) because the non-verification strategy is the dominant strategy for both verifiers. As we continue to emphasize, the sequencer can acquire<strong><em> </em></strong>information about each variable in advance, so that the effective attack probability can be easily calculated. Therefore, the sequencer will attack with the probability that not even one verifier will choose a verification strategy. In other words, if the sequencer attacks, it will attack with a lower probability than C/(R+L+F).</p>\n<p>In summary, even in a model in which the number of verifiers is increased to two, each verifier chooses the verification or non-verification strategy according to the attack probability of the sequencer, and as the attack probability decreases, the number of verifiers who choose the verification strategy decreases. This does not change considerably even if the number of verifiers is increased to N. As the number of verifiers increases, the amount of expected verification rewards will decrease, and even if the probability of attack is not very low, the number of verifiers who continue to choose the verification strategy will decrease because only one verifier who chooses the verification strategy can protect all other users’ assets and interests. In addition, when the probability of attack is very low, even one verifier will not choose the verification strategy.</p>\n<p>This is a very shocking result. <strong>Regardless of the number of verifiers, the more safely the rollup operates over the long term, the more active verifiers will continue to decrease and converge to zero.</strong></p>\n<h3>Is There No Verifier’s Dilemma in Optimistic Rollup?</h3>\n<p>Despite the fact that the rollup has several issues with security due to the verifier’s dilemma as discussed above, <strong>there is an argument that the verifier’s dilemma in the rollup is just a trivial issue, and there is no need to implement an additional mechanism to deal with it. To begin with, some parts of this argument are valid, and some are not.</strong> In general, the rationale behind the argument; it is not necessary to take into account the verifier’s dilemma in the rollup, can be summarized into four main reasons.</p>\n<ol>\n<li>Token Holder</li>\n<li>Dapp Builder — We can substitute it with all participants who earn a certain amount of revenue (e.g Yield farming) per L2 transaction.</li>\n<li>Altruist</li>\n<li>Fast Withdrawal</li>\n</ol>\n<p>Let’s examine each reason in the above mentioned in order and see if they can actually help to solve the verifier’s dilemma.</p>\n<h3>Token Holder</h3>\n<p>The first reason it’s not necessary to take into account the verifier’s dilemma in the rollup is that users with many tokens (or assets) in Layer 2 will have a high incentive to perform verification.</p>\n<p>However, users with many tokens are basically just verifiers with a relatively high L in the simple model discussed above. Therefore, this has no other meaning than slightly lowering the sequencer’s attack probability.</p>\n<p>One thing to note here again is that simply increasing L, which is the amount of assets deposited by the verifier in the rollup, or increasing the sequencer’s deposit R, is not very helpful in solving the verifier’s dilemma.</p>\n<h3>DApp Builder</h3>\n<p>Another reason is that, if a DApp is operated in a rollup, the rollup must be operated safely to ensure continuous profits for the DApp operator, so the incentive for verification of stakeholder of that DApp will be high. However, this is also discussed previously. Despite the fact that the revenue (F) per verification unit is high, it can be safely earned regardless of verification, if the sequencer does not attack. i.e. the verification strategy is also chosen according to the attack probability of the sequencer. In other words, even though the builder of the DApp makes huge profits by operating a large DApp, this does not lead to a guarantee that the builder will always verify the rollup.</p>\n<h3>Altruist</h3>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/589/0*guU9Qaxs4Wo5X5Yv"><figcaption>source: <a href="https://twitter.com/gakonst/status/1353695113860370436">twitter</a></figcaption></figure><p>The next reasoning is <a href="https://en.wikipedia.org/wiki/Altruism">altruism</a>. Not everyone in this world is always selfish and makes choices that maximize only their own interests. If so, numerous actions such as philanthropic donations and charities won’t exist (of course, this can also be explained as having a greater non-economic utility than the economic cost of donating or serving).</p>\n<p>In short, the point of the argument is that even though verification is an economic loss, someone who is altruistic in this ecosystem would verify the rollup anyway. For example, there are people who do not earn any mining rewards on the Bitcoin or Ethereum network, but store all the block data, and propagate it to other nodes. They do not get any economic benefits from this behavior, but they do it altruistically for no economic gain.</p>\n<p><em>However, this also can lead to an issue. The fact that the </em><a href="https://www.google.com/amp/s/decrypt.co/24779/ethereum-archive-nodes-now-take-up-4-terabytes-of-space%3Famp%3D1"><em>number of Ethereum archive nodes is too small</em></a><em> is a problem that has been frequently raised. As Ethereum blocks increase, state data continues to grow at a rapid pace, and in the long run it is unsustainable to simply expect altruistic participants to maintain archive nodes without any incentives.</em></p>\n<p>While this seems to make sense at first glance, it should be noted that we are searching for an approach to resolve or mitigate the verifier’s dilemma. In other words, altruistic verifiers are very helpful from the point of view of the entire network when the rollup is actually operated, but when designing any mechanism or tool to ensure the security of the network, they can neither be the rationale nor the basis of that mechanism.</p>\n<p>Let’s assume you are the architect of Ethereum. How would you respond if someone asks you the question; what can we do when the incentive to record and store block data is not clear? If the answer is that there are altruistic people in the world and these people will somehow store all the data, it would not be a convincing answer.</p>\n<p>Vitalik Buterin also argued in <a href="https://vitalik.ca/general/2021/01/05/rollup.html">his article</a> that we need more explicit reasoning to design verification incentives for rollup as mentioned below:</p>\n<p><em>Auditing incentives — how to maximize the chance that at least one honest node actually will be fully verifying an optimistic rollup so they can publish a fraud proof if something goes wrong? For small-scale rollups (up to a few hundred TPS) this is not a significant issue and one can simply rely on altruism, </em><strong><em>but for larger-scale rollups more explicit reasoning about this is needed.</em></strong></p>\n<h3>Fast Withdrawal</h3>\n<p>The last claim is fast withdrawal. To understand why fast withdrawal is presented as the basis for the claim, that it is not necessary to consider the verifier’s dilemma, we first need to figure out what fast withdrawal is.</p>\n<p>Fast withdrawal is an alternative way to withdraw tokens from L2 to L1 so that users can avoid the long withdrawal time due to the DTD (Dispute Time Delay) in rollup. Fast withdrawal simply works like this when users want to withdraw some amount of tokens from layer 2 to layer 1, an intermediary buys these tokens in layer 2 and sends them to the user in layer 1 except for the fast withdrawal fee.</p>\n<p>Let’s take a closer look at fast withdrawal with an example.</p>\n<ol>\n<li>Alice wants to withdraw 10 ETH from L2 to L1 paying a fee of 0.1ETH.</li>\n<li>Alice transfers 10 ETH to the fast withdrawal market contract.</li>\n<li>Ivan confirms and verifies the withdrawal request and sends 9.9 ETH from L1 to Alice.</li>\n<li>After the DTD required for the withdrawal, Ivan will acquire 10ETH in the market contract of L2.</li>\n</ol>\n<p>The important point here is that in the process of fast withdrawal, Ivan verifies whether Alice’s withdrawal is a valid request or not. This means that Ivan actually verifies the states of rollup are correctly configured. A problematic point in the verifier’s dilemma was that the verifier’s verification rewards depended on the probability of attack by the sequencer. <strong>However, in the case of fast withdrawal, Ivan seems to have an incentive to verify regardless of the sequencer’s attack behavior!</strong></p>\n<p>Based on this, let’s define the expected payoff of Ivan according to the Super-Simple Model.</p>\n<p>First, let’s assume that there are already a number of general verifiers(N) other than Ivan in the rollup. Assuming that fee of fast withdrawal is F, Ivan’s expected payoff for verification is as follows.</p>\n<ol>\n<li>Expected payoff of verification: R*X + F-C</li>\n<li>Expected payoff of non-verification: -L*X + (1-X)F</li>\n</ol>\n<p>What’s interesting here is that unlike for the other verifiers in the rollup, the fact whether or not the remaining verifiers have verified, does not affect Ivan’s expected payoffs.The reason for this is the special nature of fast withdrawal; Ivan has to transfer his tokens in L1 as soon as possible after receiving the fast withdrawal request from Alice. <strong>However, if Alice’s withdrawal request was found to be invalid by another verifier during the DTD, Ivan will not be able to get his tokens back.</strong> This is because tokens in L1 have already been transferred to Alice. In other words, in order for Ivan to safely process a fast withdrawal, he must verify by himself rather than relying on other verifiers.</p>\n<p>This is an interesting fact; if there are only two verifiers in the rollup and one is a fast withdrawal intermediary like Ivan, and the other is a general verifier (e.g token holder, DApp operator, etc.), then Ivan is more likely to choose a verification strategy than other verifiers. Let’s take a closer look at this through the following payoff matrix.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Z-3BxltGTz-YjkXs"></figure><p>As mentioned earlier, even if the opponent verifier chooses the verification strategy, when the sequencer attacks via a fast withdrawal, it is impossible for Ivan to effectively defend the sequencer’s attack and protect his assets. Therefore, the expected payoffs of Ivan are equally -L*X+(1-F)X. This implies that if only one of the two participants, Ivan or the opponent verifier, must choose a verification strategy (similar to the situation where the attack probability of the sequencer is neither very high nor low in a model with two general verifiers), Ivan has a higher incentive to choose a verification strategy than the opponent verifier.</p>\n<p>More specifically, when 2C/R &gt; X &gt; C/(R/2+L+F), the equilibrium becomes (V, NV). <em>Under the same conditions in the model of only two verifiers, the </em>equilibrium <em>was (V, NV) (NV, V).</em> Specifically, in a situation where the probability of attack is neither high nor low, Ivan will always choose the verification strategy, and the opponent verifier will always choose the non-verification strategy. Let’s look at this through a specific example.</p>\n<p>Under the conditions below, the payoff matrix of Ivan and the verifier is composed as follows.</p>\n<ul>\n<li>R = 100</li>\n<li>L = 100</li>\n<li>F = 5</li>\n<li>C = 1</li>\n<li>X = 0.007</li>\n</ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*wzzJJ2LaCvvnUDXh"></figure><p>Had Ivan been a general verifier, in this case the equilibrium would have been (V, NV) (NV, V). However, since Ivan is the intermediary of fast withdrawal, the verification strategy is the dominant strategy. Therefore, the other verifier will always choose the non-verification strategy and (V, NV) will become the equilibrium.</p>\n<p>In summary, <strong>it can be seen that under the same conditions, intermediaries of fast withdrawals have a higher incentive to verify than general verifiers.</strong> If someone does verify, it is very likely that it is an intermediary of fast withdrawal. However, this does not prove that Ivan will always choose the verification strategy.</p>\n<p>Again, it is true that Ivan’s incentive to choose a verification strategy is relatively large, but in practice, the probability of the sequencer’s attack is taken into consideration when making this strategic choice. Therefore, what we need to focus on now is to find out exactly under what criteria a fast withdrawal intermediary will make such a strategic choice, and what factors are needed to make sure this intermediary chooses a verification strategy. Let’s look at this in detail in the next chapter.</p>\n<h3>Fast Withdrawal and Auditing Incentives</h3>\n<p>In this chapter, we will take a closer look at how Ivan chooses between a verification and non-verification strategy for rollup, which variables will affect that decision, and furthermore, what additional mechanisms are needed to ensure that Ivan will always verify the rollup.</p>\n<h3>Attack-Verify Game</h3>\n<p>Let’s compose a simple Attack-Verify Game between Ivan and the sequencer as follows to find out how Ivan chooses the verification or non-verification strategy.</p>\n<p>The only players in this simple game are Ivan and the sequencer. The sequencer will request a fast withdrawal to Ivan, and at this time, the sequencer can choose whether to request a fast withdrawal for valid or invalid tokens. This is called an attack and non-attack strategy.</p>\n<p>Ivan can choose either to verify and transfer the tokens to the sequencer in L1, or transfer it without verification. This is called a verification and non-verification strategy.</p>\n<p>In this game, Ivan and the sequencer have different expected payoffs depending on each other’s strategic choices, which can be specifically represented by the following payoff matrix.</p>\n<ul>\n<li>R: Deposit of the sequencer / Reward given to Ivan upon successful verification</li>\n<li>L: Amount of fast withdrawal / Amount lost by Ivan upon successful attack by the sequencer</li>\n<li>F: Fast withdrawal fee</li>\n<li>C: Verification cost</li>\n</ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*faeqqFttFWohry-q"></figure><p><em>The sequencer’s payoff in non-attack is 0 because the utility obtained from the fast withdrawal is considered to be the same as the paid fee F. Even if this is changed to a different number, the expected payoff of the sequencer (V,NA), (NV,NA) will be the same. It is also difficult to expect a significant difference compared to the expected payoff of (V,A) and (NV,A).</em></p>\n<p>Assuming R,L &gt; F &gt; C, there is no pure strategy Nash equilibrium in this game. Let’s look at this in detail through an example.</p>\n<ul>\n<li>R = 100</li>\n<li>L = 100</li>\n<li>F = 5</li>\n<li>C = 1</li>\n</ul>\n<p>Substituting these values into the payoff matrix table above will give the following result.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-2vKMMoFFx_Ce0uD"></figure><p>There are no dominant and dominated strategies for both Ivan and the sequencer in this game. Also, there is no pure strategy Nash Equilibrium. This is because each player’s strategic choices vary depending on each other’s strategic choices. If the sequencer does not attack, it is advantageous for Ivan not to verify, if Ivan does not verify, it is advantageous for the sequencer to attack and vice versa. This means that, depending on the situation, Ivan and the sequencer will use both strategies, rather than just one strategy.</p>\n<h3>Mixed Strategy Nash Equilibrium</h3>\n<p>So, how do Ivan and the sequencer choose between these two strategies? First we need to understand what mixed strategy Nash equilibrium means.</p>\n<p><em>When using a mixed strategy, given the two strategies, the optimal approach for each player is to choose the strategy that makes the expected payoff of the opponent indifferent between two strategies. In other words, it is to find the point where the expected payoff becomes indifferent no matter what strategy the other party chooses.</em></p>\n<p>If the <strong>probability of Ivan choosing the verification strategy is P,</strong> and <strong>the probability of the sequencer choosing the attack strategy is Q</strong>, then each probability (P, Q) according to the mixed strategy Nash equilibrium are as follows.</p>\n<ul>\n<li>R*P<em> </em>+ L(1-P) = 0*P + 0*(1-P)</li>\n<li><strong>P = L/(R+L)</strong></li>\n<li>(R+F-C)Q + (F-C)(1-Q) = -L*Q + F(1-Q)</li>\n<li><strong>Q = C/(R+L+F)</strong></li>\n</ul>\n<p>By assigning the variable values used in the previous example, the mixed strategy Nash equilibrium can be calculated as below.</p>\n<ul>\n<li>P = 1/2</li>\n<li>Q = 1/205</li>\n</ul>\n<p>To put it another way, once every two turns, Ivan chooses either the verification strategy or the non-verification strategy. In the case of the sequencer, the non-attack strategy is chosen 204 times out of 205 times, and the attack strategy is chosen once. But our goal is to make Ivan choose the verification strategy 100% of the turns, instead of only once every two turns. We also want to reduce the attack probability from 1/205 and converge it to 0. What steps must we take to achieve both goals?</p>\n<p><strong>The most effective way is to increase L.</strong> Increasing L leads to an increase in the probability that Ivan chooses the verification strategy, while reducing the probability that the sequencer chooses the attack strategy. However, increasing R also can lead to a reduction in the attack probability, but simultaneously it decreases the probability of Ivan/verifier choosing the verification strategy. In short, if you are trying to solve the verifier’s dilemma by increasing the capital requirements in rollup, increasing L is the most effective way to achieve it. However, unfortunately there are obvious limitations when it comes to increasing capital requirements. Thus, we need a different approach to solving this.</p>\n<h3>Maximin Strategy</h3>\n<p>Through the mixed strategy Nash equilibrium we found out that Ivan and the sequencer make strategic decisions with a certain probability. However, in reality, will Ivan and the sequencer follow the exact equilibrium when choosing their respective strategies? When both players choose a strategy that maximizes their profits, the additional expected profits become relatively low, while the losses incurred by making the wrong strategic choice in the process become truly catastrophic.</p>\n<p>For example, if Ivan chooses the non-verification strategy, he gets only +1 extra reward if the sequencer doesn’t attack, while he suffers a huge loss of -100 if the sequencer chooses the attack strategy. The sequencer also gains nothing from a non-attack, but the expected loss in the event of a failure of an attack is relatively very high.</p>\n<p><strong>In such an event, players generally tend to pursue security rather than maximizing profits.The strategy that maximizes strategic security is the maximin strategy.</strong></p>\n<p><em>This does not apply only to the game of Ivan and the sequencer. For instance, users who trade and hold cryptocurrency have a variety of strategic choices on how to hold tokens depending on their tendency to deal with risks. When holding and trading cryptocurrencies, generally the most convenient way is to hold them on a centralized exchange(CEX). However, this method carries the risk of losing all of the coins when the exchange is hacked or attacked. Therefore, users who prefer high risks tend to hold and trade cryptocurrency on a centralized exchange, while users who want to avoid high risks use services such as Metamask or hardware wallets instead of a CEX. Additionally, users with extremely high risk aversion tendencies may worry about the cryptocurrency itself, so they operate a full node or an archive node simultaneously. All of these users have the same expected payoff when holding coins on the exchange, but the strategic choice depends on the degree of risk aversion. i.e. it depends on strategic security, not stability.</em></p>\n<p>The maximin strategy is a strategy that yields ‘best of the worst’ outcome for each player. To rephrase, irrespective of the decisions other players make, players maximize the minimum payoff amount.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*PGPWp0VCaL4S_v49"></figure><p>Suppose that in the above example payoff matrix, Ivan and the sequencer follow the maximin strategy, not the Nash equilibrium.</p>\n<p>Ivan’s maximin strategy will be V, the sequencer’s maximin strategy will be NA and the maximin payoff vector of the two players will be (4,0). When following the maximin strategy, Ivan and the sequencer will always choose the verification strategy and the non-attack strategy respectively.</p>\n<p><strong>Thus, we can come to the conclusion that whenever a fast withdrawal is processed, the rollup will be verified if Ivan and the sequencer, or Ivan alone, place the strategic security as top priority.</strong></p>\n<p>However, it is unreasonable to assume that all players prioritize security over stability. This is because each individual player’s disposition will be different from each other. <strong>Therefore, the approach through the maximin strategy may mitigate the verifier’s dilemma somewhat more than before, but it cannot be ensured that it has been completely solved.</strong></p>\n<h3>Fast Withdrawal With Attention Challenge</h3>\n<p>Earlier, we saw that the verifier’s dilemma can be resolved under the assumption that each player gives strategic security a higher priority. However, since this still requires assumptions about the player’s disposition, it has also been discussed that the verifier’s dilemma has not been solved completely, but only somewhat mitigated.</p>\n<p>What additional system would be needed to solve the verifier’s dilemma without having to make assumptions? The reason Ivan does not necessarily choose the verification strategy in the case of fast withdrawal is very simple. This is because the verification strategy is not a dominant strategy.</p>\n<p>Hence how do we make the verification strategy a dominant strategy? This question has a very simple answer: make Ivan’s payoff for the non-verify and non-attack vector (NV, NA) less than or equal to that of the verify and non-attack vector (V, NA). We can achieve this by adopting an Attention Challenge for fast withdrawal.</p>\n<p><em>Attention Challenge is a concept proposed in Ed Felten’s article, </em><a href="https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e"><em>Cheater Checking: How attention challenges solve the verifier’s dilemma</em></a><em>, and is a system that checks whether a specific verifier has verified correctly, at random and periodically. Please refer to the article written by Ed Felten or the Related Research section at the end of this post for details on how the attention challenge works.</em></p>\n<p>Introducing the attention challenge into rollup will work as follows. Note that this is a very simplified explanation.</p>\n<ol>\n<li>The sequencer processes the transactions in the rollup and submits a hash of the state root and a random value so that the verifiers cannot know the exact value.</li>\n<li>Verifiers are selected at random as respondents to the attention challenge without knowing the state root.</li>\n<li>The verifiers who were selected in step 2, have to respond with the state root after processing the transactions the same way as the sequencer.</li>\n<li>If they do not respond within the specified time, or submits an incorrect response, their deposit will be slashed.</li>\n</ol>\n<p>With the attention challenge, the payoff matrix can be changed as follows:</p>\n<ul>\n<li>C = Verification cost + Attention challenge response cost</li>\n<li>A = Ivan’s deposit for attention challenge. If Ivan fails to respond correctly to the challenge, the entire deposit will be slashed.</li>\n<li>P = Probability of Ivan being selected as a respondent for attention challenge</li>\n</ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*8FjQYr3fTwDARmQf"></figure><p>We can easily see that if P*A &gt; C, the verification strategy will be the dominant strategy for Ivan. In other words, if the loss from attention challenge is greater than the verification cost, Ivan will definitely choose the verification strategy. Let’s check this through a specific example.</p>\n<p>Suppose that each variable is as follows.</p>\n<ul>\n<li>R = 100</li>\n<li>L = 100</li>\n<li>F = 5</li>\n<li>C = 2</li>\n<li>A = 50</li>\n<li>P = 0.1</li>\n</ul>\n<p>Then the payoff matrix will be as follows.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Wx41QehVvzo9Yvad"></figure><p>In all cases, The expected payoff of the verification strategy for Ivan is higher than the non-verification strategy. Now the verification strategy is the dominant strategy. The sequencer will always choose the non-attack strategy because Ivan will always choose the verification strategy. Therefore, <strong>the (V, NA) strategy vector is the pure strategy Nash equilibrium, which means that the rollup can always be verified!</strong></p>\n<p><em>By introducing the attention challenge to general verifiers, we can make the verification strategy to be the dominant strategy for all verifiers. However, the nature of the attention challenge requires interacting with L1, so expanding the target and the probability of the attention challenge can be a huge burden at the system level. Details on this will be covered in the </em><strong><em>Trade-Off of Attention Challenge </em></strong><em>section.</em></p>\n<h3>Cross-Rollup Transaction</h3>\n<p>As discussed above, the intermediaries of fast withdrawal will always choose to verify the rollup, if they prefer strategic security, or if we adopt the attention challenge. The interesting fact is that there is another participant in the rollup with the exact same payoff structure as the intermediary of the fast withdrawal. This is the cross-rollup transaction intermediary (hereinafter referred to as the rollup intermediary).</p>\n<p><em>The cross-rollup transaction in this article is based on the concepts covered in the following two articles.</em></p>\n<ul>\n<li><a href="https://ethresear.ch/t/cross-rollup-dex-with-smart-contracts-only-on-the-destination-side/8778"><em>Cross-rollup DEX with smart contracts only on the destination side</em></a></li>\n<li><a href="https://ethresear.ch/t/hop-send-tokens-across-rollups/8581"><em>Hop: Send Tokens Across Rollups</em></a></li>\n</ul>\n<p>Rollup intermediaries can provide fast token transfer services between two rollups in a way similar to the intermediaries of the fast withdrawal. For example, if we have two rollups A, and B, and Alice wants to transfer tokens from A to B through rollup intermediary Ivan, this can be done the following way:</p>\n<ol>\n<li>Alice wants to transfer 10 ETH from rollup A to B paying Ivan a fee of 0.1 ETH</li>\n<li>Alice transfers 10 ETH to a cross-rollup market contract.</li>\n<li>Ivan verifies the cross-rollup transaction request and sends 9.9 ETH to Alice in B.</li>\n<li>After the DTD, Ivan gets 10 ETH deposited in the market contract in A.</li>\n</ol>\n<p>What you can see from this is that only the destinations of the withdrawal and the transfer are changed, from L1 to rollup B, and other aspects have not changed at all. This means that rollup intermediary Ivan also has the same expected payoff for both verification and non-verification as fast withdrawal intermediary Ivan.</p>\n<p>Therefore, the cross-rollup intermediary Ivan’s, and the sequencer’s payoff matrix can be expressed as follows, and it is identical to that of the fast withdrawal broker intermediary, and the sequencer.</p>\n<ul>\n<li>R: Deposit of the sequencer S / Reward given to Ivan upon successful verification</li>\n<li>L: Amount of cross-rollup transfer / Loss of Ivan when the sequencer attacks successfully</li>\n<li>F: Cross rollup transfer fee</li>\n<li>C: Verification cost</li>\n</ul>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*w3QFbs2HKux5VCDF"></figure><p>Since the two matrices are identical, we can assume that the cross-rollup intermediary Ivan also always chooses the verification strategy based on the maximin strategy, or when adopting the attention challenge.</p>\n<p>This is a very encouraging result as it means that the number of verifiers with relatively high incentives can expand from the fast withdrawal intermediaries to the cross-rollup intermediaries.</p>\n<h3>Trade-Off of Attention Challenge</h3>\n<p>We can force the intermediaries of the fast withdrawal and cross-rollup transfer consistently choose verification strategy by adopting the attention challenge. The attention challenge itself is a mechanism applicable not only to these intermediaries, but also to all other users of the rollup. If we apply the attention challenge in an extended way, it could be a very good strategy to maximize the security of the rollup, as the verification will be the dominant strategy for all verifiers.</p>\n<p>However, it has a couple of blind spots.</p>\n<p>First, since responding to the attention challenge involves <strong>on-chain transactions</strong>, the increased number of targets of the attention challenge results in an increased number of required on-chain transactions. Second, if all users of the rollup have to respond to the attention challenge, the user experience of the rollup can be seriously undermined.</p>\n<p>Let’s discuss the first issue in detail. Expanding the target of the attention challenge inevitably means that the number of respondents to the attention challenge increases. Undoubtedly, as the number of verifiers (N) increases, the probability of being selected as the target of the attention challenge (P) can be decreased, so that the number of responses to the attention challenge can be appropriately adjusted. If then, there will be no problem. However, if P is excessively reduced, the expected loss (-P*A), which can occur if the attention challenge is not properly responded, will also be lowered. This will soon lead to a situation where the attention challenge would not be able to force the verification strategy to always be the dominant strategy. It is still possible to offset this by raising A in this case as well, but it is difficult to regard it as a desirable solution because it implies raising capital requirements. In short, increasing the number of target verifiers means that a larger number of on-chain transactions would be made due to the attention challenge.</p>\n<p>The second issue is that expanding the number of targets of the attention challenge can undermine the rollup’s user experience. The advantage of rollup is that it can operate safely without all users being verifiers, i.e. with at least one honest verifier. Obviously, the more active verifiers the more secure rollup is, but this doesn’t mean that all users should be active verifiers. <strong>To put it in the extreme, making everyone verify the rollup is just as bad as making no one verify the rollup. </strong>This has already been discussed sufficiently when discussing the limitations of Plasma in the Ethereum community, so further explanation will be omitted.</p>\n<p>In other words, we shouldn’t apply the attention challenge to every user. <strong>Most desirable method is to wisely apply the attention challenge to the appropriate targets, tailored to the level of security each rollup wants to achieve.</strong> If fast withdrawals and cross-rollup transactions are actively made, the attention challenge may not need to be applied(assuming that the proportion of intermediaries who choose strategic safety is sufficient). However, there could only be a few fast withdrawals and cross-rollup transactions in the early stage of a rollup, and the number of active verifiers might be too low. In such cases, the attention challenge can be of great help in keeping the rollup secure.</p>\n<h3>Additional Reward to Attention Challenge</h3>\n<p>The attention challenge is a very effective way to maximize security, but it imposes verification as a punishment, a sort of negative feedback to the verifier. The verifier chooses the verification strategy because of the attention challenge, but not only there is no additional reward for this verification, further costs are also incurred during the process. Thus, all verifiers will consider the application of the attention challenge from a negative perspective.</p>\n<p>However, if additional rewards could be paid to verifiers who are targeted for the attention challenge, individual verifiers would be able to mitigate the economic costs incurred by the attention challenge, or even earn more profits from it. For example, suppose there are tokens issued for building an ecosystem of a rollup, some of these tokens could be given as rewards to verifiers participating in the attention challenge. If the amount of rewards is higher than the cost of responding to the attention challenge, verifiers will consider the challenge as a blessing instead of a burden.</p>\n<p><em>We can collect additional fees from the users to pay the verifier as rewards. However, we will have to carefully adjust the amount of the additional fee so that it wouldn’t be a burden to the users.</em></p>\n<h3>Repeated Game</h3>\n<p>The verification games of Ivan and the sequencer so far were all one-shot games. However, many economic activities in the real world are repeated with interactions between the same parties. Likewise, the verification game in the world of rollup is not a one-shot game. Ivan and the sequencer will repeatedly play this game over and over several times. They will make strategic choices for the current stage of the repetitive game, depending on the history of the outcome of their actions before. In this respect, it is necessary to analyze the verification game of Ivan and the sequencer from the point of view of the repetitive game, not simply the one-shot game.</p>\n<p>First, it is well known that in an infinitely repeated game, the equilibrium can be different from one-shot game, or it can even have more than a single equilibrium. This is because it is difficult to deviate from a cooperative strategy, unlike one-shot games, or finitely repeated games. Players in infinitely repeated games usually choose the cooperative strategy in order not to break relationships with other players because the future loss that would occur from revenge attacks from the opponent could be higher than the profit received by deceiving the opponent in the present.</p>\n<p>However, in finitely repeated games, it is challenging to make players choose the cooperative strategy no matter how often the number of repeated games increases. Players in the finitely repeated games with a unique Nash equilibrium choose the same equilibrium of the one-shot game at each stage regardless of how many games are repeated.</p>\n<p>What we should pay attention here is how to categorize this game of Ivan and the sequencer. Before discussing whether the number of repeated games will be infinite or finite, let’s focus on the following question first.</p>\n<p>If the sequencer on one rollup did not execute transactions correctly, what would happen to the sequencer and Ivan (or the other verifiers)?</p>\n<p>First, let’s assume that the attack of the sequencer is verified within the DTD. In this case, the sequencer will lose all or a portion of its deposit and any right they might possess to manage that rollup. Ivan will receive a portion of the sequencer’s deposit as a reward. What will happen to the verification game after that? It ends!</p>\n<p>For our next scenario, let’s assume that the attack was “found” after the DTD. Ivan, who has already sent tokens to the sequencer through the fast withdrawal, checks the tokens that the sequencer gave him in L2 after the DTD, but will soon come to know that they are invalid tokens. At this point, what happens to the sequencer and Ivan? Ivan has already lost his tokens from the fast withdrawal which has not been verified within the DTD, so he will not be able to receive any compensation. What about the sequencer? Although it may differ according to the predetermined rules of each rollup, at least the role of the sequencer will be suspended afterwards, even if the deposit cannot be slashed, and the invalid states cannot be changed to valid ones. In other words, even in this case, the subsequent verification game ends.</p>\n<p><em>If you, as a store owner, discovered after a long time that the clerk had embezzled, would you let the clerk continue to run the store afterwards? If you weren’t an angel, definitely you would fire the clerk even if a long time has passed since, and you cannot be held financially responsible for theft.</em></p>\n<p>From the two scenarios above, we can observe that the moment the sequencer attacks, the repeated games end regardless of whether it is verified or not. Through this, we can see that it is more reasonable to assume that the game will be repeated finitely, although the number of repetitions cannot be accurately known in advance.</p>\n<p><strong>Therefore, it is more rational to define the game of Ivan and the sequencer as a finitely repeated game rather than an infinitely repeated game, and thus it can be seen that the equilibrium in a one-shot game will be repeated at every stage.</strong></p>\n<h3>Related Research</h3>\n<p>As discussed before, the verifier’s dilemma is not a new issue, and it has already been discussed in various areas. Many researchers have already tried to find a solution to it.</p>\n<p>In this chapter, we will examine various solutions proposed to solve the verifier’s dilemma on many different platforms.</p>\n<h3>Forced Error &amp; Jackpot — Truebit</h3>\n<p>In order to understand how the forced error and jackpot concept work, we must grasp a solid concept of what <a href="https://truebit.io/">Truebit</a> is. Truebit is a type of scalability solution that uses off-chain computations. In Truebit, large computation tasks that need an Ethereum block gas limit even higher than current block gas limit, can be executed correctly off chain.</p>\n<p>The participants of the Truebit protocol are largely classified into three types, and the roles and responsibilities that each participant are as follows.</p>\n<p>1. Task Giver</p>\n<ul>\n<li>Requests the solver to execute a complex transaction.</li>\n<li>For requesting a task, the task giver must pay a fee to the solver.</li>\n</ul>\n<p>2. Solver</p>\n<ul>\n<li>Executes a requested task (transaction) off-chain.</li>\n<li>Deposit a certain amount of tokens for acting as a/the solver.</li>\n<li>If it is proved that the execution was invalid, the deposit is slashed.</li>\n</ul>\n<p>3. Verifier</p>\n<ul>\n<li>Verifies that the task has been executed correctly.</li>\n<li>If the task was not executed correctly, the verifier deposits a certain amount of tokens and requests to play a verification game to prove it.</li>\n<li>If the verifier wins the verification game, the solver’s deposit is given as a prize to the verifier.</li>\n</ul>\n<p>What you can see here is that the role of the verifier is crucial for the Truebit protocol to perform safely. This is because, if the verifier does not properly verify that the task has been executed correctly, we cannot ensure that the solver will always execute tasks correctly, and submit only valid results on-chain. Therefore, what we should focus on is whether the verifier in Truebit is always willing to verify or not.</p>\n<p>Those who can read between the lines would assume that the payoff of the verifier in the Truebit protocol would have a similar structure to that of the super-simple game discussed above: this assumption is accurate.</p>\n<p>If the probability of the solver submitting an invalid result is X, then the expected payoff of the verifier in Truebit can be expressed as:</p>\n<ol>\n<li>Expected payoff of verification: R*X-C</li>\n<li>Expected payoff of non-verification: <em>0 (The verifier has no explicit penalty even if he does not verify the solver.)</em>\n</li>\n</ol>\n<p>It is now very obvious that in such a model, it is difficult to grant the incentives for verification. Certainly, the architects of the Truebit protocol were also aware of this. To solve this problem, they introduced Forced Error and Jackpot method.</p>\n<p>The biggest cause of the verifier’s dilemma in Truebit is that the verifier’s reward also depends on the attack probability of the solver. It is the forced error that solves this. The forced error refers to an error that is deliberately, and randomly generated by the system regardless of whether or not the solver attacked. i.e. even if the solver does not attack, a forced error occurs randomly, so the verifier can verify and get rewarded.</p>\n<p>Since the deposit of the solver cannot be used to give rewards for the forced errors, it is necessary to make a new reward pool called the jackpot. Per each request, task givers pay a separate tax in addition to the fee paid to the solver, and this tax is gathered in the jackpot reward pool.</p>\n<p>In short, to collect funds for the jackpot, an additional fee is received from the user, and the reward is distributed to the verifier who successfully verified the forced error that is generated randomly.</p>\n<p>Jackpot rewards are given to any verifier who verifies the forced error within a set period of time. However, because of the sybil attack, which exploits jackpot rewards by creating a large number of duplicate verifier accounts, Truebit has designed a technique to reduce the distribution of rewards exponentially in proportion to the number of accounts that have verified the forced error. The exact jackpot reward distribution is calculated as follows.</p>\n<ul><li>J/2^(k-1) (k = Number of verifier accounts who verified forced error)</li></ul>\n<p>If the probability of a forced error is P, when P*J/2^(k-1) &gt; C, all verifiers always have an incentive to verify. Since the values of P and J are system variables that can be determined by the protocol, unlike the X, Truebit can easily make verifiers verify the solvers at any time.</p>\n<p>The jackpot model has the above advantages, but on the contrary, the following issues also exist.</p>\n<ol>\n<li><strong>Unpredictable rewards</strong></li>\n<li><strong>Charges additional fees to users</strong></li>\n</ol>\n<p>The first issue is that the events of forced errors can only be predicted probabilistically. If you are lucky, you might be rewarded with only one verification, or you might not even be able to receive any reward after hundreds of verifications. The expected reward is predictable, but since the jackpot is like a lottery, there is an inadequate aspect to attract the constant participation of verifiers. For more information on this, please check the <a href="https://www.deconlab.io/simulation-of-truebit-protocol-part-1/">article written by Decon</a>.</p>\n<p>Secondly, in order for the jackpot model to operate as intended, it is essential to collect funds for the jackpot reward pool above all else. If the reward pool isn’t large enough, it won’t be possible to provide proper incentives to verifiers. However, since the whole jackpot reward is borne by the task giver, it means that in order to increase the size of the reward, the task giver must inevitably pay an additional fee.</p>\n<h3>Application to Rollup</h3>\n<p>The forced error and jackpot model has several issues, but it is still valuable in that it can increase the incentive for verification by setting the expected reward for verification higher than the verification cost.</p>\n<p>However, it is not easy to use this to solve the verifier’s dilemma in the rollup because it is not easy to collect additional fees, and the rollup is not suitable for generating the forced error.</p>\n<p>First, collecting additional fees from users could be burdensome to them, and will undermine the UX. As an alternative to this, native tokens issued at the ecosystem level of the rollup can be used for the fund. However, not all rollups can issue these tokens, and since jackpot rewards are completely dependent on the value of the tokens issued in the ecosystem, there may be additional risks in terms of security.</p>\n<p>Secondly, the rollup has a very tricky structure to generate forced errors. In Truebit, the solver has to submit both correct and incorrect solutions to L1. If the forced error needs to be generated, the incorrect solution is designated by the solver, and on the other-hand, if there is no need for a forced error, the correct solution is designated. In Truebit, since the tasks requested by givers are independent and unique tasks, it is not a problem to generate forced errors this way.</p>\n<p>In the case of rollup, if we generate forced error, subsequent transactions must be executed based on the incorrect states. Otherwise, anyone can easily detect that a forced error has occurred. In addition, since the subsequent transactions are executed based on invalid states, all consequent state values will also become invalid.</p>\n<h3>Multiple Solvers — Truebit</h3>\n<p><a href="https://arxiv.org/pdf/1806.11476.pdf">Multiple solvers</a> is a newly proposed method to solve several shortcomings of the jackpot model, and to completely solve the verifier’s dilemma in Truebit. There are three types of participants in the jackpot model; task giver, solver, and verifier, but in the multiple solvers model, there are only the task giver and the solver. It has multiple solvers to prevent any attacks by a small number of malicious solvers.</p>\n<p>In the multiple solvers model, when a task giver asks for a task, a number of solvers randomly selected from the solver pool are assigned to the task. Each solver submits a solution, and a proof of independent execution for the task. Proof of independent execution is the process of proving that each solver has solved the task on its own. <em>How the proof of independent execution generated is described </em><a href="https://arxiv.org/pdf/1806.11476.pdf"><em>here</em></a><em>. </em>This allows each solver to prove that they have not replicated the solutions of other solvers.</p>\n<p>If all solvers assigned to a task do not submit the correct solution, or the proof of independent execution, they can be challenged by another solver, or an external verifier (anyone can still verify even if they are not solvers assigned to the task) and their deposit can be slashed.</p>\n<p>However, if each solver executes the task correctly, they can receive a fee as a reward, and if this fee is higher than the verification cost, it can be said that solvers always have an incentive to execute the task correctly. In other words, the architects of Truebit found that the verification and the process of solving are not inherently different, and resolved the verifier’s dilemma by giving explicit rewards for them.</p>\n<p>However, having multiple solvers results in one fatal drawback: <strong>it is too expensive</strong>. A higher level of security can be guaranteed as the number of solvers assigned to each task increases but it also means that the fees paid to the solvers will inevitably increase.</p>\n<p>Therefore, Truebit allows task givers to pay fees according to the desired level of security. If you require a higher level of security, you can pay a higher fee to get more solvers for the task. Otherwise you can pay a minimal fee to get a few solvers for the task.</p>\n<h3>Application to Rollup</h3>\n<p>The core idea of the multiple solvers is not to separate the solver and the verifier, but to integrate them into one, and to directly reward the action of solving (verifying) the task. To apply a similar method in the rollup, we have to appoint multiple sequencers instead of one, execute transactions independently, and submit the corresponding state root ​​to the layer 1.</p>\n<p>The important point is that in order to keep the rollup as secure as possible, it is necessary to reward the multiple sequencers appropriately. This reward can be accumulated largely by collecting additional fees from users, or by issuing native tokens of the ecosystem to the reward pool. However, for a higher level of security, more fees and token rewards are required, so it is necessary to specifically establish an appropriate level of security and costs.</p>\n<p>Additionally, in the multiple solvers model, transactions on layer 1 for submitting state roots, ​​and the proof of independent execution could be increased linearly as the number of sequencers grows. Note that this may conflict with the main purpose of the rollup, which is to maximize the scalability of layer 1.</p>\n<h3>Attention Challenge — Arbitrum</h3>\n<p><a href="https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e">Attention Challenge</a> is an approach to resolve the verifier’s dilemma by punishing verifiers who do not properly perform verification work. The key to the attention challenge is not to encourage verification by giving additional rewards to the verifier, but to make the task of verification inevitable and inflict significant losses on the verifier if the verification is not performed.</p>\n<p>Let’s refer to the Super-simple model we covered earlier to see in detail how the attention challenge works. In this simple model, there are two participants, the asserter and the verifier. The task of the asserter is to compute a certain function f(x), and submit x, and only the encrypted value of f(x). The verifier’s duty is to check x and submit the correct f(x). If the verifier submits incorrect values ​​or does not respond in time, deposit of the verifier will be slashed.</p>\n<p>For responding to the attention challenge, verifiers must submit transactions on-chain, and this would be a heavy burden on both the layer 1 and the verifier. So, the attention challenge is not consistently applied to each verifier, but only probabilistically. However, it is designed in a way that the verifiers can only check whether they are the target of the attention challenge only after performing the verification work by themselves. Therefore, verifiers always have to do verification to check if they are selected as respondents to the attention challenge.</p>\n<p><em>For technical details on how f(x) is encrypted, and how each verifier checks whether they are selected as respondent to the attention challenge, please check this </em><a href="https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e"><em>article</em></a><em>.</em></p>\n<p>When applying the attention challenge to the super-simple model, the expected verification and non-verification payoff of the verifier are changed as follows.</p>\n<ol>\n<li>Expected payoff for verification: R*X-C</li>\n<li>Expected payoff for non-verification: -L*X -P<em>*</em>A</li>\n</ol>\n<p><em>P is the probability of being designated as the target of the attention challenge, and A is the amount of tokens slashed when an incorrect response is submitted.</em></p>\n<p>If P*A &gt; C, the best strategy for the verifier is to always verify regardless of X. Since values of P and A can be controlled by the system, it can easily force the verifiers to always verify.</p>\n<p>Attention challenges are very attractive, in that they do not incur additional costs for the user, and can make the verifier always perform the verification. However, there is one blind spot in the attention challenge: if the verifier verifies, but the assertor does not perform any attacks, then in all cases, there is only loss for the verifier.</p>\n<p>For example, under the conditions below, the expected payoff of the verifier can be expressed as follows.</p>\n<ul>\n<li>R = 100</li>\n<li>L = 10</li>\n<li>X = 0</li>\n<li>C = 1</li>\n<li>P*A = 5</li>\n</ul>\n<ol>\n<li>Expected payoff for verification = -1</li>\n<li>Expected payoff for non-verification = -5</li>\n</ol>\n<p>In this case, the verifier will perform the verification because the expected payoff to verify (-1) is greater than the expected payoff not to verify (-5). However, there is one <strong>trap</strong>. Whatever choice is made, the verifier faces <strong>pure loss</strong>! In other words, the verifier is in a situation where he suffers a small loss in order to avoid a larger loss. We cannot systematically enforce the verifier to be in such a situation without an alternative. If the verifier wishes, he should have the freedom to abandon the verifier’s role, withdraw the deposit, and leave the system.</p>\n<p>If you were this verifier, what would have been your choice? Would you like to remain in this system and continue verification, awaiting unclear returns, or just give up and leave because there is no reward and only costs for you anyway? It is certain that everyone will choose the latter.</p>\n<p>What we can observe from this example is that attention challenge can lead the verifier to always choose a verification strategy in the short run, but it does not convince the verifier to continue to remain in the system in the long run.</p>\n<p>So, is the attention challenge of no use? Not quite. The attention challenge is very effective in solving the verifier’s dilemma. However, it is effective only when the verifiers can earn a certain amount of profits related to, or not related to the verification work.</p>\n<p>For example, if the verifier earns a constant return F for each verification unit, when F-C &gt; -P*A, it is difficult for the verifier to find a reason not to continue the verification. We know one model in which these conditions can be applied. It is the optimistic rollup!</p>\n<h3>Application to Rollup</h3>\n<p>In the rollup, the role of the verifier is not clearly distinguished, but any user can be the verifier at their will. Some of these users earn a certain profit for each transaction, which is called the verification unit. For example, a user doing yield farming on a rollup, or a developer running a DEX can earn a certain amount of revenue each time a transaction is executed. In these cases, applying the attention challenge can make these users reliably verify the rollup. Details on this matter have already been dealt with previously, so additional explanations will be omitted.</p>\n<h3>Why do I care so much about Verifier’s Dilemma?</h3>\n<p>This article continues to argue that in order to ensure security for all users of the rollup, it is necessary to consider the verifier’s dilemma, and to come up with appropriate solutions. Several reasons for this have been presented above, but there may still be disagreements from the community. This is only a theoretical aspect, and indeed, when rollups are actively adopted and used, the verifier’s dilemma may not be a big problem. There are altruistic people in the world who help others even if they don’t receive monetary incentives. There are also people who choose to give up a little bit of their profit for others rather than maximizing their profit. A similar situation could happen in the rollup too.</p>\n<p><strong>What I would like to suggest in this article is not the fact that the rollup has to be at risk if it doesn’t take the verifier’s dilemma into account. However, if it is not considered in advance, even if it rarely happens, in the event of an unexpected crisis, the security of the rollup “could be at huge risk”.</strong></p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ij2Yvb-Au_dsjK8N"><figcaption>(Source: Shutterstock)</figcaption></figure><p>Let’s take our focus away from the rollup for a moment. For example, say we are designing a car for citizens living in a modern city. Since this car will probably only run on well-maintained urban roads, we don’t have to struggle to make it work well in extreme environments. It doesn’t have to be a four-wheel drive, and there’s no need to add expensive shock-absorbing suspensions, as it most certainly won’t fall from high drops. It won’t have to run through the desert, or heavy snow and rains, so we don’t have to consider sand dust, pay much attention to heavy snow and heavy rain conditions. The roads will always be well maintained, so even an ordinary car can run well.</p>\n<p>On the other hand, if we want to design a car that can always run well without any problems in any kind of extreme environment, the story is completely different. If there are not enough safety mechanisms, the lives of the driver and passengers can be seriously threatened in such environments. For this reason, even if the design becomes complex and additional costs are incurred, designing the car to be as safe as possible is a top priority. A car designed in this way, of course, can also be driven in an urban environment perfectly but the various costs and equipment involved in this car may feel a bit unnecessary and excessive for the customers/users. However, this car will do its best when faced with extreme conditions. When there is a sudden heavy snowfall, and all the other cars can’t move, this car will smoothly drive forward without any problems.</p>\n<p>Coming back to the topic of rollup and blockchain, which of these two cars do you think is close to rollup? I trust anyone who believes in blockchain will agree that rollup, along with all blockchain technologies, are closer to the latter in nature. Blockchain technology seeks to <a href="https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274">overcome all extreme environments that the system may face (fault tolerance, attack resistance, collusion resistance) through decentralization </a>as rare as they might be. Rollup is a technology that implements the ability to cope with extreme situations similar to those of Layer 1, and simultaneously increases the insufficient scalability of Layer 1 significantly. Therefore, we need to work hard to ensure that the rollup can cope well with all extreme environments.</p>\n<h3>Conclusion</h3>\n<p>Optimistic rollup is a layer 2 solution that is expected to be able to drastically solve the current scalability issue of Ethereum in the short, medium and even long term. Many types of layer 2 solutions have been proposed to date, and in particular, zk-rollup, powered by validity proof, is in the spotlight since it can provide instant finality, unlike optimistic rollup. However, there are obvious limitations at this point in processing all complex transactions in Ethereum with zk-rollup, so for the time being, the main realistic alternative for Ethereum will be the optimistic rollup.</p>\n<p>In the near future, the optimistic rollup will be widely used and adopted massively. As the number and the size of rollups increase, the security issue will become more and more important. As we continue to emphasize, rollup is a very attractive Layer 2 solution in that the system can be kept secure with just one honest verifier.</p>\n<p>However, as we discussed throughout this article, in rollup, verifiers have a higher incentive to not verify if the attack probability is fairly low. In other words, as the need for the rollup to operate safely increases with time, the number of active verifiers will decrease rapidly. Intermediaries of fast withdrawal and cross-rollup transfer are no exception. In short, the rollup will, paradoxically, become more vulnerable as it gets safer. But we know one solution; the proper application of the attention challenge. We can ensure the security of the rollup via the attention challenge.</p>\n<p>Certainly, this article does not insist that the attention challenge must be applied to all rollups. There will be a different target level of security for each rollup, and there will be assumptions about the disposition of the participants. If it is not necessary to guarantee high security, or if the proportion of altruist and extremely risk-averse participants is considered to be high enough, it is not necessary to apply the attention challenge. The important concept here is using only the necessary and appropriate tools for each purpose. I hope this article will guide you even a little when designing the security of each rollup.</p>\n<h3>Glossary</h3>\n<ul>\n<li>Sequencer: Determines the order of transactions in the optimistic rollup, and submits state roots ​​and transaction data to layer 1 after executing those transactions on layer 2. Also called as Operator.</li>\n<li>Verification: In optimistic rollup, refers to verifying that the state root submitted by the sequencer is valid or not.</li>\n<li>Verifier: An entity who performs the verification. In the optimistic rollup, any participant can be a verifier.</li>\n<li>DTD (Dispute Time Delay): Refers to the period of time required for a state root or an execution result to be finalized in the fraud proof system.</li>\n<li>Fraud Proof: Refers to a set of systems which assumes that the result of execution is correct first, and then provides a way to verify that the result value is correct within a certain period of time (DTD).</li>\n<li>Validity Proof: Refers to a system which proves that the result of execution is correctly configured. No DTD is required for validity proof.</li>\n<li>Attack: Usually means taking an economic advantage by submitting an incorrect state root, or execution result to layer 1. In optimistic rollup, the sequencer can take over assets from users by inducing finalizations of incorrect state roots.</li>\n<li>Challenge: Refers to a set of steps to change an incorrect state root or execution result to a correct one via fraud proof. In the optimistic rollup, anyone can apply for a challenge to prove that the state root submitted by the sequencer is invalid.</li>\n</ul>\n<h3>References</h3>\n<ul>\n<li><a href="https://eprint.iacr.org/2015/702.pdf">https://eprint.iacr.org/2015/702.pdf</a></li>\n<li><a href="https://medium.datadriveninvestor.com/cryptonomics-understanding-the-vertifiers-dilemma-in-crypto-assets-30c65259865b">https://medium.datadriveninvestor.com/cryptonomics-understanding-the-vertifiers-dilemma-in-crypto-assets-30c65259865b</a></li>\n<li><a href="https://medium.com/offchainlabs/the-cheater-checking-problem-why-the-verifiers-dilemma-is-harder-than-you-think-9c7156505ca1">https://medium.com/offchainlabs/the-cheater-checking-problem-why-the-verifiers-dilemma-is-harder-than-you-think-9c7156505ca1</a></li>\n<li><a href="https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e">https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e</a></li>\n<li><a href="https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e">https://medium.com/offchainlabs/cheater-checking-how-attention-challenges-solve-the-verifiers-dilemma-681a92d9948e</a></li>\n<li><a href="https://offchainlabs.com/Arbitrum_Rollup_Whitepaper.pdf">https://offchainlabs.com/Arbitrum_Rollup_Whitepaper.pdf</a></li>\n<li><a href="https://www.deconlab.io/simulation-of-truebit-protocol-part-1/">https://www.deconlab.io/simulation-of-truebit-protocol-part-1/</a></li>\n<li><a href="https://medium.com/decon-lab/simulation-of-truebit-protocol-part-1-9a126280172f">https://medium.com/decon-lab/simulation-of-truebit-protocol-part-1-9a126280172f</a></li>\n<li><a href="https://www.deconlab.io/simulation-of-truebit-protocol-part-2/">https://www.deconlab.io/simulation-of-truebit-protocol-part-2/</a></li>\n<li><a href="https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf">https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf</a></li>\n<li><a href="https://github.com/TruebitProtocol/wiki">https://github.com/TruebitProtocol/wiki</a></li>\n<li><a href="https://people.cs.uchicago.edu/~teutsch/papers/stableCPU.pdf">https://people.cs.uchicago.edu/~teutsch/papers/stableCPU.pdf</a></li>\n<li><a href="https://medium.com/truebit/truebit-the-marketplace-for-verifiable-computation-f51d1726798f">https://medium.com/truebit/truebit-the-marketplace-for-verifiable-computation-f51d1726798f</a></li>\n<li><a href="https://arxiv.org/pdf/1806.11476.pdf">https://arxiv.org/pdf/1806.11476.pdf</a></li>\n<li><a href="https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf">https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-kalodner.pdf</a></li>\n<li><a href="https://research.paradigm.xyz/rollups">https://research.paradigm.xyz/rollups</a></li>\n<li><a href="https://vitalik.ca/general/2021/01/05/rollup.html">https://vitalik.ca/general/2021/01/05/rollup.html</a></li>\n<li><a href="https://www.youtube.com/watch?v=wcCHlqgGSH4">https://www.youtube.com/watch?v=wcCHlqgGSH4</a></li>\n<li><a href="https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788">https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788</a></li>\n<li><a href="https://medium.com/offchainlabs/meva-what-is-it-good-for-de8a96c0e67c">https://medium.com/offchainlabs/meva-what-is-it-good-for-de8a96c0e67c</a></li>\n</ul>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=cb23e6e6f11c" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/optimistic-rollup-is-not-secure-enough-than-you-think-cb23e6e6f11c">Optimistic Rollup is Not Secure Enough Than You Think[EN]</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                enclosure: {},
                categories: [
                  "opinion",
                  "research",
                  "layer-2",
                  "ethereum",
                  "optimistic-rollup",
                ],
              },
              {
                title: "옵티미즘 초보자 가이드 3편 : ERC721 써보기",
                pubDate: "2021-05-20 05:32:27",
                link:
                  "https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d?source=rss----eb8117f0bafd---4",
                guid: "https://medium.com/p/bb647362ec5d",
                author: "Darren K",
                thumbnail:
                  "https://cdn-images-1.medium.com/max/1024/1*24AMI1ETvBG2CCTRX3scYQ.png",
                description:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*24AMI1ETvBG2CCTRX3scYQ.png"></figure><h3>TL;DR</h3>\n<h4>Run optimistic rollup</h4>\n<pre>$ cd optimism/ops<br>$ docker-compose up -d</pre>\n<h4>Build repository</h4>\n<pre>$ cd ../ <br>$ git clone <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git</a><br>$ cd l1-l2-deposit-withdrawal <br>$ yarn &amp;&amp; yarn compile</pre>\n<h4>Test ERC721 L1 &lt;&gt; L2</h4>\n<pre>$ node ./example.721.js</pre>\n<p>옵티미스틱 롤업 사용하기 시리즈는 총 세 개의 포스팅으로 구성됩니다.</p>\n<blockquote>\n<a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">옵티미스틱 롤업 사용하기</a><br><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">옵티미스틱 롤업에서 ERC20 사용하기</a><br><strong>옵티미스틱 롤업에서 ERC721 사용하기</strong>\n</blockquote>\n<h3>소개</h3>\n<p>옵티미스틱 롤업은 스마트 컨트랙트를 지원하는 레이어2 솔루션이기 때문에, 이더리움 메인넷과 마찬가지로 ERC20 토큰 뿐만 아니라 ERC721 토큰 등 여러 토큰 컨트랙트를 지원할 수 있습니다. 지난 포스팅에서는 옵티미스틱 롤업에서 ERC20 토큰을 사용하기 위해 레이어1의 ERC20 토큰을 예치하고 인출하는 방법을 살펴보았고, 그 과정에서 optimism 저장소 내의 게이트웨이 컨트랙트들을 사용했습니다. 이 포스팅에서는 옵티미스틱 롤업에서 ERC721 토큰을 예치하고 인출하는 것에 대해 살펴보면서 ERC20 외 다른 종류의 토큰들을 어떻게 지원할 수 있는지 알아보겠습니다.</p>\n<blockquote>옵티미스틱 롤업은 web3.js 대신 ethers.js를, truffle 대신 hardhat을 사용하고 있습니다. ethers.js와 hardhat 등은 web3와 truffle 등과 비교했을 때 여러 장점들이 있어 최근 많은 스마트 컨트랙트 프로젝트에서 사용하고 있습니다.</blockquote>\n<h3>저장소 정보</h3>\n<p>Optimistic rollup repository : <a href="https://github.com/ethereum-optimism/optimism">https://github.com/ethereum-optimism/optimism</a></p>\n<p>Commit : 751e2be</p>\n<p>Test repository : <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal/tree/feature/erc721">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal</a></p>\n<p>Commit : a00fb50</p>\n<h3>인출/예치</h3>\n<p>옵티미스틱 롤업의 ERC721 토큰 이동은 ERC20 토큰과 같은 인터페이스, 같은 흐름으로 이루어집니다. 토큰의 레이어1, 레이어2이동 외의 차이점은 토큰 자체 기능의 차이점이 있습니다. 이번 포스팅에서는 ERC721 토큰의 L1 &lt;&gt; L2 이동을 살펴 보면서, ERC20 토큰과 비교해 어떤 부분이 같고 어떤 부분이 달라지는지 살펴보겠습니다.</p>\n<h4>컨트랙트와 서비스 설정</h4>\n<p>테스트 코드 시작 부분의 초기 설정은 ERC20의 테스트 코드를 그대로 사용합니다.</p>\n<a href="https://medium.com/media/51c2f782f2c2352e9bbbd31df238b12f/href">https://medium.com/media/51c2f782f2c2352e9bbbd31df238b12f/href</a><p>초기 설정 후 필요한 컨트랙트를 배포합니다. 배포되는 컨트랙트는 ERC20의 경우와 마찬가지로 세 개인데, ERC721을 사용하는 컨트랙트들을 배포합니다.</p>\n<ul><li>L1_ERC721(레이어1 배포)</li></ul>\n<p>테스트에 사용할 ERC721 토큰 컨트랙트입니다. 옵티미스틱 롤업에서 필요한 기능이 추가된 것이 아닌, 최소한의 기능만 구현된 일반적인 ERC721 컨트랙트입니다. L1_ERC721 토큰 컨트랙트 배포 후 ID 1234 토큰을 발행합니다.</p>\n<ul><li>L1_ERC721Gateway(레이어1 배포)</li></ul>\n<p>레이어1에서 L1_ERC721 토큰의 게이트웨이 역할을 담당하는 컨트랙트입니다. 이 컨트랙트는 이전 포스팅의 ERC20 토큰 이동 테스트에서 사용했던 L1_ERC20Gateway 컨트랙트를 이름만 바꿔 그대로 사용했는데, 토큰 게이트웨이 역할에 필요한 함수의 인터페이스를 동일하게 사용하기 때문에 가능합니다.</p>\n<blockquote><em>ERC721의 표준은 transfer 함수를 포함하지 않지만, 테스트의 편의성을 위해 테스트용 ERC721 토큰에는 transfer 함수를 구현해놓았습니다. 옵티미즘의 L1_ERC20Gateway 컨트랙트에서는 사용자가 레이어2의 토큰을 인출 할 때 토큰의 transfer 함수를 호출해서 사용자에게 토큰을 전송합니다. 따라서 이 포스팅의 테스트에서는 테스트용 ERC721 토큰 컨트랙트에 transfer 함수를 구현하고 L1_ERC20Gateway 컨트랙트를 그대로 사용했지만, transfer 함수가 없는 ERC721 토큰 컨트랙트를 옵티미스틱 롤업에 적용할 경우 L1_ERC721Gateway 컨트랙트를 구현하고 transfer 함수가 아닌 transferFrom 등의 함수를 호출하도록 해야합니다.</em></blockquote>\n<ul><li>L2_ERC721(레이어2 배포)</li></ul>\n<p>레이어2에 배포되는 ERC721 토큰 컨트랙트입니다. L1_ERC721 컨트랙트는 단순한 ERC721 토큰 컨트랙트이지만, L2_ERC721 토큰 컨트랙트는 옵티미스틱 롤업의 Abs_L2DepositedToken 컨트랙트를 상속 받고 필요한 기능이 구현된 컨트랙트입니다. Abs_L2DepositedToken 컨트랙트에는 L1 &lt;&gt; L2 이동시 호출되는 함수의 인터페이스가 정의되어 있습니다.</p>\n<a href="https://medium.com/media/d2cd9ebb2c38e2a3146f741b89ece32c/href">https://medium.com/media/d2cd9ebb2c38e2a3146f741b89ece32c/href</a><p>필요한 컨트랙트들의 배포와 초기 설정을 마친 뒤, 본격적인 테스트를 시작하기 전에 토큰 잔고를 확인하는 부분입니다. 테스트에 사용할 ERC721 토큰의 잔고를 레이어1과 레이어2에서 각각 출력하는 부분이며, 레이어1에서는 1개, 레이어2에서는 0개의 토큰을 가진 상태입니다.</p>\n<a href="https://medium.com/media/98e58b6f1748675be56fb0180f468768/href">https://medium.com/media/98e58b6f1748675be56fb0180f468768/href</a><h4>레이어1 토큰의 예치</h4>\n<p>레이어1에서 사용자가 가진 토큰을 예치하기 전에 approve 하고 L1_ERC721Gateway 컨트랙트의 deposit 함수를 호출하는 부분입니다. L1_ERC721Gateway 컨트랙트의 deposit 함수를 호출하면 사용자의 ERC721 토큰이 L1_ERC721Gateway 컨트랙트로 이동합니다.</p>\n<a href="https://medium.com/media/44e137ec3ed9d8f12a276f82db24c860/href">https://medium.com/media/44e137ec3ed9d8f12a276f82db24c860/href</a><p>위의 deposit 함수 실행 트랜잭션이 완료되면 사용자가 레이어1에서 가졌던 ERC721 토큰은 L1_ERC721Gateway 컨트랙트로 예치되지만, 이것이 레이어2로의 토큰 이동을 의미하지는 않습니다. 옵티미스틱 롤업의 data-transport-layer에서 예치 이벤트를 모니터링하고 Sequencer가 예치 정보를 레이어2에 반영하기까지의 후처리를 대기하는 것이 필요합니다. 아래 코드는 레이어1에서 예치한 정보가 레이어2에 반영되는 것을 대기하는 코드입니다.</p>\n<a href="https://medium.com/media/15b10d79dc799a68850052a438ab486e/href">https://medium.com/media/15b10d79dc799a68850052a438ab486e/href</a><p>레이어2의 반영이 완료된 뒤 아래와 같이 각 체인의 토큰 갯수를 확인하면 레이어1의 ERC721 토큰 갯수는 0개, 레이어2의 ERC721 토큰 갯수는 1개가 됩니다.</p>\n<a href="https://medium.com/media/f98f4e26afe1cb5367bbf05320190ee4/href">https://medium.com/media/f98f4e26afe1cb5367bbf05320190ee4/href</a><h4>레이어2 토큰의 출금</h4>\n<p>레이어2의 ERC721 토큰을 출금하여 레이어1으로 가져오는 부분입니다. 레이어2에서 L2_ERC721의 withdraw 함수를 호출하면 사용자가 레이어2에서 가진 ERC721 토큰이 소각됩니다.</p>\n<a href="https://medium.com/media/fb1465fdc255274bbd48052f00587aea/href">https://medium.com/media/fb1465fdc255274bbd48052f00587aea/href</a><p>사용자가 레이어2에서 갖고 있던 ERC721 토큰이 소각되면, 옵티미스틱 롤업의 Sequencer는 인출 내용을 레이어1에 반영합니다. 아래 코드는 레이어2의 withdraw 트랜잭션 실행 후 해당 내용이 레이어1에서 처리되는 것을 대기하는 코드입니다.</p>\n<a href="https://medium.com/media/700e89e2ebfeba8b5ef6497c3ae33be4/href">https://medium.com/media/700e89e2ebfeba8b5ef6497c3ae33be4/href</a><p>ERC721 토큰의 인출이 모두 완료 된 후 각 체인의 토큰 잔액을 조회하는 코드입니다. 레이어1에는 ERC721 토큰을 1개, 레이어2에는 ERC721 토큰을 0개 소유한 것을 볼 수 있습니다.</p>\n<a href="https://medium.com/media/1b909e1587ab2a0d620175b8a0416dc2/href">https://medium.com/media/1b909e1587ab2a0d620175b8a0416dc2/href</a><h3>테스트</h3>\n<h4>Run optimistic rollup</h4>\n<p>ERC721 토큰의 예치/인출 테스트에 앞서 아래와 같이 테스트에서 필요한 환경을 구성합니다. 옵티미스틱 롤업의 빌드를 하지 않은 상태라면 이전 포스팅을 따라 환경 설치를 해주셔야 합니다.</p>\n<pre>$ cd optimism/ops<br>$ docker-compose up -d</pre>\n<h4>Build repository</h4>\n<p>테스트에 필요한 저장소를 받고 빌드합니다. 이 저장소는 옵티미스틱 롤업의 ERC20 토큰 테스트를 위한 저장소에서 ERC721 테스트를 추가한 저장소입니다.</p>\n<pre>$ cd ../<br>$ git clone <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git</a><br>$ cd l1-l2-deposit-withdrawal<br>$ yarn &amp;&amp; yarn compile</pre>\n<h4>Test ERC721 L1 &lt;&gt; L2</h4>\n<p>테스트를 실행합니다.</p>\n<pre>$ node ./example.721.js</pre>\n<h4>Result</h4>\n<p>테스트가 정상적으로 종료되면 아래와 같은 결과를 보실 수 있습니다. ERC721의 balanceOf는 특정 주소가 소유한 ERC721 토큰의 갯수를 반환합니다.</p>\n<pre>Deploying L1 ERC721...<br>Deploying L2 ERC721...<br>Deploying L1 ERC721 Gateway...<br>Initializing L2 ERC721...<br>Balance on L1: 1<br>Balance on L2: 0<br>Approving tokens for ERC721 gateway...<br>Depositing tokens into L2 ERC721...<br>Waiting for deposit to be relayed to L2...<br>Balance on L1: 0<br>Balance on L2: 1<br>Withdrawing tokens back to L1 ERC721...<br>Waiting for withdrawal to be relayed to L1...<br>Balance on L1: 1<br>Balance on L2: 0</pre>\n<h3>정리</h3>\n<p>현재 옵티미스틱 롤업의 토큰 게이트웨이 컨트랙트는 ERC20 토큰만 지원하지만, 동일한 방식으로 ERC721 토큰도 지원하도록 해보았습니다. 물론 ERC721 토큰 전용 게이트웨이 컨트랙트도 추후 옵티미스틱 롤업에서 자체적으로 구현되어 추가될 여지는 있습니다. 여기서 중요한 점은, 옵티미스틱 롤업에서 L1 &lt;&gt; L2 이동을 지원하는 형식의 토큰이 아니더라도 충분히 커스터마이징하여 게이트웨이 컨트랙트를 구현하고 기능을 지원할 수 있다는 점입니다.</p>\n<h3>참조</h3>\n<p><a href="https://github.com/ethereum-optimism/optimism">Optimism Monorepo</a></p>\n<p><a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal">Onther-Tech/l1-l2-deposit-withdrawal</a></p>\n<p><a href="https://github.com/ethereum-optimism/l1-l2-deposit-withdrawal">ethereum-optimism/l1-l2-deposit-withdrawal</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bb647362ec5d" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d">옵티미즘 초보자 가이드 3편 : ERC721 써보기</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                content:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*24AMI1ETvBG2CCTRX3scYQ.png"></figure><h3>TL;DR</h3>\n<h4>Run optimistic rollup</h4>\n<pre>$ cd optimism/ops<br>$ docker-compose up -d</pre>\n<h4>Build repository</h4>\n<pre>$ cd ../ <br>$ git clone <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git</a><br>$ cd l1-l2-deposit-withdrawal <br>$ yarn &amp;&amp; yarn compile</pre>\n<h4>Test ERC721 L1 &lt;&gt; L2</h4>\n<pre>$ node ./example.721.js</pre>\n<p>옵티미스틱 롤업 사용하기 시리즈는 총 세 개의 포스팅으로 구성됩니다.</p>\n<blockquote>\n<a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">옵티미스틱 롤업 사용하기</a><br><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">옵티미스틱 롤업에서 ERC20 사용하기</a><br><strong>옵티미스틱 롤업에서 ERC721 사용하기</strong>\n</blockquote>\n<h3>소개</h3>\n<p>옵티미스틱 롤업은 스마트 컨트랙트를 지원하는 레이어2 솔루션이기 때문에, 이더리움 메인넷과 마찬가지로 ERC20 토큰 뿐만 아니라 ERC721 토큰 등 여러 토큰 컨트랙트를 지원할 수 있습니다. 지난 포스팅에서는 옵티미스틱 롤업에서 ERC20 토큰을 사용하기 위해 레이어1의 ERC20 토큰을 예치하고 인출하는 방법을 살펴보았고, 그 과정에서 optimism 저장소 내의 게이트웨이 컨트랙트들을 사용했습니다. 이 포스팅에서는 옵티미스틱 롤업에서 ERC721 토큰을 예치하고 인출하는 것에 대해 살펴보면서 ERC20 외 다른 종류의 토큰들을 어떻게 지원할 수 있는지 알아보겠습니다.</p>\n<blockquote>옵티미스틱 롤업은 web3.js 대신 ethers.js를, truffle 대신 hardhat을 사용하고 있습니다. ethers.js와 hardhat 등은 web3와 truffle 등과 비교했을 때 여러 장점들이 있어 최근 많은 스마트 컨트랙트 프로젝트에서 사용하고 있습니다.</blockquote>\n<h3>저장소 정보</h3>\n<p>Optimistic rollup repository : <a href="https://github.com/ethereum-optimism/optimism">https://github.com/ethereum-optimism/optimism</a></p>\n<p>Commit : 751e2be</p>\n<p>Test repository : <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal/tree/feature/erc721">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal</a></p>\n<p>Commit : a00fb50</p>\n<h3>인출/예치</h3>\n<p>옵티미스틱 롤업의 ERC721 토큰 이동은 ERC20 토큰과 같은 인터페이스, 같은 흐름으로 이루어집니다. 토큰의 레이어1, 레이어2이동 외의 차이점은 토큰 자체 기능의 차이점이 있습니다. 이번 포스팅에서는 ERC721 토큰의 L1 &lt;&gt; L2 이동을 살펴 보면서, ERC20 토큰과 비교해 어떤 부분이 같고 어떤 부분이 달라지는지 살펴보겠습니다.</p>\n<h4>컨트랙트와 서비스 설정</h4>\n<p>테스트 코드 시작 부분의 초기 설정은 ERC20의 테스트 코드를 그대로 사용합니다.</p>\n<a href="https://medium.com/media/51c2f782f2c2352e9bbbd31df238b12f/href">https://medium.com/media/51c2f782f2c2352e9bbbd31df238b12f/href</a><p>초기 설정 후 필요한 컨트랙트를 배포합니다. 배포되는 컨트랙트는 ERC20의 경우와 마찬가지로 세 개인데, ERC721을 사용하는 컨트랙트들을 배포합니다.</p>\n<ul><li>L1_ERC721(레이어1 배포)</li></ul>\n<p>테스트에 사용할 ERC721 토큰 컨트랙트입니다. 옵티미스틱 롤업에서 필요한 기능이 추가된 것이 아닌, 최소한의 기능만 구현된 일반적인 ERC721 컨트랙트입니다. L1_ERC721 토큰 컨트랙트 배포 후 ID 1234 토큰을 발행합니다.</p>\n<ul><li>L1_ERC721Gateway(레이어1 배포)</li></ul>\n<p>레이어1에서 L1_ERC721 토큰의 게이트웨이 역할을 담당하는 컨트랙트입니다. 이 컨트랙트는 이전 포스팅의 ERC20 토큰 이동 테스트에서 사용했던 L1_ERC20Gateway 컨트랙트를 이름만 바꿔 그대로 사용했는데, 토큰 게이트웨이 역할에 필요한 함수의 인터페이스를 동일하게 사용하기 때문에 가능합니다.</p>\n<blockquote><em>ERC721의 표준은 transfer 함수를 포함하지 않지만, 테스트의 편의성을 위해 테스트용 ERC721 토큰에는 transfer 함수를 구현해놓았습니다. 옵티미즘의 L1_ERC20Gateway 컨트랙트에서는 사용자가 레이어2의 토큰을 인출 할 때 토큰의 transfer 함수를 호출해서 사용자에게 토큰을 전송합니다. 따라서 이 포스팅의 테스트에서는 테스트용 ERC721 토큰 컨트랙트에 transfer 함수를 구현하고 L1_ERC20Gateway 컨트랙트를 그대로 사용했지만, transfer 함수가 없는 ERC721 토큰 컨트랙트를 옵티미스틱 롤업에 적용할 경우 L1_ERC721Gateway 컨트랙트를 구현하고 transfer 함수가 아닌 transferFrom 등의 함수를 호출하도록 해야합니다.</em></blockquote>\n<ul><li>L2_ERC721(레이어2 배포)</li></ul>\n<p>레이어2에 배포되는 ERC721 토큰 컨트랙트입니다. L1_ERC721 컨트랙트는 단순한 ERC721 토큰 컨트랙트이지만, L2_ERC721 토큰 컨트랙트는 옵티미스틱 롤업의 Abs_L2DepositedToken 컨트랙트를 상속 받고 필요한 기능이 구현된 컨트랙트입니다. Abs_L2DepositedToken 컨트랙트에는 L1 &lt;&gt; L2 이동시 호출되는 함수의 인터페이스가 정의되어 있습니다.</p>\n<a href="https://medium.com/media/d2cd9ebb2c38e2a3146f741b89ece32c/href">https://medium.com/media/d2cd9ebb2c38e2a3146f741b89ece32c/href</a><p>필요한 컨트랙트들의 배포와 초기 설정을 마친 뒤, 본격적인 테스트를 시작하기 전에 토큰 잔고를 확인하는 부분입니다. 테스트에 사용할 ERC721 토큰의 잔고를 레이어1과 레이어2에서 각각 출력하는 부분이며, 레이어1에서는 1개, 레이어2에서는 0개의 토큰을 가진 상태입니다.</p>\n<a href="https://medium.com/media/98e58b6f1748675be56fb0180f468768/href">https://medium.com/media/98e58b6f1748675be56fb0180f468768/href</a><h4>레이어1 토큰의 예치</h4>\n<p>레이어1에서 사용자가 가진 토큰을 예치하기 전에 approve 하고 L1_ERC721Gateway 컨트랙트의 deposit 함수를 호출하는 부분입니다. L1_ERC721Gateway 컨트랙트의 deposit 함수를 호출하면 사용자의 ERC721 토큰이 L1_ERC721Gateway 컨트랙트로 이동합니다.</p>\n<a href="https://medium.com/media/44e137ec3ed9d8f12a276f82db24c860/href">https://medium.com/media/44e137ec3ed9d8f12a276f82db24c860/href</a><p>위의 deposit 함수 실행 트랜잭션이 완료되면 사용자가 레이어1에서 가졌던 ERC721 토큰은 L1_ERC721Gateway 컨트랙트로 예치되지만, 이것이 레이어2로의 토큰 이동을 의미하지는 않습니다. 옵티미스틱 롤업의 data-transport-layer에서 예치 이벤트를 모니터링하고 Sequencer가 예치 정보를 레이어2에 반영하기까지의 후처리를 대기하는 것이 필요합니다. 아래 코드는 레이어1에서 예치한 정보가 레이어2에 반영되는 것을 대기하는 코드입니다.</p>\n<a href="https://medium.com/media/15b10d79dc799a68850052a438ab486e/href">https://medium.com/media/15b10d79dc799a68850052a438ab486e/href</a><p>레이어2의 반영이 완료된 뒤 아래와 같이 각 체인의 토큰 갯수를 확인하면 레이어1의 ERC721 토큰 갯수는 0개, 레이어2의 ERC721 토큰 갯수는 1개가 됩니다.</p>\n<a href="https://medium.com/media/f98f4e26afe1cb5367bbf05320190ee4/href">https://medium.com/media/f98f4e26afe1cb5367bbf05320190ee4/href</a><h4>레이어2 토큰의 출금</h4>\n<p>레이어2의 ERC721 토큰을 출금하여 레이어1으로 가져오는 부분입니다. 레이어2에서 L2_ERC721의 withdraw 함수를 호출하면 사용자가 레이어2에서 가진 ERC721 토큰이 소각됩니다.</p>\n<a href="https://medium.com/media/fb1465fdc255274bbd48052f00587aea/href">https://medium.com/media/fb1465fdc255274bbd48052f00587aea/href</a><p>사용자가 레이어2에서 갖고 있던 ERC721 토큰이 소각되면, 옵티미스틱 롤업의 Sequencer는 인출 내용을 레이어1에 반영합니다. 아래 코드는 레이어2의 withdraw 트랜잭션 실행 후 해당 내용이 레이어1에서 처리되는 것을 대기하는 코드입니다.</p>\n<a href="https://medium.com/media/700e89e2ebfeba8b5ef6497c3ae33be4/href">https://medium.com/media/700e89e2ebfeba8b5ef6497c3ae33be4/href</a><p>ERC721 토큰의 인출이 모두 완료 된 후 각 체인의 토큰 잔액을 조회하는 코드입니다. 레이어1에는 ERC721 토큰을 1개, 레이어2에는 ERC721 토큰을 0개 소유한 것을 볼 수 있습니다.</p>\n<a href="https://medium.com/media/1b909e1587ab2a0d620175b8a0416dc2/href">https://medium.com/media/1b909e1587ab2a0d620175b8a0416dc2/href</a><h3>테스트</h3>\n<h4>Run optimistic rollup</h4>\n<p>ERC721 토큰의 예치/인출 테스트에 앞서 아래와 같이 테스트에서 필요한 환경을 구성합니다. 옵티미스틱 롤업의 빌드를 하지 않은 상태라면 이전 포스팅을 따라 환경 설치를 해주셔야 합니다.</p>\n<pre>$ cd optimism/ops<br>$ docker-compose up -d</pre>\n<h4>Build repository</h4>\n<p>테스트에 필요한 저장소를 받고 빌드합니다. 이 저장소는 옵티미스틱 롤업의 ERC20 토큰 테스트를 위한 저장소에서 ERC721 테스트를 추가한 저장소입니다.</p>\n<pre>$ cd ../<br>$ git clone <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git</a><br>$ cd l1-l2-deposit-withdrawal<br>$ yarn &amp;&amp; yarn compile</pre>\n<h4>Test ERC721 L1 &lt;&gt; L2</h4>\n<p>테스트를 실행합니다.</p>\n<pre>$ node ./example.721.js</pre>\n<h4>Result</h4>\n<p>테스트가 정상적으로 종료되면 아래와 같은 결과를 보실 수 있습니다. ERC721의 balanceOf는 특정 주소가 소유한 ERC721 토큰의 갯수를 반환합니다.</p>\n<pre>Deploying L1 ERC721...<br>Deploying L2 ERC721...<br>Deploying L1 ERC721 Gateway...<br>Initializing L2 ERC721...<br>Balance on L1: 1<br>Balance on L2: 0<br>Approving tokens for ERC721 gateway...<br>Depositing tokens into L2 ERC721...<br>Waiting for deposit to be relayed to L2...<br>Balance on L1: 0<br>Balance on L2: 1<br>Withdrawing tokens back to L1 ERC721...<br>Waiting for withdrawal to be relayed to L1...<br>Balance on L1: 1<br>Balance on L2: 0</pre>\n<h3>정리</h3>\n<p>현재 옵티미스틱 롤업의 토큰 게이트웨이 컨트랙트는 ERC20 토큰만 지원하지만, 동일한 방식으로 ERC721 토큰도 지원하도록 해보았습니다. 물론 ERC721 토큰 전용 게이트웨이 컨트랙트도 추후 옵티미스틱 롤업에서 자체적으로 구현되어 추가될 여지는 있습니다. 여기서 중요한 점은, 옵티미스틱 롤업에서 L1 &lt;&gt; L2 이동을 지원하는 형식의 토큰이 아니더라도 충분히 커스터마이징하여 게이트웨이 컨트랙트를 구현하고 기능을 지원할 수 있다는 점입니다.</p>\n<h3>참조</h3>\n<p><a href="https://github.com/ethereum-optimism/optimism">Optimism Monorepo</a></p>\n<p><a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal">Onther-Tech/l1-l2-deposit-withdrawal</a></p>\n<p><a href="https://github.com/ethereum-optimism/l1-l2-deposit-withdrawal">ethereum-optimism/l1-l2-deposit-withdrawal</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bb647362ec5d" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d">옵티미즘 초보자 가이드 3편 : ERC721 써보기</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                enclosure: {},
                categories: [
                  "optimistic-rollup",
                  "optimism",
                  "research",
                  "layer-2",
                  "ethereum",
                ],
              },
              {
                title: "옵티미즘 초보자 가이드 2편 : ERC20 써보기",
                pubDate: "2021-05-20 05:31:48",
                link:
                  "https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3?source=rss----eb8117f0bafd---4",
                guid: "https://medium.com/p/bc774f94d8b3",
                author: "Darren K",
                thumbnail:
                  "https://cdn-images-1.medium.com/max/1024/1*IFccG7mF3x3PrIEBogAxwQ.png",
                description:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IFccG7mF3x3PrIEBogAxwQ.png"></figure><h3>TL;DR</h3>\n<h4>Run optimistic rollup</h4>\n<pre>$ cd optimism/ops<br>$ docker-compose up -d</pre>\n<h4>Build repository</h4>\n<pre>$ cd ../<br>$ git clone <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git</a><br>$ cd l1-l2-deposit-withdrawal<br>$ yarn &amp;&amp; yarn compile</pre>\n<h4>Test ERC20 L1 &lt;&gt; L2</h4>\n<pre>$ node ./example.js</pre>\n<p>옵티미스틱 롤업 사용하기 시리즈는 총 세 개의 포스팅으로 구성됩니다.</p>\n<blockquote>\n<a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">옵티미스틱 롤업 사용하기</a><br><strong>옵티미스틱 롤업에서 ERC20 사용하기</strong><br><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d">옵티미스틱 롤업에서 ERC721 사용하기</a>\n</blockquote>\n<h3>소개</h3>\n<p>옵티미스틱 롤업은 스마트 컨트랙트를 지원하는 레이어2 솔루션으로, 이더리움 메인넷에서 사용하던 스마트 컨트랙트들을 레이어2에서도 동일하게 사용할 수 있도록 합니다. 레이어2에서 스마트 컨트랙트를 사용하고자 하는 사용자들은 자신의 토큰들을 레이어2에서 사용하게 됩니다. 레이어2의 dApp을 사용하기 위해서는 필요한 토큰을 메인넷으로부터 가져와야 하는데, 메인넷의 토큰을 컨트랙트에 예치시키고 같은 양의 토큰을 레이어2에서 받는 방식으로 이루어집니다. 또한, 레이어2에서 사용하던 토큰을 메인넷으로 다시 가져오는 인출 기능도 지원합니다.</p>\n<p>레이어2에 갖고 있던 토큰을 메인넷으로 인출하는 부분에서는 레이어2 솔루션별로 소요 기간의 차이가 있습니다. 레이어2의 트랜잭션에 대한 검증 방식과 검증 기간에 따라 달라지는데, 토큰 인출 시도가 올바른지, 이중 지불이 될만한 시도인지 등을 검증하기 위함입니다. 옵티미스틱 롤업은 레이어2의 트랜잭션에 대한 정보를 메인넷의 컨트랙트에 일단 등록해두고, 올바르지 않은 트랜잭션을 찾기 위해 일정 기간 동안 검증 기간을 갖는데, 이 기간 동안 부정 행위가 발견되지 않은 트랜잭션은 올바른 트랜잭션으로써 확정됩니다. 토큰의 인출도 같은 과정으로 이루어지는데, 사용자의 토큰 인출 요청 트랜잭션이 실행되면서 동시에 메인넷의 토큰이 인출되는 것이 아니라, 토큰 인출 요청 트랜잭션이 발생한 뒤 일정 기간이 지나고 메인넷의 토큰을 받을 수 있습니다.</p>\n<p>이 포스팅은 옵티미스틱 롤업을 사용하고자 하는 개발자 분들께, 레이어1과 레이어2의 ERC20 토큰 이동이 어떤 방식으로 이루어지며 어떻게 사용할 수 있는지를 전달하기 위해 작성되었습니다.</p>\n<blockquote>옵티미스틱 롤업은 web3.js 대신 ethers.js를, truffle 대신 hardhat을 사용하고 있습니다. ethers.js와 hardhat 등은 web3와 truffle 등과 비교했을 때 여러 장점들이 있어 최근 많은 스마트 컨트랙트 프로젝트에서 사용하고 있습니다.</blockquote>\n<h3>저장소 정보</h3>\n<p>Optimistic rollup repository : <a href="https://github.com/ethereum-optimism/optimism">https://github.com/ethereum-optimism/optimism</a></p>\n<p>Commit : 751e2be</p>\n<p>Test repository : <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal/tree/feature/erc721">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal</a></p>\n<p>Commit : a00fb50</p>\n<h3>인출/예치 코드</h3>\n<p>레이어1, 레이어2간의 ERC20 토큰 이동이 어떻게 이루어지는지 살펴보겠습니다. 먼저 레이어1에서 레이어2로 예치하는 것을 살펴보면, 개념적으로는 사용자가 레이어1에 가지고 있던 토큰이 레이어2로 이동한 것이지만, 내부적으로 레이어1 입장에서는 사용자의 토큰이 옵티미스틱 롤업의 게이트웨이 컨트랙트로 이동한 것이고, 레이어2 입장에서는 같은 양의 토큰이 사용자에게 발행된 것입니다. 따라서 사용자 입장에서는 레이어1에서 예치한 토큰 양만큼 레이어2에서 받기 때문에 레이어1 → 레이어2로 토큰 이동을 한 것으로도 볼 수 있습니다.</p>\n<p>마찬가지로 레이어2에서 레이어1으로 토큰을 이동하는 것은, 레이어2 입장에서는 사용자의 토큰을 소각하는 것이고, 같은 양의 토큰을 레이어1에서 사용자에게 전송하는 것입니다.</p>\n<p>아래에서는 테스트 코드를 기준으로 어떤 컨트랙트를 배포해서 사용하고, 사용자의 트랜잭션이 어떤 흐름으로 처리되는지 살펴보겠습니다. 테스트 코드의 위치는 l1-l2-deposit-withdrawal 저장소의 example.js 파일입니다.</p>\n<h4>컨트랙트와 서비스 설정</h4>\n<p>테스트 코드의 시작 부분에서는 먼저 테스트에 사용할 RPC Provider와 지갑 등을 설정합니다. RPC Provider와 지갑 모두 레이어1과 레이어2를 각각 설정하고 있습니다. l1MessengerAddress는 optimism의 도커 이미지들을 올릴 때 배포되는 컨트랙트의 주소로 하드코딩되어 있고, l2MessengerAddress는 레이어2의 predeployed 컨트랙트로 사용하는 주소가 하드코딩되어 있습니다.</p>\n<p>옵티미스틱 롤업을 실행하는 환경이 localhost가 아닐 경우 RPC Provider에 주소를 직접 지정해주면 됩니다. 레이어1, 레이어2에 대한 RPC Provider 주소를 지정해 줄 수 있습니다.</p>\n<a href="https://medium.com/media/4b31024904168410eae0707486352bb4/href">https://medium.com/media/4b31024904168410eae0707486352bb4/href</a><p>다음으로 Watcher 서비스를 연결하고 있습니다. Watcher 서비스는 사용자가 트랜잭션을 보낸 뒤 완전한 처리가 끝나도록 대기할 수 있도록 합니다. 사용자가 레이어1이나 레이어2로 보낸 트랜잭션이 단순히 해당 체인에서만 실행이 끝나는 것이 아니라 다른 체인에 영향을 미치는 경우(예를 들어 예치와 인출), 단순히 처음 트랜잭션을 보낸 체인에서 마이닝되었다고 처리가 끝난 것이 아니기 때문에 이와 같이 후처리를 대기할 수 있도록 해야 합니다.</p>\n<a href="https://medium.com/media/748304d4ac473d717457868aa0c5ad3a/href">https://medium.com/media/748304d4ac473d717457868aa0c5ad3a/href</a><p>다음으로 테스트에 사용할 컨트랙트들을 배포하고 설정합니다. 여기서 배포하는 컨트랙트는 모두 세 개인데, 레이어1에서 두 개(L1_ERC20, L1_ERC20Gateway), 레이어2에서 한 개(L2_ERC20)의 컨트랙트들을 배포합니다.</p>\n<ul><li>L1_ERC20(레이어1 배포)</li></ul>\n<p>테스트에 사용할 ERC20 토큰 컨트랙트입니다. 옵티미스틱 롤업에서 필요한 기능이 추가된 것이 아닌, 최소한의 기능만 구현된 일반적인 ERC20 컨트랙트입니다.</p>\n<ul><li>L1_ERC20Gateway(레이어1 배포)</li></ul>\n<p>레이어1 L1_ERC20 토큰의 게이트웨이 역할을 담당하는 컨트랙트입니다. 사용자가 레이어2로 이동시키고자 하는 레이어1 토큰은 이 게이트웨이 컨트랙트에서 보관하고, 레이어2에서 레이어1로 인출이 완료될 때 이 게이트웨이 컨트랙트에 보관되었던 토큰을 사용자에게 전송합니다.</p>\n<ul><li>L2_ERC20(레이어2배포)</li></ul>\n<p>레이어2에 배포되는 ERC20 토큰 컨트랙트입니다. L1_ERC20 컨트랙트는 단순한 ERC20 토큰 컨트랙트이지만, L2_ERC20 토큰 컨트랙트는 옵티미스틱 롤업의 Abs_L2DepositedToken 컨트랙트를 상속받고 필요한 기능이 구현된 컨트랙트입니다. Abs_L2DepositedToken 컨트랙트에는 L1 &lt;&gt; L2 이동시 호출되는 함수의 인터페이스가 정의되어 있습니다.</p>\n<a href="https://medium.com/media/2a7bb255f68cdffb942bfcc3c9600df7/href">https://medium.com/media/2a7bb255f68cdffb942bfcc3c9600df7/href</a><p>다음은 테스트에 필요한 컨트랙트 환경 구성을 마친 후, 본격적인 테스트를 시작하기 전에 토큰 잔고를 확인하는 부분입니다. 테스트에 사용할 ERC20 토큰의 잔고를 레이어1과 레이어2에서 각각 출력하는 부분이며, 레이어1에서는 1234, 레이어2에서는 0의 토큰을 가진 상태입니다.</p>\n<a href="https://medium.com/media/134cdce590a4bc1eea6f7e651398a947/href">https://medium.com/media/134cdce590a4bc1eea6f7e651398a947/href</a><h4>레이어1 토큰의 예치</h4>\n<p>레이어1 사용자가 가진 토큰을 예치하기 위해서는 먼저 approve를 해두어야 합니다. approve 대상은 L1_ERC20Gateway 컨트랙트이며, 이 테스트에서는 1234만큼의 토큰 양을 이동하고 있습니다. 실제 토큰의 이동은 L1_ERC20Gateway에서 deposit 함수를 호출하는 시점에 이루어지는데, 이 시점에 L1_ERC20Gateway 컨트랙트가 사용자의 토큰을 가져올 수 있도록 하기 위해 approve를 하고 있습니다.</p>\n<a href="https://medium.com/media/bea37ba8791ff696e8a9a80945b3294f/href">https://medium.com/media/bea37ba8791ff696e8a9a80945b3294f/href</a><p>approve가 완료된 후 예치는 L1_ERC20Gateway 컨트랙트의 deposit 함수를 통해 이루어집니다. 이 때, deposit을 호출하는 트랜잭션이 마이닝되었다는 것은 레이어1의 사용자 토큰이 레이어1의 L1_ERC20Gateway 컨트랙트로 예치되었다는 것을 의미합니다. 또한 이것은 레이어2로 토큰 이동이 완료되었다는 것을 의미하지는 않기 때문에 레이어2의 후처리를 대기하는 작업이 필요합니다. 테스트 코드에서는 아래와 같이 L1_ERC20Gateway 컨트랙트의 deposit 함수를 호출하고, 이후 해당 트랜잭션을 기준으로 watcher를 통해 레이어2의 처리가 완료되기를 대기하는 것을 볼 수 있습니다.</p>\n<a href="https://medium.com/media/fc5c1fcd989b52df8afaf5573eced776/href">https://medium.com/media/fc5c1fcd989b52df8afaf5573eced776/href</a><p>위의 코드가 완료된 뒤 다시 토큰 잔액을 확인하는 코드입니다. 지금까지의 과정이 정상적으로 완료된 경우, 레이어1의 사용자 토큰은 L1_ERC20Gateway 컨트랙트로 이동되어서 레이어1의 토큰 잔액은 0이 되어야 하고, 레이어2에서는 같은 양의 토큰이 사용자에게 발행되어 레이어2의 토큰 잔액은 1234가 되어야 합니다.</p>\n<a href="https://medium.com/media/dd495780bcc0d75360e62e374d483ec6/href">https://medium.com/media/dd495780bcc0d75360e62e374d483ec6/href</a><h4>레이어2 토큰의 출금</h4>\n<p>이제 레이어2의 토큰을 출금하여 다시 레이어1으로 가져오는 부분입니다. 레이어2 토큰의 출금은 사용자가 가진 레이어2의 토큰을 소각하고, 레이어1에서 같은 양의 토큰을 사용자에게 전송하는 과정으로 이루어집니다. 이 때, 레이어2의 트랜잭션은 L2_ERC20 토큰 컨트랙트를 통해 이루어지는데, 옵티미스틱 롤업의 컨트랙트를 상속받고 필요한 기능이 구현된 컨트랙트이기 때문에 미리 approve를 할 필요가 없습니다.</p>\n<p>아래 코드에서 L2_ERC20의 withdraw 함수를 호출하고, 이 트랜잭션 실행이 완료된 뒤 그에 대응하는 레이어1의 처리를 대기하는 것을 볼 수 있습니다.</p>\n<a href="https://medium.com/media/e44d92f9ee309addd54c6b48e901fa4a/href">https://medium.com/media/e44d92f9ee309addd54c6b48e901fa4a/href</a><p>출금이 완료된 뒤 다시 토큰의 잔액을 조회합니다. 레이어2의 사용자 토큰은 소각되어 레이어2토큰 잔액은 0이 되고, 같은 양의 토큰이 L1_ERC20Gateway 컨트랙트로부터 사용자에게 전송되어 레이어1토큰 잔액은 1234가 되는 것을 볼 수 있습니다.</p>\n<a href="https://medium.com/media/c97c7bdb60dc438ad2b0cbbd53b3c79f/href">https://medium.com/media/c97c7bdb60dc438ad2b0cbbd53b3c79f/href</a><blockquote>withdraw 트랜잭션이 실행된 후 처리를 대기하는 사이에 옵티미스틱 롤업은 검증 기간을 갖고 올바르지 않은 트랜잭션을 검증하기 위한 기간을 갖습니다. 이런 방식은 레이어2의 트랜잭션을 일단 레이어1에 등록시켜놓고, 올바르지 않은 트랜잭션을 검증하는 기간을 갖는 Fraud proof 방식입니다. 옵티미스틱 롤업에서 트랜잭션을 관리하는 방법과 검증에 대한 자세한 내용은 <a href="https://medium.com/onther-tech/how-does-optimisms-rollup-really-work-249797c91336">How does Optimism’s Rollup really work?</a> 포스팅을 참고해 주시기 바랍니다.</blockquote>\n<h3>테스트</h3>\n<h4>Run optimistic rollup</h4>\n<p>ERC20 토큰의 예치/인출 테스트에 앞서 아래와 같이 테스트에서 필요한 환경을 구성합니다. 옵티미스틱 롤업의 빌드를 하지 않은 상태라면 이전 포스팅을 따라 환경 설치를 해주셔야 합니다.</p>\n<pre>$ cd optimism/ops<br>$ docker-compose up -d</pre>\n<h4>Build repository</h4>\n<p>테스트에 필요한 저장소를 받고 빌드합니다. 이 저장소는 옵티미스틱 롤업에서의 ERC20 토큰 이동을 테스트하는 저장소로, 테스트에 사용할 컨트랙트 등을 빌드합니다.</p>\n<pre>$ cd ../<br>$ git clone <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git</a><br>$ cd l1-l2-deposit-withdrawal<br>$ yarn &amp;&amp; yarn compile</pre>\n<h4>Test ERC20 L1 &lt;&gt; L2</h4>\n<p>테스트를 실행합니다.</p>\n<pre>$ node ./example.js</pre>\n<h4>Result</h4>\n<p>테스트가 정상적으로 종료되면 아래와 같은 결과를 보실 수 있습니다.</p>\n<pre>Deploying L1 ERC20...<br>Deploying L2 ERC20...<br>Deploying L1 ERC20 Gateway...<br>Initializing L2 ERC20...<br>Balance on L1: 1234<br>Balance on L2: 0<br>Approving tokens for ERC20 gateway...<br>Depositing tokens into L2 ERC20...<br>Waiting for deposit to be relayed to L2...<br>Balance on L1: 0<br>Balance on L2: 1234<br>Withdrawing tokens back to L1 ERC20...<br>Waiting for withdrawal to be relayed to L1...<br>Balance on L1: 1234<br>Balance on L2: 0</pre>\n<h3>정리</h3>\n<p>옵티미스틱 롤업에서 ERC20 토큰을 사용하기 위해 예치/인출하는 방법에 대해 살펴보았습니다. 토큰의 L1 -&gt; L2 이동은 사용자의 레이어1 토큰을 게이트웨이 컨트랙트로 전송하고 같은 양의 토큰을 레이어2에서 발행 받는 방법으로 처리되고, L1 &lt;- L2 이동은 사용자의 레이어2 토큰을 소각하고 같은 양의 토큰을 레이어1의 게이트웨이 컨트랙트로부터 받아 처리합니다. 예치와 인출을 다루는 것은 deposit과 withdraw 함수를 호출하는 것과 레이어2의 처리를 대기하는 것이 추가된 정도로, 크게 복잡하지 않다는 것을 확인했습니다.</p>\n<h3>참조</h3>\n<p><a href="https://github.com/ethereum-optimism/optimism">Optimism Monorepo</a></p>\n<p><a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal">Onther-Tech/l1-l2-deposit-withdrawal</a></p>\n<p><a href="https://github.com/ethereum-optimism/l1-l2-deposit-withdrawal">ethereum-optimism/l1-l2-deposit-withdrawal</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bc774f94d8b3" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">옵티미즘 초보자 가이드 2편 : ERC20 써보기</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                content:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IFccG7mF3x3PrIEBogAxwQ.png"></figure><h3>TL;DR</h3>\n<h4>Run optimistic rollup</h4>\n<pre>$ cd optimism/ops<br>$ docker-compose up -d</pre>\n<h4>Build repository</h4>\n<pre>$ cd ../<br>$ git clone <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git</a><br>$ cd l1-l2-deposit-withdrawal<br>$ yarn &amp;&amp; yarn compile</pre>\n<h4>Test ERC20 L1 &lt;&gt; L2</h4>\n<pre>$ node ./example.js</pre>\n<p>옵티미스틱 롤업 사용하기 시리즈는 총 세 개의 포스팅으로 구성됩니다.</p>\n<blockquote>\n<a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">옵티미스틱 롤업 사용하기</a><br><strong>옵티미스틱 롤업에서 ERC20 사용하기</strong><br><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d">옵티미스틱 롤업에서 ERC721 사용하기</a>\n</blockquote>\n<h3>소개</h3>\n<p>옵티미스틱 롤업은 스마트 컨트랙트를 지원하는 레이어2 솔루션으로, 이더리움 메인넷에서 사용하던 스마트 컨트랙트들을 레이어2에서도 동일하게 사용할 수 있도록 합니다. 레이어2에서 스마트 컨트랙트를 사용하고자 하는 사용자들은 자신의 토큰들을 레이어2에서 사용하게 됩니다. 레이어2의 dApp을 사용하기 위해서는 필요한 토큰을 메인넷으로부터 가져와야 하는데, 메인넷의 토큰을 컨트랙트에 예치시키고 같은 양의 토큰을 레이어2에서 받는 방식으로 이루어집니다. 또한, 레이어2에서 사용하던 토큰을 메인넷으로 다시 가져오는 인출 기능도 지원합니다.</p>\n<p>레이어2에 갖고 있던 토큰을 메인넷으로 인출하는 부분에서는 레이어2 솔루션별로 소요 기간의 차이가 있습니다. 레이어2의 트랜잭션에 대한 검증 방식과 검증 기간에 따라 달라지는데, 토큰 인출 시도가 올바른지, 이중 지불이 될만한 시도인지 등을 검증하기 위함입니다. 옵티미스틱 롤업은 레이어2의 트랜잭션에 대한 정보를 메인넷의 컨트랙트에 일단 등록해두고, 올바르지 않은 트랜잭션을 찾기 위해 일정 기간 동안 검증 기간을 갖는데, 이 기간 동안 부정 행위가 발견되지 않은 트랜잭션은 올바른 트랜잭션으로써 확정됩니다. 토큰의 인출도 같은 과정으로 이루어지는데, 사용자의 토큰 인출 요청 트랜잭션이 실행되면서 동시에 메인넷의 토큰이 인출되는 것이 아니라, 토큰 인출 요청 트랜잭션이 발생한 뒤 일정 기간이 지나고 메인넷의 토큰을 받을 수 있습니다.</p>\n<p>이 포스팅은 옵티미스틱 롤업을 사용하고자 하는 개발자 분들께, 레이어1과 레이어2의 ERC20 토큰 이동이 어떤 방식으로 이루어지며 어떻게 사용할 수 있는지를 전달하기 위해 작성되었습니다.</p>\n<blockquote>옵티미스틱 롤업은 web3.js 대신 ethers.js를, truffle 대신 hardhat을 사용하고 있습니다. ethers.js와 hardhat 등은 web3와 truffle 등과 비교했을 때 여러 장점들이 있어 최근 많은 스마트 컨트랙트 프로젝트에서 사용하고 있습니다.</blockquote>\n<h3>저장소 정보</h3>\n<p>Optimistic rollup repository : <a href="https://github.com/ethereum-optimism/optimism">https://github.com/ethereum-optimism/optimism</a></p>\n<p>Commit : 751e2be</p>\n<p>Test repository : <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal/tree/feature/erc721">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal</a></p>\n<p>Commit : a00fb50</p>\n<h3>인출/예치 코드</h3>\n<p>레이어1, 레이어2간의 ERC20 토큰 이동이 어떻게 이루어지는지 살펴보겠습니다. 먼저 레이어1에서 레이어2로 예치하는 것을 살펴보면, 개념적으로는 사용자가 레이어1에 가지고 있던 토큰이 레이어2로 이동한 것이지만, 내부적으로 레이어1 입장에서는 사용자의 토큰이 옵티미스틱 롤업의 게이트웨이 컨트랙트로 이동한 것이고, 레이어2 입장에서는 같은 양의 토큰이 사용자에게 발행된 것입니다. 따라서 사용자 입장에서는 레이어1에서 예치한 토큰 양만큼 레이어2에서 받기 때문에 레이어1 → 레이어2로 토큰 이동을 한 것으로도 볼 수 있습니다.</p>\n<p>마찬가지로 레이어2에서 레이어1으로 토큰을 이동하는 것은, 레이어2 입장에서는 사용자의 토큰을 소각하는 것이고, 같은 양의 토큰을 레이어1에서 사용자에게 전송하는 것입니다.</p>\n<p>아래에서는 테스트 코드를 기준으로 어떤 컨트랙트를 배포해서 사용하고, 사용자의 트랜잭션이 어떤 흐름으로 처리되는지 살펴보겠습니다. 테스트 코드의 위치는 l1-l2-deposit-withdrawal 저장소의 example.js 파일입니다.</p>\n<h4>컨트랙트와 서비스 설정</h4>\n<p>테스트 코드의 시작 부분에서는 먼저 테스트에 사용할 RPC Provider와 지갑 등을 설정합니다. RPC Provider와 지갑 모두 레이어1과 레이어2를 각각 설정하고 있습니다. l1MessengerAddress는 optimism의 도커 이미지들을 올릴 때 배포되는 컨트랙트의 주소로 하드코딩되어 있고, l2MessengerAddress는 레이어2의 predeployed 컨트랙트로 사용하는 주소가 하드코딩되어 있습니다.</p>\n<p>옵티미스틱 롤업을 실행하는 환경이 localhost가 아닐 경우 RPC Provider에 주소를 직접 지정해주면 됩니다. 레이어1, 레이어2에 대한 RPC Provider 주소를 지정해 줄 수 있습니다.</p>\n<a href="https://medium.com/media/4b31024904168410eae0707486352bb4/href">https://medium.com/media/4b31024904168410eae0707486352bb4/href</a><p>다음으로 Watcher 서비스를 연결하고 있습니다. Watcher 서비스는 사용자가 트랜잭션을 보낸 뒤 완전한 처리가 끝나도록 대기할 수 있도록 합니다. 사용자가 레이어1이나 레이어2로 보낸 트랜잭션이 단순히 해당 체인에서만 실행이 끝나는 것이 아니라 다른 체인에 영향을 미치는 경우(예를 들어 예치와 인출), 단순히 처음 트랜잭션을 보낸 체인에서 마이닝되었다고 처리가 끝난 것이 아니기 때문에 이와 같이 후처리를 대기할 수 있도록 해야 합니다.</p>\n<a href="https://medium.com/media/748304d4ac473d717457868aa0c5ad3a/href">https://medium.com/media/748304d4ac473d717457868aa0c5ad3a/href</a><p>다음으로 테스트에 사용할 컨트랙트들을 배포하고 설정합니다. 여기서 배포하는 컨트랙트는 모두 세 개인데, 레이어1에서 두 개(L1_ERC20, L1_ERC20Gateway), 레이어2에서 한 개(L2_ERC20)의 컨트랙트들을 배포합니다.</p>\n<ul><li>L1_ERC20(레이어1 배포)</li></ul>\n<p>테스트에 사용할 ERC20 토큰 컨트랙트입니다. 옵티미스틱 롤업에서 필요한 기능이 추가된 것이 아닌, 최소한의 기능만 구현된 일반적인 ERC20 컨트랙트입니다.</p>\n<ul><li>L1_ERC20Gateway(레이어1 배포)</li></ul>\n<p>레이어1 L1_ERC20 토큰의 게이트웨이 역할을 담당하는 컨트랙트입니다. 사용자가 레이어2로 이동시키고자 하는 레이어1 토큰은 이 게이트웨이 컨트랙트에서 보관하고, 레이어2에서 레이어1로 인출이 완료될 때 이 게이트웨이 컨트랙트에 보관되었던 토큰을 사용자에게 전송합니다.</p>\n<ul><li>L2_ERC20(레이어2배포)</li></ul>\n<p>레이어2에 배포되는 ERC20 토큰 컨트랙트입니다. L1_ERC20 컨트랙트는 단순한 ERC20 토큰 컨트랙트이지만, L2_ERC20 토큰 컨트랙트는 옵티미스틱 롤업의 Abs_L2DepositedToken 컨트랙트를 상속받고 필요한 기능이 구현된 컨트랙트입니다. Abs_L2DepositedToken 컨트랙트에는 L1 &lt;&gt; L2 이동시 호출되는 함수의 인터페이스가 정의되어 있습니다.</p>\n<a href="https://medium.com/media/2a7bb255f68cdffb942bfcc3c9600df7/href">https://medium.com/media/2a7bb255f68cdffb942bfcc3c9600df7/href</a><p>다음은 테스트에 필요한 컨트랙트 환경 구성을 마친 후, 본격적인 테스트를 시작하기 전에 토큰 잔고를 확인하는 부분입니다. 테스트에 사용할 ERC20 토큰의 잔고를 레이어1과 레이어2에서 각각 출력하는 부분이며, 레이어1에서는 1234, 레이어2에서는 0의 토큰을 가진 상태입니다.</p>\n<a href="https://medium.com/media/134cdce590a4bc1eea6f7e651398a947/href">https://medium.com/media/134cdce590a4bc1eea6f7e651398a947/href</a><h4>레이어1 토큰의 예치</h4>\n<p>레이어1 사용자가 가진 토큰을 예치하기 위해서는 먼저 approve를 해두어야 합니다. approve 대상은 L1_ERC20Gateway 컨트랙트이며, 이 테스트에서는 1234만큼의 토큰 양을 이동하고 있습니다. 실제 토큰의 이동은 L1_ERC20Gateway에서 deposit 함수를 호출하는 시점에 이루어지는데, 이 시점에 L1_ERC20Gateway 컨트랙트가 사용자의 토큰을 가져올 수 있도록 하기 위해 approve를 하고 있습니다.</p>\n<a href="https://medium.com/media/bea37ba8791ff696e8a9a80945b3294f/href">https://medium.com/media/bea37ba8791ff696e8a9a80945b3294f/href</a><p>approve가 완료된 후 예치는 L1_ERC20Gateway 컨트랙트의 deposit 함수를 통해 이루어집니다. 이 때, deposit을 호출하는 트랜잭션이 마이닝되었다는 것은 레이어1의 사용자 토큰이 레이어1의 L1_ERC20Gateway 컨트랙트로 예치되었다는 것을 의미합니다. 또한 이것은 레이어2로 토큰 이동이 완료되었다는 것을 의미하지는 않기 때문에 레이어2의 후처리를 대기하는 작업이 필요합니다. 테스트 코드에서는 아래와 같이 L1_ERC20Gateway 컨트랙트의 deposit 함수를 호출하고, 이후 해당 트랜잭션을 기준으로 watcher를 통해 레이어2의 처리가 완료되기를 대기하는 것을 볼 수 있습니다.</p>\n<a href="https://medium.com/media/fc5c1fcd989b52df8afaf5573eced776/href">https://medium.com/media/fc5c1fcd989b52df8afaf5573eced776/href</a><p>위의 코드가 완료된 뒤 다시 토큰 잔액을 확인하는 코드입니다. 지금까지의 과정이 정상적으로 완료된 경우, 레이어1의 사용자 토큰은 L1_ERC20Gateway 컨트랙트로 이동되어서 레이어1의 토큰 잔액은 0이 되어야 하고, 레이어2에서는 같은 양의 토큰이 사용자에게 발행되어 레이어2의 토큰 잔액은 1234가 되어야 합니다.</p>\n<a href="https://medium.com/media/dd495780bcc0d75360e62e374d483ec6/href">https://medium.com/media/dd495780bcc0d75360e62e374d483ec6/href</a><h4>레이어2 토큰의 출금</h4>\n<p>이제 레이어2의 토큰을 출금하여 다시 레이어1으로 가져오는 부분입니다. 레이어2 토큰의 출금은 사용자가 가진 레이어2의 토큰을 소각하고, 레이어1에서 같은 양의 토큰을 사용자에게 전송하는 과정으로 이루어집니다. 이 때, 레이어2의 트랜잭션은 L2_ERC20 토큰 컨트랙트를 통해 이루어지는데, 옵티미스틱 롤업의 컨트랙트를 상속받고 필요한 기능이 구현된 컨트랙트이기 때문에 미리 approve를 할 필요가 없습니다.</p>\n<p>아래 코드에서 L2_ERC20의 withdraw 함수를 호출하고, 이 트랜잭션 실행이 완료된 뒤 그에 대응하는 레이어1의 처리를 대기하는 것을 볼 수 있습니다.</p>\n<a href="https://medium.com/media/e44d92f9ee309addd54c6b48e901fa4a/href">https://medium.com/media/e44d92f9ee309addd54c6b48e901fa4a/href</a><p>출금이 완료된 뒤 다시 토큰의 잔액을 조회합니다. 레이어2의 사용자 토큰은 소각되어 레이어2토큰 잔액은 0이 되고, 같은 양의 토큰이 L1_ERC20Gateway 컨트랙트로부터 사용자에게 전송되어 레이어1토큰 잔액은 1234가 되는 것을 볼 수 있습니다.</p>\n<a href="https://medium.com/media/c97c7bdb60dc438ad2b0cbbd53b3c79f/href">https://medium.com/media/c97c7bdb60dc438ad2b0cbbd53b3c79f/href</a><blockquote>withdraw 트랜잭션이 실행된 후 처리를 대기하는 사이에 옵티미스틱 롤업은 검증 기간을 갖고 올바르지 않은 트랜잭션을 검증하기 위한 기간을 갖습니다. 이런 방식은 레이어2의 트랜잭션을 일단 레이어1에 등록시켜놓고, 올바르지 않은 트랜잭션을 검증하는 기간을 갖는 Fraud proof 방식입니다. 옵티미스틱 롤업에서 트랜잭션을 관리하는 방법과 검증에 대한 자세한 내용은 <a href="https://medium.com/onther-tech/how-does-optimisms-rollup-really-work-249797c91336">How does Optimism’s Rollup really work?</a> 포스팅을 참고해 주시기 바랍니다.</blockquote>\n<h3>테스트</h3>\n<h4>Run optimistic rollup</h4>\n<p>ERC20 토큰의 예치/인출 테스트에 앞서 아래와 같이 테스트에서 필요한 환경을 구성합니다. 옵티미스틱 롤업의 빌드를 하지 않은 상태라면 이전 포스팅을 따라 환경 설치를 해주셔야 합니다.</p>\n<pre>$ cd optimism/ops<br>$ docker-compose up -d</pre>\n<h4>Build repository</h4>\n<p>테스트에 필요한 저장소를 받고 빌드합니다. 이 저장소는 옵티미스틱 롤업에서의 ERC20 토큰 이동을 테스트하는 저장소로, 테스트에 사용할 컨트랙트 등을 빌드합니다.</p>\n<pre>$ cd ../<br>$ git clone <a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git">https://github.com/Onther-Tech/l1-l2-deposit-withdrawal.git</a><br>$ cd l1-l2-deposit-withdrawal<br>$ yarn &amp;&amp; yarn compile</pre>\n<h4>Test ERC20 L1 &lt;&gt; L2</h4>\n<p>테스트를 실행합니다.</p>\n<pre>$ node ./example.js</pre>\n<h4>Result</h4>\n<p>테스트가 정상적으로 종료되면 아래와 같은 결과를 보실 수 있습니다.</p>\n<pre>Deploying L1 ERC20...<br>Deploying L2 ERC20...<br>Deploying L1 ERC20 Gateway...<br>Initializing L2 ERC20...<br>Balance on L1: 1234<br>Balance on L2: 0<br>Approving tokens for ERC20 gateway...<br>Depositing tokens into L2 ERC20...<br>Waiting for deposit to be relayed to L2...<br>Balance on L1: 0<br>Balance on L2: 1234<br>Withdrawing tokens back to L1 ERC20...<br>Waiting for withdrawal to be relayed to L1...<br>Balance on L1: 1234<br>Balance on L2: 0</pre>\n<h3>정리</h3>\n<p>옵티미스틱 롤업에서 ERC20 토큰을 사용하기 위해 예치/인출하는 방법에 대해 살펴보았습니다. 토큰의 L1 -&gt; L2 이동은 사용자의 레이어1 토큰을 게이트웨이 컨트랙트로 전송하고 같은 양의 토큰을 레이어2에서 발행 받는 방법으로 처리되고, L1 &lt;- L2 이동은 사용자의 레이어2 토큰을 소각하고 같은 양의 토큰을 레이어1의 게이트웨이 컨트랙트로부터 받아 처리합니다. 예치와 인출을 다루는 것은 deposit과 withdraw 함수를 호출하는 것과 레이어2의 처리를 대기하는 것이 추가된 정도로, 크게 복잡하지 않다는 것을 확인했습니다.</p>\n<h3>참조</h3>\n<p><a href="https://github.com/ethereum-optimism/optimism">Optimism Monorepo</a></p>\n<p><a href="https://github.com/Onther-Tech/l1-l2-deposit-withdrawal">Onther-Tech/l1-l2-deposit-withdrawal</a></p>\n<p><a href="https://github.com/ethereum-optimism/l1-l2-deposit-withdrawal">ethereum-optimism/l1-l2-deposit-withdrawal</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bc774f94d8b3" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">옵티미즘 초보자 가이드 2편 : ERC20 써보기</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                enclosure: {},
                categories: [
                  "optimism",
                  "layer-2",
                  "optimistic-rollup",
                  "ethereum",
                  "research",
                ],
              },
              {
                title: "옵티미즘 초보자 가이드 1편 : 환경설정 및 설치",
                pubDate: "2021-05-20 05:30:58",
                link:
                  "https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f?source=rss----eb8117f0bafd---4",
                guid: "https://medium.com/p/390cd737c02f",
                author: "Darren K",
                thumbnail:
                  "https://cdn-images-1.medium.com/max/1024/1*190PrSih_EcnzAd65Ptndw.png",
                description:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*190PrSih_EcnzAd65Ptndw.png"></figure><h3>TL;DR</h3>\n<h4>Build repository</h4>\n<pre>$ git clone https://github.com/ethereum-optimism/optimism.git<br>$ cd optimism<br>$ yarn &amp;&amp; yarn build</pre>\n<h4>Unit test</h4>\n<pre>$ yarn test</pre>\n<h4>Run</h4>\n<pre>$ cd ops<br>$ export COMPOSE_DOCKER_CLI_BUILD=1<br>$ export DOCKER_BUILDKIT=1<br>$ docker-compose build<br>$ docker-compose up -d</pre>\n<h4>Integration test</h4>\n<pre>$ cd ../integration-tests<br>$ yarn build:integration<br>$ yarn test:integration</pre>\n<p>옵티미스틱 롤업 사용하기 시리즈는 총 세 개의 포스팅으로 구성됩니다.</p>\n<blockquote>\n<strong>옵티미스틱 롤업 사용하기</strong><br><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">옵티미스틱 롤업에서 ERC20 사용하기</a><br><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d">옵티미스틱 롤업에서 ERC721 사용하기</a>\n</blockquote>\n<h3>들어가기 전에</h3>\n<p>이더리움은 업데이트를 통해 트랜잭션 수수료의 부담을 줄이기 위한 노력을 하고 있지만, 이더리움의 가격 상승과 트랜잭션 경쟁 심화 등의 이유로 수수료 부담은 크게 줄고 있지 않습니다. 이더리움 레이어2 솔루션은 이더리움 메인 체인 외부의 별개의 체인을 두어 확장성을 높이고 수수료 부담을 줄여줄 수 있는 솔루션으로써, 다양한 솔루션이 존재하며 성과도 나오고 있는 분야입니다. 이 글은 스마트 컨트랙트를 지원하는 레이어2 솔루션인 옵티미스틱 롤업의 설치 방법과 간략한 설명을 다루는 글입니다.</p>\n<h3>옵티미스틱 롤업 개요</h3>\n<p>옵티미스틱 롤업은 스마트 컨트랙트를 지원하는 이더리움 레이어2 솔루션이며, 스마트 컨트랙트를 지원한다는 것이 여러 레이어2 솔루션들과 비교했을 때 가장 차별화되는 부분입니다. 초기의 롤업은 레이어2에서 토큰 전송만을 지원하는 모델부터 시작했는데, 스마트 컨트랙트를 사용할 수 없기 때문에 굉장히 제한적으로 사용될 수밖에 없었습니다. 옵티미스틱 롤업은 레이어2에서도 스마트 컨트랙트를 지원하여, 현재 이더리움 생태계의 Dapp들을 레이어2에서 사용할 수 있도록 하는 것이 목표입니다.</p>\n<p>옵티미스틱 롤업은 레이어2에서 스마트 컨트랙트를 지원하고, 동시에 그러한 레이어2 컨트랙트 실행을 레이어1에서 검증할 수 있도록 하기 위해 EVM의 실행 환경을 가상화하여 OVM이라는 환경에서 트랜잭션을 실행합니다. OVM은 EVM과 호환되는 실행 환경으로써, EVM 위에서 실행되는 여러 컨트랙트로 구성됩니다. 레이어2의 트랜잭션들은 OVM 환경 내에서 실행되며, 레이어2의 트랜잭션들이 레이어1에서 검증될 때 레이어1의 EVM으로 직접 실행되는 것이 아니라 OVM 내에서 검증 과정을 거치게 됩니다.</p>\n<p>옵티미스틱 롤업은 스마트 컨트랙트를 지원하기 때문에 토큰 전송만을 지원하는 레이어2 솔루션들보다 복잡한 구조를 갖습니다. 옵티미스틱 롤업의 레이어2에서는 이더리움 메인 체인과 거의 같은 방식의 독자적인 체인을 갖고 있으며, 레이어2의 트랜잭션들은 이러한 레이어2 체인에서 실행됩니다. 또한 옵티미스틱 레이어2 체인은 스마트 컨트랙트를 지원하기 위해 이더리움 클라이언트를 조금 수정한 클라이언트를 사용하며, 레이어1과 레이어2의 중간 다리 역할을 하는 서비스들을 포함하고 있습니다. 아래에서 옵티미스틱 롤업을 사용해보기 위해 필요한 서비스들을 다루는 방법과, 각 서비스들의 간략한 설명을 다루겠습니다.</p>\n<h3>패키지들</h3>\n<p>옵티미스틱 롤업을 사용해보기 위해서는 많은 서비스들이 실행되어야 합니다. 테스트 용도의 레이어1, 레이어2 클라이언트는 물론이고, 중간 다리 역할을 하는 여러 서비스들도 실행되어야 합니다. optimism 저장소는 이러한 여러 패키지를 관리하는 Monorepo로써, 옵티미스틱 롤업을 실행할 때 필요한 모든 패키지들을 포함하고 있습니다. 또한, 많은 패키지들을 쉽게 관리하고 실행할 수 있도록 도커를 활용하고 있습니다. 아래에서는 optimism 저장소에 어떤 패키지들이 있는지, 각 패키지가 옵티미스틱 롤업에서 어떤 역할을 하는지 등의 간략한 설명과, 개인 PC에 옵티미스틱 롤업 환경을 어떻게 만들어 볼 수 있는지를 살펴보겠습니다.</p>\n<h4>저장소 정보</h4>\n<p>Repository : <a href="https://github.com/ethereum-optimism/optimism">https://github.com/ethereum-optimism/optimism</a></p>\n<p>Commit : 751e2be</p>\n<h4>주요 디렉토리</h4>\n<ul>\n<li>packages/contracts</li>\n<li>packages/data-transport-layer</li>\n<li>packages/batch-submitter</li>\n<li>packages/message-relayer</li>\n<li>l2geth</li>\n<li>integration-tests</li>\n<li>ops</li>\n</ul>\n<h4>packages/contracts</h4>\n<p>옵티미스틱 롤업에서 필요한 모든 컨트랙트를 관리합니다. 여기에는 EVM과 OVM에서 실행될 컨트랙트들이 모두 포함되어 있는데, 각 컨트랙트 파일 상단의 주석에서 간단한 설명을 참고할 수 있습니다.</p>\n<p>EVM용 컨트랙트는 일반적인 스마트 컨트랙트로써, 솔리디티로 구현한 파일을 일반적으로 사용하는 solc를 통해 컴파일합니다.</p>\n<p>OVM용 컨트랙트는 옵티미스틱 롤업의 가상 실행 환경 위에서 실행되는 컨트랙트로써, 솔리디티로 구현한 파일을 옵티미즘에서 제공하는 solc로 컴파일합니다. 옵티미스틱 롤업은 Layer1과 Layer2에서 동일한 실행 환경을 만들어 검증이 가능하도록 OVM이라는 가상 실행 환경을 제공하며, 일반적으로 EVM에서 실행되는 스마트 컨트랙트와는 조금의 차이가 있습니다.</p>\n<h4>packages/data-transport-layer</h4>\n<p>Layer1에서 발생한 이벤트를 모니터링하여 발생한 이벤트들에 대한 정보를 DB에 저장하고, 저장된 정보를 Layer2의 Sequencer(블록 생성자)가 가져갈 수 있는 기능을 제공합니다. Layer1과 Layer2를 연결하는 서비스 중 하나이며, 서비스 내에 있는 자체 DB에 정보를 쌓고 Layer2의 geth 노드가 필요한 정보들을 가져갈 수 있도록 서버 역할도 담당하는 서비스입니다.</p>\n<h4>packages/batch-submitter</h4>\n<p>Sequencer가 Layer2에서 발생한 트랜잭션들을 수집해 Layer1의 컨트랙트에 정보를 올리는 기능을 제공합니다.</p>\n<h4>packages/message-relayer</h4>\n<p>Layer2에서 발생한 트랜잭션이 Layer1에 등록된 후, 검증 기간이 지난 트랜잭션에 대한 상태를 확정시키는 기능을 제공합니다. 옵티미스틱 롤업은 Fraud proof 검증 방식을 사용하기 때문에, Layer2에서 실행된 트랜잭션이 확정된 뒤 반영되려면 추가적인 행동이 필요하며, message-relayer가 그러한 역할을 담당하게 됩니다.</p>\n<h4>l2geth</h4>\n<p>Layer2의 트랜잭션을 처리하는 클라이언트입니다. 옵티미스틱 롤업에서 필요한 Layer2 관련된 기능이 추가된 옵티미스틱 롤업 클라이언트입니다.</p>\n<h4>integration-tests</h4>\n<p>필요한 모든 서비스가 실행된 상태에서 통합 테스트를 해 볼 수 있습니다.</p>\n<h4>ops</h4>\n<p>옵티미스틱 롤업을 사용하기 위해 필요한 서비스들을 도커로 관리하는 디렉토리입니다. 도커로 패키지들을 관리하는 부분은 아래에서 설명합니다.</p>\n<h3>도커 환경</h3>\n<p>optimism 저장소에서는 많은 패키지들을 쉽게 관리할 수 있도록 도커를 활용하고 있습니다. 저장소 내의 각 패키지들은 별개의 도커로 실행되며, 패키지 실행 외에도 빌드, 배포, 테스트 등의 용도로 도커를 활용합니다. 아래에서는 각 도커 환경이 어떤 역할을 하며 어떤 관계로 구성되는지 설명합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/531/1*Bfz0swDuQPy_xk34xvJ3Fw.png"></figure><h4>builder</h4>\n<p>저장소 내의 패키지들을 빌드하는 용도로 사용합니다. 여기서 필요한 패키지들을 빌드하고 다른 서비스용 도커에서는 필요한 파일들을 가져가 사용합니다.</p>\n<h4>l1_chain</h4>\n<p>Layer1 노드 용도로 사용되는 도커입니다.</p>\n<h4>deployer</h4>\n<p>옵티미스틱 롤업에 필요한 컨트랙트들을 배포하는 도커입니다. contracts 패키지에 포함된 컨트랙트들을 배포합니다.</p>\n<h4>dtl</h4>\n<p>data-transport-layer 서비스용 도커입니다.</p>\n<h4>l2geth</h4>\n<p>Layer2 용도로 사용되는 도커입니다.</p>\n<h4>relayer</h4>\n<p>message-relayer 서비스용 도커입니다.</p>\n<h4>batch_submitter</h4>\n<p>batch-submitter 서비스용 도커입니다.</p>\n<h4>integration_tests</h4>\n<p>통합 서비스에 사용되는 도커입니다.</p>\n<h3>환경 구성하기</h3>\n<p>옵티미스틱 롤업을 사용하기 위한 환경을 구성하고 실행하여 테스트를 돌려볼 수 있는 명령어들을 소개합니다.</p>\n<h4>Clone repository</h4>\n<pre>$ git clone https://github.com/ethereum-optimism/optimism.git<br>$ cd optimism<br>$ yarn &amp;&amp; yarn build</pre>\n<h4>Unit test</h4>\n<pre>$ yarn test</pre>\n<h4>Run</h4>\n<pre>$ cd ops<br>$ export COMPOSE_DOCKER_CLI_BUILD=1<br>$ export DOCKER_BUILDKIT=1<br>$ docker-compose build<br>$ docker-compose up -d</pre>\n<h4>Integration test</h4>\n<pre>$ cd ../integration-tests<br>$ yarn build:integration<br>$ yarn test:integration</pre>\n<h3>추가: AWS내에 환경 구성</h3>\n<p>옵티미스틱 롤업 환경을 AWS와 같은 클라우드 환경으로 구성하여 외부에서 접근하려는 경우 필요한 포트를 열어야 합니다. 옵티미스틱 롤업의 Layer1, Layer2 노드에서 사용하는 RPC Endpoint 포트의 정보는 아래와 같습니다.</p>\n<p>Layer 1</p>\n<ul><li>9545 : http</li></ul>\n<p>Layer 2</p>\n<ul>\n<li>8545 : http</li>\n<li>8546 : ws</li>\n</ul>\n<h3>정리</h3>\n<p>옵티미스틱 롤업을 사용해보기 위한 환경의 구성과 그 안에 포함되는 여러 서비스들의 역할을 살펴보았습니다. 메인넷만을 위해 개발할 때는 ganache 등으로 쉽게 개발 환경을 구성해볼 수 있는데, 옵티미스틱 롤업의 경우 추가적으로 신경써주어야 할 부분은 있지만 자동화가 잘 되어있어서 개발 환경의 관리가 어렵지 않다는 것을 확인할 수 있었습니다. 이어지는 포스팅에서는 이렇게 구성한 옵티미스틱 롤업 환경 안에서 실제로 트랜잭션을 날려보면서 테스트해보는 방법에 대해 알아보겠습니다.</p>\n<h3>참조</h3>\n<p><a href="https://github.com/ethereum-optimism/optimism">Optimism Monorepo</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=390cd737c02f" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">옵티미즘 초보자 가이드 1편 : 환경설정 및 설치</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                content:
                  '\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*190PrSih_EcnzAd65Ptndw.png"></figure><h3>TL;DR</h3>\n<h4>Build repository</h4>\n<pre>$ git clone https://github.com/ethereum-optimism/optimism.git<br>$ cd optimism<br>$ yarn &amp;&amp; yarn build</pre>\n<h4>Unit test</h4>\n<pre>$ yarn test</pre>\n<h4>Run</h4>\n<pre>$ cd ops<br>$ export COMPOSE_DOCKER_CLI_BUILD=1<br>$ export DOCKER_BUILDKIT=1<br>$ docker-compose build<br>$ docker-compose up -d</pre>\n<h4>Integration test</h4>\n<pre>$ cd ../integration-tests<br>$ yarn build:integration<br>$ yarn test:integration</pre>\n<p>옵티미스틱 롤업 사용하기 시리즈는 총 세 개의 포스팅으로 구성됩니다.</p>\n<blockquote>\n<strong>옵티미스틱 롤업 사용하기</strong><br><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc20-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bc774f94d8b3">옵티미스틱 롤업에서 ERC20 사용하기</a><br><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85%EC%97%90%EC%84%9C-erc721-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-bb647362ec5d">옵티미스틱 롤업에서 ERC721 사용하기</a>\n</blockquote>\n<h3>들어가기 전에</h3>\n<p>이더리움은 업데이트를 통해 트랜잭션 수수료의 부담을 줄이기 위한 노력을 하고 있지만, 이더리움의 가격 상승과 트랜잭션 경쟁 심화 등의 이유로 수수료 부담은 크게 줄고 있지 않습니다. 이더리움 레이어2 솔루션은 이더리움 메인 체인 외부의 별개의 체인을 두어 확장성을 높이고 수수료 부담을 줄여줄 수 있는 솔루션으로써, 다양한 솔루션이 존재하며 성과도 나오고 있는 분야입니다. 이 글은 스마트 컨트랙트를 지원하는 레이어2 솔루션인 옵티미스틱 롤업의 설치 방법과 간략한 설명을 다루는 글입니다.</p>\n<h3>옵티미스틱 롤업 개요</h3>\n<p>옵티미스틱 롤업은 스마트 컨트랙트를 지원하는 이더리움 레이어2 솔루션이며, 스마트 컨트랙트를 지원한다는 것이 여러 레이어2 솔루션들과 비교했을 때 가장 차별화되는 부분입니다. 초기의 롤업은 레이어2에서 토큰 전송만을 지원하는 모델부터 시작했는데, 스마트 컨트랙트를 사용할 수 없기 때문에 굉장히 제한적으로 사용될 수밖에 없었습니다. 옵티미스틱 롤업은 레이어2에서도 스마트 컨트랙트를 지원하여, 현재 이더리움 생태계의 Dapp들을 레이어2에서 사용할 수 있도록 하는 것이 목표입니다.</p>\n<p>옵티미스틱 롤업은 레이어2에서 스마트 컨트랙트를 지원하고, 동시에 그러한 레이어2 컨트랙트 실행을 레이어1에서 검증할 수 있도록 하기 위해 EVM의 실행 환경을 가상화하여 OVM이라는 환경에서 트랜잭션을 실행합니다. OVM은 EVM과 호환되는 실행 환경으로써, EVM 위에서 실행되는 여러 컨트랙트로 구성됩니다. 레이어2의 트랜잭션들은 OVM 환경 내에서 실행되며, 레이어2의 트랜잭션들이 레이어1에서 검증될 때 레이어1의 EVM으로 직접 실행되는 것이 아니라 OVM 내에서 검증 과정을 거치게 됩니다.</p>\n<p>옵티미스틱 롤업은 스마트 컨트랙트를 지원하기 때문에 토큰 전송만을 지원하는 레이어2 솔루션들보다 복잡한 구조를 갖습니다. 옵티미스틱 롤업의 레이어2에서는 이더리움 메인 체인과 거의 같은 방식의 독자적인 체인을 갖고 있으며, 레이어2의 트랜잭션들은 이러한 레이어2 체인에서 실행됩니다. 또한 옵티미스틱 레이어2 체인은 스마트 컨트랙트를 지원하기 위해 이더리움 클라이언트를 조금 수정한 클라이언트를 사용하며, 레이어1과 레이어2의 중간 다리 역할을 하는 서비스들을 포함하고 있습니다. 아래에서 옵티미스틱 롤업을 사용해보기 위해 필요한 서비스들을 다루는 방법과, 각 서비스들의 간략한 설명을 다루겠습니다.</p>\n<h3>패키지들</h3>\n<p>옵티미스틱 롤업을 사용해보기 위해서는 많은 서비스들이 실행되어야 합니다. 테스트 용도의 레이어1, 레이어2 클라이언트는 물론이고, 중간 다리 역할을 하는 여러 서비스들도 실행되어야 합니다. optimism 저장소는 이러한 여러 패키지를 관리하는 Monorepo로써, 옵티미스틱 롤업을 실행할 때 필요한 모든 패키지들을 포함하고 있습니다. 또한, 많은 패키지들을 쉽게 관리하고 실행할 수 있도록 도커를 활용하고 있습니다. 아래에서는 optimism 저장소에 어떤 패키지들이 있는지, 각 패키지가 옵티미스틱 롤업에서 어떤 역할을 하는지 등의 간략한 설명과, 개인 PC에 옵티미스틱 롤업 환경을 어떻게 만들어 볼 수 있는지를 살펴보겠습니다.</p>\n<h4>저장소 정보</h4>\n<p>Repository : <a href="https://github.com/ethereum-optimism/optimism">https://github.com/ethereum-optimism/optimism</a></p>\n<p>Commit : 751e2be</p>\n<h4>주요 디렉토리</h4>\n<ul>\n<li>packages/contracts</li>\n<li>packages/data-transport-layer</li>\n<li>packages/batch-submitter</li>\n<li>packages/message-relayer</li>\n<li>l2geth</li>\n<li>integration-tests</li>\n<li>ops</li>\n</ul>\n<h4>packages/contracts</h4>\n<p>옵티미스틱 롤업에서 필요한 모든 컨트랙트를 관리합니다. 여기에는 EVM과 OVM에서 실행될 컨트랙트들이 모두 포함되어 있는데, 각 컨트랙트 파일 상단의 주석에서 간단한 설명을 참고할 수 있습니다.</p>\n<p>EVM용 컨트랙트는 일반적인 스마트 컨트랙트로써, 솔리디티로 구현한 파일을 일반적으로 사용하는 solc를 통해 컴파일합니다.</p>\n<p>OVM용 컨트랙트는 옵티미스틱 롤업의 가상 실행 환경 위에서 실행되는 컨트랙트로써, 솔리디티로 구현한 파일을 옵티미즘에서 제공하는 solc로 컴파일합니다. 옵티미스틱 롤업은 Layer1과 Layer2에서 동일한 실행 환경을 만들어 검증이 가능하도록 OVM이라는 가상 실행 환경을 제공하며, 일반적으로 EVM에서 실행되는 스마트 컨트랙트와는 조금의 차이가 있습니다.</p>\n<h4>packages/data-transport-layer</h4>\n<p>Layer1에서 발생한 이벤트를 모니터링하여 발생한 이벤트들에 대한 정보를 DB에 저장하고, 저장된 정보를 Layer2의 Sequencer(블록 생성자)가 가져갈 수 있는 기능을 제공합니다. Layer1과 Layer2를 연결하는 서비스 중 하나이며, 서비스 내에 있는 자체 DB에 정보를 쌓고 Layer2의 geth 노드가 필요한 정보들을 가져갈 수 있도록 서버 역할도 담당하는 서비스입니다.</p>\n<h4>packages/batch-submitter</h4>\n<p>Sequencer가 Layer2에서 발생한 트랜잭션들을 수집해 Layer1의 컨트랙트에 정보를 올리는 기능을 제공합니다.</p>\n<h4>packages/message-relayer</h4>\n<p>Layer2에서 발생한 트랜잭션이 Layer1에 등록된 후, 검증 기간이 지난 트랜잭션에 대한 상태를 확정시키는 기능을 제공합니다. 옵티미스틱 롤업은 Fraud proof 검증 방식을 사용하기 때문에, Layer2에서 실행된 트랜잭션이 확정된 뒤 반영되려면 추가적인 행동이 필요하며, message-relayer가 그러한 역할을 담당하게 됩니다.</p>\n<h4>l2geth</h4>\n<p>Layer2의 트랜잭션을 처리하는 클라이언트입니다. 옵티미스틱 롤업에서 필요한 Layer2 관련된 기능이 추가된 옵티미스틱 롤업 클라이언트입니다.</p>\n<h4>integration-tests</h4>\n<p>필요한 모든 서비스가 실행된 상태에서 통합 테스트를 해 볼 수 있습니다.</p>\n<h4>ops</h4>\n<p>옵티미스틱 롤업을 사용하기 위해 필요한 서비스들을 도커로 관리하는 디렉토리입니다. 도커로 패키지들을 관리하는 부분은 아래에서 설명합니다.</p>\n<h3>도커 환경</h3>\n<p>optimism 저장소에서는 많은 패키지들을 쉽게 관리할 수 있도록 도커를 활용하고 있습니다. 저장소 내의 각 패키지들은 별개의 도커로 실행되며, 패키지 실행 외에도 빌드, 배포, 테스트 등의 용도로 도커를 활용합니다. 아래에서는 각 도커 환경이 어떤 역할을 하며 어떤 관계로 구성되는지 설명합니다.</p>\n<figure><img alt="" src="https://cdn-images-1.medium.com/max/531/1*Bfz0swDuQPy_xk34xvJ3Fw.png"></figure><h4>builder</h4>\n<p>저장소 내의 패키지들을 빌드하는 용도로 사용합니다. 여기서 필요한 패키지들을 빌드하고 다른 서비스용 도커에서는 필요한 파일들을 가져가 사용합니다.</p>\n<h4>l1_chain</h4>\n<p>Layer1 노드 용도로 사용되는 도커입니다.</p>\n<h4>deployer</h4>\n<p>옵티미스틱 롤업에 필요한 컨트랙트들을 배포하는 도커입니다. contracts 패키지에 포함된 컨트랙트들을 배포합니다.</p>\n<h4>dtl</h4>\n<p>data-transport-layer 서비스용 도커입니다.</p>\n<h4>l2geth</h4>\n<p>Layer2 용도로 사용되는 도커입니다.</p>\n<h4>relayer</h4>\n<p>message-relayer 서비스용 도커입니다.</p>\n<h4>batch_submitter</h4>\n<p>batch-submitter 서비스용 도커입니다.</p>\n<h4>integration_tests</h4>\n<p>통합 서비스에 사용되는 도커입니다.</p>\n<h3>환경 구성하기</h3>\n<p>옵티미스틱 롤업을 사용하기 위한 환경을 구성하고 실행하여 테스트를 돌려볼 수 있는 명령어들을 소개합니다.</p>\n<h4>Clone repository</h4>\n<pre>$ git clone https://github.com/ethereum-optimism/optimism.git<br>$ cd optimism<br>$ yarn &amp;&amp; yarn build</pre>\n<h4>Unit test</h4>\n<pre>$ yarn test</pre>\n<h4>Run</h4>\n<pre>$ cd ops<br>$ export COMPOSE_DOCKER_CLI_BUILD=1<br>$ export DOCKER_BUILDKIT=1<br>$ docker-compose build<br>$ docker-compose up -d</pre>\n<h4>Integration test</h4>\n<pre>$ cd ../integration-tests<br>$ yarn build:integration<br>$ yarn test:integration</pre>\n<h3>추가: AWS내에 환경 구성</h3>\n<p>옵티미스틱 롤업 환경을 AWS와 같은 클라우드 환경으로 구성하여 외부에서 접근하려는 경우 필요한 포트를 열어야 합니다. 옵티미스틱 롤업의 Layer1, Layer2 노드에서 사용하는 RPC Endpoint 포트의 정보는 아래와 같습니다.</p>\n<p>Layer 1</p>\n<ul><li>9545 : http</li></ul>\n<p>Layer 2</p>\n<ul>\n<li>8545 : http</li>\n<li>8546 : ws</li>\n</ul>\n<h3>정리</h3>\n<p>옵티미스틱 롤업을 사용해보기 위한 환경의 구성과 그 안에 포함되는 여러 서비스들의 역할을 살펴보았습니다. 메인넷만을 위해 개발할 때는 ganache 등으로 쉽게 개발 환경을 구성해볼 수 있는데, 옵티미스틱 롤업의 경우 추가적으로 신경써주어야 할 부분은 있지만 자동화가 잘 되어있어서 개발 환경의 관리가 어렵지 않다는 것을 확인할 수 있었습니다. 이어지는 포스팅에서는 이렇게 구성한 옵티미스틱 롤업 환경 안에서 실제로 트랜잭션을 날려보면서 테스트해보는 방법에 대해 알아보겠습니다.</p>\n<h3>참조</h3>\n<p><a href="https://github.com/ethereum-optimism/optimism">Optimism Monorepo</a></p>\n<img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=390cd737c02f" width="1" height="1" alt=""><hr>\n<p><a href="https://medium.com/onther-tech/%EC%98%B5%ED%8B%B0%EB%AF%B8%EC%8A%A4%ED%8B%B1-%EB%A1%A4%EC%97%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-390cd737c02f">옵티미즘 초보자 가이드 1편 : 환경설정 및 설치</a> was originally published in <a href="https://medium.com/onther-tech">Onther</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n',
                enclosure: {},
                categories: [
                  "optimism",
                  "optimistic-rollup",
                  "research",
                  "layer-2",
                  "ethereum",
                ],
              },
            ],
          };
          commit("SET_POSTS", contents.items);
        });
    },
  },
  modules: {},
});
